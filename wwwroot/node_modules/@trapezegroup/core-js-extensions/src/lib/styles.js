/* eslint-disable guard-for-in */
/* eslint-disable no-continue */
/* eslint-disable no-cond-assign */
/* eslint-disable no-plusplus */
/* eslint-disable no-prototype-builtins */
/* eslint-disable no-restricted-syntax */
/* eslint-disable no-multi-assign */
/* eslint-disable func-names */
/* eslint-disable no-param-reassign */
/* eslint-disable prefer-destructuring */
// @ts-check

// TODO - splitinto separate files
import { Color } from './color.js';
import { dasherize, underscore, camelize, compareRight } from './string.js';
import { clone } from './json.js';

/** @typedef {HTMLElement|CSSStyleRule} ObjWithStyles */
/** @typedef {HTMLElement|CSSStyleRule|CSSStyleDeclaration} ObjWithStylesExt */
/** @typedef {{ name: string; value: string; important: string; disabled: boolean; }} StyleEntry */

/**
 * @param {any} _
 * @param {any} skip
 * @param {any} remove
 * @param {any} whitespace
 * @returns {string}
 */
const stripUnitsReplacer = function stripUnitsReplacer(_, skip, remove, whitespace) {
    return skip || `0${whitespace}`;
};

/**
 * @param {StyleEntry[]} props
 */
const sortProperties = function sortProperties(props) {
    props.sort((a, b) => (a.name > b.name ? 1 : -1));
};

const inheritedStyleNames = {
    azimuth: 1,
    'border-collapse': 1,
    'border-spacing': 1,
    'border-style': 1,
    'caption-side': 1,
    color: 1,
    cursor: 1,
    direction: 1,
    elevation: 1,
    'empty-cells': 1,
    font: 1,
    'font-family': 1,
    'font-size-adjust': 1,
    'font-size': 1,
    'font-style': 1,
    'font-variant': 1,
    'font-weight': 1,
    'letter-spacing': 1,
    'line-height': 1,
    'list-style': 1,
    'list-style-image': 1,
    'list-style-position': 1,
    'list-style-type': 1,
    orphans: 1,
    'pitch-range': 1,
    pitch: 1,
    quotes: 1,
    richness: 1,
    'speak-header': 1,
    'speak-numeral': 1,
    'speak-punctuation': 1,
    speak: 1,
    'speech-rate': 1,
    stress: 1,
    'text-align': 1,
    'text-decoration': 1,
    'text-indent': 1,
    'text-shadow': 1,
    'text-transform': 1,
    visibility: 1,
    'voice-family': 1,
    volume: 1,
    'white-space': 1,
    widows: 1,
    'word-spacing': 1,
};

const reSelectorTag = /(^|\s)(?:[\w\*(\w\\\:\w)?]+)/gi;
const reSelectorClass = /\.[\w\d_-]+/g;
const reSelectorId = /#[\w\d_-]+/gi;
const reAttribute = /\[[^\]]+\]/gi;
// const rePseudoClasses = /:[\w\d_-]+/gi;

/**
 * @param {CSSStyleRule} style
 * @param {any} inheritMode
 * @returns {StyleEntry[]}
 */
const parseCSSProps = function(style, inheritMode) {
    const props = [];
    const lines = style.cssText.match(/(?:[^;\(]*(?:\([^\)]*?\))?[^;\(]*)*;?/g);
    const propRE = /\s*([^:\s]*)\s*:\s*(.*?)\s*(! important)?;?$/;
    let line;
    let i = 0;
    let m;
    // TODO: xxxpedro port to firebug: variable leaked into global namespace

    while ((line = lines[i++])) {
        m = propRE.exec(line);
        if (!m) continue;
        // let name = m[1], value = m[2], important = !!m[3];
        if (m[2]) addProperty(m[1], m[2], !!m[3], false, inheritMode, props);
    }

    return props;
};

/**
 * @param {{ selectorMap: { [x: string]: any; }; }} context
 * @param {string} ruleId
 * @param {any} inheritMode
 * @param {any[]} props
 */
const addOldProperties = function(context, ruleId, inheritMode, props) {
    if (this.selectorMap && this.selectorMap.hasOwnProperty(ruleId)) {
        const moreProps = context.selectorMap[ruleId];
        let prop;
        for (let i = 0; i < moreProps.length; ++i) {
            prop = moreProps[i];
            addProperty(prop.name, prop.value, prop.important, true, inheritMode, props);
        }
    }
};

/**
 * @param {string} name
 * @param {string} value
 * @param {string | boolean} important
 * @param {boolean} disabled
 * @param {any} inheritMode
 * @param {StyleEntry[]} props
 */
let addProperty = function(name, value, important, disabled, inheritMode, props) {
    name = name.toLowerCase();

    if (inheritMode && !inheritedStyleNames[name]) return;

    name = translateName(name, value);
    if (name) {
        value = stripUnits(rgbToHex(value));
        important = important ? ' !important' : '';

        const prop = { name, value, important, disabled };
        props.push(prop);
    }
};

/**
 * @param {string} name
 * @param {string} value
 * @returns {?string}
 */
let translateName = function(name, value) {
    // Don't show these proprietary Mozilla properties
    if (
        (value === '-moz-initial' &&
            (name === '-moz-background-clip' ||
                name === '-moz-background-origin' ||
                name === '-moz-background-inline-policy')) ||
        (value === 'physical' &&
            (name === 'margin-left-ltr-source' ||
                name === 'margin-left-rtl-source' ||
                name === 'margin-right-ltr-source' ||
                name === 'margin-right-rtl-source')) ||
        (value === 'physical' &&
            (name === 'padding-left-ltr-source' ||
                name === 'padding-left-rtl-source' ||
                name === 'padding-right-ltr-source' ||
                name === 'padding-right-rtl-source'))
    )
        return null;

    // Translate these back to the form the user probably expects
    if (name === 'margin-left-value') return 'margin-left';
    else if (name === 'margin-right-value') return 'margin-right';
    else if (name === 'margin-top-value') return 'margin-top';
    else if (name === 'margin-bottom-value') return 'margin-bottom';
    else if (name === 'padding-left-value') return 'padding-left';
    else if (name === 'padding-right-value') return 'padding-right';
    else if (name === 'padding-top-value') return 'padding-top';
    else if (name === 'padding-bottom-value') return 'padding-bottom';
    // XXXjoe What about border!
    return name;
};

/**
 * @param {string} value
 * @returns {string}
 */
let stripUnits = function(value) {
    // remove units from '0px', '0em' etc. leave non-zero units in-tact.
    return value.replace(/(url\(.*?\)|[^0]\S*\s*)|0(%|em|ex|px|in|cm|mm|pt|pc)(\s|$)/gi, stripUnitsReplacer);
};

/**
 * @param {string} value
 * @returns {string}
 */
let rgbToHex = function(value) {
    return value.replace(/\brgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)/gi, rgbToHexReplacer);
};

/**
 * @param {any} _
 * @param {number} r
 * @param {number} g
 * @param {number} b
 * @returns {string}
 */
let rgbToHexReplacer = function(_, r, g, b) {
    // eslint-disable-next-line no-bitwise
    return `#${((1 << 24) + (r << 16) + (g << 8) + (b << 0))
        .toString(16)
        .substr(-6)
        .toUpperCase()}`;
};

const styleSheetLoadcontexts = {};
/**
 * @param {string} url
 */
const styleSheetReleaseCallbacks = function(url) {
    const context = styleSheetLoadcontexts[url];
    if (context) {
        const callbacks = context.callbacks;
        for (let i = 0, iLen = callbacks.length; i < iLen; i++) {
            callbacks[i]();
        }
        delete styleSheetLoadcontexts[url];
    }
};
let styleSheetTimer = null;
/** */
const styleSheetWatcher = function() {
    const contexts = styleSheetLoadcontexts;
    for (const url in contexts) {
        if (isStyleSheetReady(contexts[url].link)) styleSheetReleaseCallbacks(url);
    }
    if (Object.keys(contexts).length > 0) styleSheetTimer = setTimeout(styleSheetWatcher, 100);
    else styleSheetTimer = null;
};

/**
 * @param {HTMLLinkElement} linkElem
 * @param {Function} callback
 */
const styleSheetLoadWatcher = function(linkElem, callback) {
    const context =
        styleSheetLoadcontexts[linkElem.href] ||
        (styleSheetLoadcontexts[linkElem.href] = {
            callbacks: [],
            link: linkElem,
        });
    context.callbacks.push(callback);

    if (isStyleSheetReady(linkElem)) {
        styleSheetReleaseCallbacks(linkElem.href);
    } else if (!styleSheetTimer) {
        setTimeout(styleSheetWatcher, 100);
    }
};

/**
 * @param {HTMLLinkElement} sheet
 * @returns {boolean}
 */
let isStyleSheetReady = function(sheet) {
    const styleSheet = sheet.sheet;
    if (styleSheet && styleSheet instanceof CSSStyleSheet)
        // Accessing cssRules property while CSS is being parsed throws InvalidAccessError exception in Firefox
        // https://bugzilla.mozilla.org/show_bug.cgi?id=761236
        try {
            return !!(styleSheet.rules || styleSheet.cssRules);
        } catch (e) {
            return false;
        }
    return false;
};

/**
 * @param {CSSStyleSheet} sheet
 * @param {{ (sheet: CSSStyleSheet): boolean;}} callback
 * @returns {boolean}
 */
export function forEachSheet(sheet, callback) {
    try {
        // .imports is IE specific (nice optimization, no need to scan all rules)
        const sheets = sheet ? sheet.imports : document.styleSheets;
        const uriPattern = /(?:[a-z]+?):\/\/([a-z0-9-.]+(?::\d+)?)+/i;

        if (sheets) {
            for (let i = 0, n = sheets.length; i < n; i++) {
                const _sheet = sheets[i];

                if (
                    _sheet instanceof CSSStyleSheet &&
                    (!_sheet.href || uriPattern.exec(_sheet.href)[1] === location.host)
                ) {
                    if (callback(_sheet)) return true;
                    if (forEachSheet(_sheet, callback)) return true;
                }
            }
        } // go through the rules looking for @import
        else {
            const sheetRules = sheet.cssRules;
            for (let r = 0, n = sheetRules.length; r < n; r++) {
                const styleSheetRule = sheetRules[r];
                if (styleSheetRule instanceof CSSImportRule) {
                    const _sheet = styleSheetRule.styleSheet;
                    if (_sheet) {
                        if (callback(_sheet)) return true;

                        if (forEachSheet(_sheet, callback)) return true;
                    }
                }
            }
        }
    } catch (e) {
        // workaround for the Firefox "Security error" code: "1000" when using file:// protocol.
        // reproducible with gridEditable.html, etc. where the page runs from filesystem.
        // console.log(e);
    }
    return false;
}

/**
 * @param {string} url
 * @return {CSSStyleSheet}
 */
export function getSheet(url) {
    const data = { url };

    forEachSheet(null, sheet => {
        const href = sheet.href ? sheet.href.split('?')[0] : sheet.href;
        if ((!href && data.url == null) || (href && compareRight(href, url, true))) {
            data.sheet = sheet;
            return true;
        }
        return false;
    });
    return data.sheet;
}

const _ruleProcessedSheets = [];
const _ruleSelectorCache = [];

/**
 * @param {CSSStyleSheet} sheet
 * @param {string} selector
 * @returns {CSSRule[]}
 */
export function getRulesFromSheet(sheet, selector) {
    if (selector == null) return Array.from(sheet.rules || sheet.cssRules);

    const rules = [];
    const sanitize = /\\|'|"/g;
    let cache;
    let selector2;
    if (selector) selector2 = selector.replace(sanitize, '').toLowerCase();
    if (sheet) {
        // let start = new Date;
        let ruleCacheIndex = _ruleProcessedSheets.indexOf(sheet);

        if (ruleCacheIndex > -1) {
            cache = _ruleSelectorCache[ruleCacheIndex];
            for (let i = 0, sheetRules = sheet.rules || sheet.cssRules, size = cache.length; i < size; i++)
                if (cache[i].indexOf(selector2) > -1) rules[rules.length] = sheetRules[i];
            // console.log((new Date) - start + " -- Using Cache");
        } else {
            ruleCacheIndex = _ruleProcessedSheets.push(sheet) - 1;
            cache = _ruleSelectorCache[ruleCacheIndex] = [];

            for (
                let r = 0, rule, ruleSelectorText, sheetRules = sheet.rules || sheet.cssRules, n = sheetRules.length;
                r < n;
                r++
            ) {
                rule = sheetRules[r];
                if (rule instanceof CSSStyleRule) {
                    // TODO - need more accurate match
                    ruleSelectorText = rule.selectorText;
                    ruleSelectorText = ruleSelectorText && ruleSelectorText.replace(sanitize, '').toLowerCase();

                    if (selector == null || (ruleSelectorText && ruleSelectorText.indexOf(selector2) >= 0)) {
                        // rule.sheetUrl = sheet.href;
                        rules[rules.length] = rule;
                    }
                    // @ts-ignore
                    cache[cache.length] = ruleSelectorText || '';
                }
            }
            // console.log((new Date) - start);
        }
    }

    return rules;
}

/**
 * @param {string} [selector]
 * @returns {CSSStyleRule[]}
 */
export function getRules(selector) {
    const data = { rules: [], selector };

    forEachSheet(
        null,
        /**
         * @param {CSSStyleSheet} sheet
         */
        sheet => {
            data.rules = data.rules.concat(getRulesFromSheet(sheet, data.selector));
            return false;
        },
    );
    return data.rules;
}

/**
 * @param {CSSStyleRule[]} rules
 * @returns {any}
 */
export function getStyleFromRules(rules) {
    const style = {};
    for (let i = 0, n = rules.length; i < n; i++) {
        const rule = rules[i];
        const cssText = rule.style.cssText;
        const entries = cssText.split(';');
        for (let e = 0; e < entries.length; e++) {
            const entry = entries[e].split(': '); // some browsers expand urls to http://domain, but all have ": " after the attribute name
            if (entry.length === 2) style[entry[0].trim().toLowerCase()] = entry[1].trim(); // IE8 uses uppercase rules by default
        }
    }
    return style;
}

/**
 * @param {CSSRule[]} rules
 * @returns {CSSStyleRule[]}
 */
function filterCssStyleRules(rules) {
    return _ruleSelectorCache.filter(rule => rule instanceof CSSStyleRule);
}

/** Get the style object from styles sheets for a given selector. Styles sheets are searched for the given selector and, if found, the style Object is returned.
 * @param {String} selector -  A valid CSS selector to search for.
 * @param {String|Object} [sheet] - Specify which style sheet to search. This make the process much quicker. If not specified all style sheet in memory are searched. Defining this not only speeds up performance but also reduces risk of seleotor name collisions. Can be a StyleSheet object or URL.
 * @returns {CSSStyleRule[]} If the selector was found then the styles contained in that CSS rule are returned.
 */
export function getStyleDeclaration(selector, sheet) {
    if (sheet !== undefined) {
        if (typeof sheet === 'string') sheet = getSheet(sheet);
        const rules = getRulesFromSheet(sheet, selector);
        return getStyleFromRules(rules.length ? filterCssStyleRules(rules) : getRules(selector));
    }
    return getStyleFromRules(getRules(selector));
}

/**
 * @param {string} selector
 * @return {number};
 */
export function getCSSRuleSpecificity(selector) {
    let match = selector.match(reSelectorTag);
    const tagCount = match ? match.length : 0;

    match = selector.match(reSelectorClass);
    const classCount = match ? match.length : 0;

    match = selector.match(reSelectorId);
    const idCount = match ? match.length : 0;

    match = selector.match(reAttribute);
    const attCount = match ? match.length : 0;

    return tagCount + 10 * classCount + 100 * idCount + 10 * attCount;
}

/**
 * @param {any} context
 * @param {{ style: any; selectorText: any; }} rule
 * @param {any} inheritMode
 * @returns {StyleEntry[]}
 */
export function getRuleProperties(context, rule, inheritMode) {
    const props = parseCSSProps(rule.style, inheritMode);
    // let line = domUtils.getRuleLine(rule);
    let line;
    const ruleId = `${rule.selectorText}/${line}`;
    addOldProperties(context, ruleId, inheritMode, props);
    sortProperties(props);

    return props;
}

/**
 * @param {string} overlayName
 * @returns {CSSStyleRule|HTMLElement}
 */
export function getOverlayStyle(overlayName) {
    const doc = document;
    const proto = doc.getElementById(overlayName);

    if (proto) return proto;

    const sheetCount = doc.styleSheets ? doc.styleSheets.length : 0;
    let selectedRule = null;

    for (let ix = 0; ix < sheetCount; ix++) {
        const rules = getRules();
        let i = 0;
        const size = rules.length;
        let rule = null;

        // selectorText containing element tags names are lowercase in webkit
        overlayName = overlayName.toLowerCase();
        for (; i < size; i++)
            if (rules[i].selectorText && rules[i].selectorText.toLowerCase() === overlayName) rule = rules[i];

        if (rule) selectedRule = rule;
    }

    return selectedRule;
}

/**
 * Returns TRUE when the specified value matches the beginning of the string.
 * @param {string} str
 * @param {String} value - String to match against.
 * @param {Boolean} [caseInsensitive] - Set to TRUE for case-insensitive.
 * @returns {Boolean} TRUE when the string matches the specified value.
 */
function compareLeft(str, value, caseInsensitive) {
    const regexEscapedValue = value.replace(/[\.\^\$\*\+\-\?\(\)\[\]\{\}\\\|]/g, g1 => `\\${g1}`);
    return new RegExp(`^${regexEscapedValue}`, caseInsensitive ? 'i' : undefined).test(this);
}

/**
 * Dynamically loads a style sheet to the web page and optionally invokes a callback when the new stylesheet is ready.
 * @param {String} url - the url of the Style Sheet to load.
 * @param {Function} [callback] - Optional callback to invoke when the style is loaded and ready.
 * @returns {boolean}
 */
export function load(url, callback) {
    const urlLowercase = url.toLowerCase();
    const doc = document;
    const head = doc.getElementsByTagName('HEAD')[0];
    const links = head.getElementsByTagName('LINK');
    for (let i = 0; i < links.length; i++) {
        if (compareLeft(links[i].getAttribute('href').toLowerCase(), urlLowercase)) {
            const linkElem = links[i];
            if (callback && linkElem instanceof HTMLLinkElement) styleSheetLoadWatcher(linkElem, callback);
            return false;
        }
    }
    const node = new HTMLLinkElement();
    node.type = 'text/css';
    node.rel = 'stylesheet';
    node.href = urlLowercase;
    if (callback) styleSheetLoadWatcher(node, callback);

    head.appendChild(node);
    return true;
}

/** CSS Style Rule model */
export class StyleRule {
    /** Removes and disposes of all dynamically added rules. */
    static dispose() {
        document.getElementsByTagName('head')[0].removeChild(StyleRule.sheetElem);
        StyleRule.sheetElem = null;
    }

    /** Dynamically adds CSS Rules to the current page. A cache of Rules is kept using the selector as a key. If the same selector already exists than the existing Rule belonging to that selector has its cssText replaced and is returned.
     * @param {string} selector - The CSS selector for this new Rule.
     * @param {string} cssText - The CSS text to add to this Rule.
     * @param {string} [media] - The CSS media type. Defaults to 'screen'.
     */
    constructor(selector, cssText, media) {
        if (StyleRule._cache[selector]) {
            StyleRule._cache[selector].setCssText(cssText);
            return StyleRule._cache[selector];
        }

        // Ignoring randomly generated id selector, caching them long-term is not efficient since it doesn't get reused when an aframe updates
        if (selector.indexOf('anonymous_element') === -1) StyleRule._cache[selector] = this;

        // TODO should each instance have their own style element?
        if (!StyleRule.sheetElem) {
            const cssElem = document.createElement('style');
            cssElem.type = 'text/css';
            cssElem.media = media || 'screen';
            document.getElementsByTagName('head')[0].appendChild(cssElem);
            StyleRule.sheetElem = cssElem;
        }

        const sheet = StyleRule.sheetElem.sheet;

        if (sheet instanceof CSSStyleSheet) {
            sheet.insertRule
                ? sheet.insertRule(`${selector}{${cssText || ''}}`, sheet.cssRules.length)
                : sheet.addRule(selector, cssText || ' ');
            const styleRule = sheet.cssRules
                ? sheet.cssRules[sheet.cssRules.length - 1]
                : sheet.rules[sheet.rules.length - 1];
            if (styleRule instanceof CSSStyleRule) {
                this._rule = styleRule;
            }
        }
    }

    /** Replaces the current selector text. If another StyleRule exists with the same selector it will be cleared and removed.
     * @param {string} selector - The selector to set.
     * @returns {StyleRule} This rule so that it can be used in chaining.
     */
    setSelector(selector) {
        if (StyleRule._cache[selector]) StyleRule._cache[selector].remove();
        StyleRule._cache[selector] = this;
        if (this._rule instanceof CSSStyleRule) this._rule.selectorText = selector;
        // TODO handle IE8 multi selector that creates multiple rules. Best delete rules and recreate.
        return this;
    }

    /** Replaces the current cssText
     * @param {String|Object} cssText - cssText, style map or class name. If Class Name is passed through, the style map is generated based on that class name.
     * @param {boolean} append=true - whether to append or repalce the existing cssText.
     * @returns {StyleRule} This rule so that it can be used in chaining.
     */
    setStyles(cssText, append) {
        if (this._rule.parentStyleSheet && this._rule instanceof CSSStyleRule) {
            if (append === false && this._rule.style.cssText) this._rule.style.cssText = '';
            setStyle(this._rule, cssText);
        }
        return this;
    }

    /** Replaces the current cssText
     * @param {string} cssText - The cssText to set.
     * @returns {StyleRule} This rule so that it can be used in chaining.
     */
    setCssText(cssText) {
        return this.setStyles(cssText, false);
    }

    /** Removes the Rule from the DOM */
    remove() {
        const r = StyleRule;
        const { selectorText } = this._rule;
        if (r.sheetElem) {
            const sheet = StyleRule.sheetElem.sheet;
            const rules = [this._rule];
            if (sheet instanceof CSSStyleSheet) {
                const cssRules = sheet.cssRules ? sheet.cssRules : sheet.rules;
                const removeMethod = sheet.deleteRule ? 'deleteRule' : 'removeRule';
                for (let i = 0, iLen = rules.length; i < iLen; i++)
                    for (let j = 0, jLen = cssRules.length; j < jLen; j++)
                        if (cssRules[j] === rules[i]) sheet[removeMethod](j);
            }
        }
        StyleRule._cache[selectorText] = null;
    }
}

/** @type {HTMLStyleElement} */
StyleRule.sheetElem = null;

StyleRule._cache = {};

/**
 *
 * @param {HTMLElement | CSSStyleRule} element
 * @param {number|string} value
 * @returns {HTMLElement | CSSStyleRule}
 */
export function setOpacity(element, value) {
    // eslint-disable-next-line no-nested-ternary
    element.style.opacity = value === 1 || value === '' ? '' : value < 0.00001 ? '0' : `${value}`;
    return element;
}

/**
 * @param {ObjWithStyles} element
 * @param {string|object} styles
 * @returns {ObjWithStyles}
 */
function _setStyle(element, styles) {
    const elementStyle = element instanceof HTMLElement ? element.style : element;
    if (typeof styles === 'string') {
        // @ts-ignore
        elementStyle.cssText += `;${styles}`;
        // @ts-ignore
        return styles.indexOf('opacity') > -1
            ? setOpacity(element, styles.match(/opacity:\s*(\d?\.?\d*)/)[1])
            : element;
    }
    // eslint-disable-next-line no-restricted-syntax
    for (const property in styles)
        if (property === 'opacity') setOpacity(element, styles[property]);
        else elementStyle[property === 'float' || property === 'cssFloat' ? 'cssFloat' : property] = styles[property];

    return element;
}

/**
 * Prototype.js setStyle has been over ridden to provide extra functionality. This function should be used for setting multiple styles in one shot. For single styles just use {code}element.<styleName> = <value>{code}
 * @param {String | Object} styles - If Class Name is passed through, the style map is generated based on that class name.
 * @param {ObjWithStyles} element
 * @returns {ObjWithStyles} current element
 */
export function setStyle(element, styles) {
    if (typeof styles === 'string' && styles.indexOf(';') === -1) {
        // eslint-disable-next-line no-param-reassign
        styles = compute(
            element instanceof Element ? element.tagName : null,
            styles,
            element instanceof HTMLElement && element.parentNode instanceof HTMLElement ? element.parentNode : null,
        );
        setStyleUnsafe(element, styles);
        return element;
    }

    if (typeof styles !== 'string') {
        let cssText = '';
        // eslint-disable-next-line no-restricted-syntax
        for (const attributeName in styles)
            if (Object.prototype.hasOwnProperty.call(styles, attributeName)) {
                if (styles[attributeName] != null && typeof styles[attributeName] !== 'function')
                    cssText += `${attributeName}:${styles[attributeName]};`;
                // eslint-disable-next-line no-param-reassign
                styles = cssText;
            }
    }
    if (styles.indexOf('linear-gradient') > -1) {
        const matches = styles.match(
            /linear-gradient\(\s*(?:((?:(?:-?[0-9]*\.?[0-9]+)deg|0))\s*,)?\s*((?:(?:(?:(?:(?:red|tan|grey|gray|lime|navy|blue|teal|aqua|cyan|gold|peru|pink|plum|snow|[a-z]{5,20}))|(?:(?:rgb|hsl)a?\((?:\s*(?:-?[0-9]*\.?[0-9]+)%?\s*,?\s*){3,4}\))|(?:#(?:[0-9a-f]{1,2}){3})))\s*(?:(?:-?[0-9]*\.?[0-9]+)(?:%|px|mm|cm|in|em|rem|en|ex|ch|vm|vw|vh)|0)?)\s*)?,?\s*((?:(?:(?:(?:(?:(?:(?:red|tan|grey|gray|lime|navy|blue|teal|aqua|cyan|gold|peru|pink|plum|snow|[a-z]{5,20}))|(?:(?:rgb|hsl)a?\((?:\s*(?:-?[0-9]*\.?[0-9]+)%?\s*,?\s*){3,4}\))|(?:#(?:[0-9a-f]{1,2}){3})))\s*(?:(?:-?[0-9]*\.?[0-9]+)(?:%|px|mm|cm|in|em|rem|en|ex|ch|vm|vw|vh)|0)?)\s*)+))\)?/i,
        );

        let startColor = matches[2];
        let endColor = matches[3];
        if (!startColor) {
            startColor = endColor;
            endColor = null;
        }
        const colorObj = new Color(startColor);

        if (!endColor) {
            colorObj.r = Math.round(colorObj.r / 2);
            colorObj.g = Math.round(colorObj.g / 2);
            colorObj.b = Math.round(colorObj.b / 2);
            endColor = colorObj.toCss(true);
        }
        let linearGrad = '';
        const ieStartColor = colorObj.setColor(startColor).toHex();
        const ieEndColor = colorObj.setColor(endColor).toHex();
        linearGrad += `filter: progid:DXImageTransform.Microsoft.gradient(GradientType=0, startColorStr='${ieStartColor}', EndColorStr='${ieEndColor}');`;
        const angle = matches[1] || '-90deg';
        linearGrad += `background-image: -webkit-linear-gradient(${angle}, ${startColor}, ${endColor});`;
        linearGrad += `background-image: -moz-linear-gradient(${angle}, ${startColor}, ${endColor});`;
        linearGrad += `background-image: -ms-linear-gradient(${angle}, ${startColor}, ${endColor});`;
        linearGrad += `background-image: -o-linear-gradient(${angle}, ${startColor}, ${endColor});`;
        linearGrad += `background-image: linear-gradient(${angle}, ${startColor}, ${endColor});`;
        const linGrad = matches[0].replace(/\(/g, '\\(').replace(/\)/g, '\\)');
        // eslint-disable-next-line no-param-reassign
        styles = styles.replace(new RegExp(`background.*${linGrad}\s*;*`), linearGrad);
    }
    return _setStyle(element, styles);
}

/** Calculates what styles the browser would apply to element with a given className appended to a given parent. The element is assumed to be appended
 * to the end of the parentElem childNodes.
 * Usage: Calculating styles that would be applied to an Element when assigned a className without actually assigning the className.
 * @param {String|Element} tagName - The {Element} that will be used to compute the style. If this argument is a String then a temporary {Element} with the tagName is created.
 * @param {String} className -
 * @param {HTMLElement} parentElem
 * @param {object} [stylePrefixesToInclude]
 * @param {object} [styleMap]
 * @returns {Object} An Object containing the styles found and their values is returned.
 */
export function compute(tagName, className, parentElem, stylePrefixesToInclude, styleMap) {
    let tempElem;
    let tempIsExisting = false;
    if (tagName instanceof Element) {
        // eslint-disable-next-line no-param-reassign
        stylePrefixesToInclude = className;
        // eslint-disable-next-line no-param-reassign
        styleMap = parentElem;
        // eslint-disable-next-line no-param-reassign
        ({ className } = tagName);
        // @ts-ignore
        // eslint-disable-next-line no-param-reassign
        parentElem = tagName.parentNode;
        tempElem = tagName;
        // eslint-disable-next-line no-param-reassign
        ({ tagName } = tagName);
        tempIsExisting = true;
    }
    // eslint-disable-next-line no-param-reassign
    tagName = tagName || 'div';
    // eslint-disable-next-line no-param-reassign
    parentElem = parentElem || document.body;
    if (!tempIsExisting) {
        tempElem = document.createElement(tagName);
        tempElem.className = className;
        parentElem.appendChild(tempElem);
    }
    const controlElem = document.createElement(tagName);
    parentElem.appendChild(controlElem);
    // eslint-disable-next-line no-param-reassign
    styleMap = styleMap || {};
    const styles = tempElem instanceof HTMLElement && getStyle(tempElem);
    const controlStyles = getStyle(controlElem);

    // Cross browser support of iterating through computed styles.
    // WebKit does not support for in on the CssStyle object.
    // FF Supports Array based for loop and for in.
    // IE The CssStyle does not have array entries or length so we need to do a for in.
    // So we need to test if the CssStyle has an array and iterate through it otherwise we use the for in over the object.
    if (styles.length !== undefined) {
        if (!_camelizedProperties) {
            _camelizedProperties = {};
            for (let i = 0; i < styles.length; i++) _camelizedProperties[styles[i]] = styles[i].camelize();
        }
        let name;
        for (let i = 0; i < styles.length; i++) {
            name = _camelizedProperties[styles[i]];
            if (
                styles[name] &&
                controlStyles[name] !== styles[name] &&
                (!stylePrefixesToInclude || stylePrefixesToInclude[name.substring(0, 4)]) &&
                styles[name].length > 0 &&
                !_DEFAULT_VALUES[styles[name]]
            )
                styleMap[name.underscore().dasherize()] = styles[name];
        }
    } else {
        const heightWidthMap = { height: true, width: true };
        // eslint-disable-next-line no-restricted-syntax
        for (const name in styles) {
            if (
                controlStyles[name] !== styles[name] &&
                (!stylePrefixesToInclude || stylePrefixesToInclude[name.substring(0, 4)]) &&
                styles[name].length > 0 &&
                !_DEFAULT_VALUES[styles[name]]
            ) {
                if (_DEFAULT_VALUES[styles[name]] && name in heightWidthMap && styles[name] === 'auto')
                    styleMap[dasherize(underscore(name))] =
                        tempElem instanceof HTMLElement && `${tempElem.offsetHeight}px`;
                else styleMap[dasherize(underscore(name))] = styles[name];
            }
        }
    }

    if (!tempIsExisting) parentElem.removeChild(tempElem);
    parentElem.removeChild(controlElem);
    return styleMap;
}

let _camelizedProperties = null; // Caching of camelized css properties
const _DEFAULT_VALUES = { medium: true, '0px': true, auto: true, none: true };
export const StyleGroups = {
    COLOR: { back: true, colo: true },
    DECORATION: { back: true, bord: true, colo: true, font: true, padd: true, text: true, outl: true },
    DIMENSIONS: { heig: true, widt: true, marg: true },
    POSITION: { disp: true, top: true, left: true, posi: true },
    LAYOUT: { heig: true, widt: true, disp: true, top: true, left: true, marg: true, posi: true },
    ANIMATION: { heig: true, widt: true, top: true, left: true, bott: true, righ: true, colo: true },
};

/**
 * This is a function for setting multiple styles quickly. It requires a simple JSON object of styles.
 * @param {ObjWithStyles} element - element to appl styles to.
 * @param {Object} styleMap - JSON of style name/value pairs to be applied to the element.
 * @param {boolean} [replace] - Default false. Whether to replace the current styles completely.
 * @returns {ObjWithStyles} current element
 */
export function setStyleUnsafe(element, styleMap, replace) {
    let cssText = '';
    // eslint-disable-next-line no-restricted-syntax
    for (const attributeName in styleMap) {
        cssText += `${attributeName}:${styleMap[attributeName]};`;
    }
    if (replace) {
        (element instanceof HTMLElement ? element.style : element).cssText = `;${cssText}`;
    } else {
        (element instanceof HTMLElement ? element.style : element).cssText += `;${cssText}`;
    }
    return element;
}

/**
 * @param {HTMLElement} element
 * @param {string} style
 */
function _getStyle(element, style) {
    style = style === 'float' ? 'cssFloat' : camelize(style);
    let value = element.style[style];
    if (!value || value === 'auto') {
        const css = document.defaultView.getComputedStyle(element, null);
        value = css ? css[style] : null;
    }
    if (style === 'opacity') return value ? parseFloat(value) : 1.0;
    return value === 'auto' ? null : value;
}

/**
 *
 * @param {HTMLElement} element
 * @param {*} [style]
 * @param {HTMLElement} [parentNode]
 * @param {boolean} [copy]
 */
export function getStyle(element, style, parentNode, copy) {
    if (element == null) return null;

    if (typeof style !== 'string') {
        // @ts-ignore
        copy = parentNode;
        parentNode = style;
        style = null;
    }

    let result;
    let oldParentNode;
    let oldNextSib;
    if (parentNode && element.parentNode !== parentNode) {
        oldParentNode = element.parentNode;
        oldNextSib = element.nextSibling;
        parentNode.appendChild(element);
    }
    let display = '';
    if (style !== 'display' && element.style.display === 'none') {
        ({ display } = element.style);
        element.style.display = 'block';
    }
    if (style) result = _getStyle(element, style);
    else {
        result = window.getComputedStyle(element, null);
        if (copy) result = clone(result);
    }
    if (display) element.style.display = display;
    if (oldParentNode) oldParentNode.insertBefore(element, oldNextSib);

    return result;
}
