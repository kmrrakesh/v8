/* global signalR */
// @ts-check
/**
 * Web Component helper that gives server side event support
 *
 * Usage:
 * import { serverEventsListener } from '../path/to/serverEventsListener.mixin.js';
 * class MyElement extends serverEventsListener(HTMLElement) {
 *
 *  serverEventReceived(topic, context, data) {
 *     // Do something with new data
 *  }
 *
 *  connectedCallback() {
 *     super.connectedCallback();
 *     this.listenFor('topicName', 'topicContext');
 *     this.listenFor('topicName');
 *  }
 * }
 *
 * @param {{ new (): HTMLElement; new (): HTMLElement; prototype: HTMLElement; }} baseElement
 */
export const serverEventsListener = baseElement =>
    class extends baseElement {
        /** @inheritdoc */
        constructor() {
            super();

            /** @type {Map<string,CoreServerEventTopic>} */
            this.activeTopics = new Map();

            /** @type {string} */
            this.lastTopicContext = null;

            this._onSeverEventReceived = this._onSeverEventReceived.bind(this);
        }

        /**
         * Part of the API - used by Web Component to change the context of the topic
         * @param {string} topicName - the name of the topic to listen too
         * @param {string} [topicContext] - The context of the topic to listen to. examples might be a meeting ID of a chat group you want ot join. If not supplied all data will be listened for without any context filtering.
         * @returns {Promise} resolves once connection and topic/context registration is complete.
         */
        async listenFor(topicName, topicContext) {
            if (this.activeTopics.has(topicName) === false) {
                addTopic(topicName);
            }

            this._listenFor(topicName, topicContext);
        }

        /**
         * @private
         * @param {string} topicName to listen to
         * @param {string} [topicContext] optional context to filter results by. If not supplied all messages in the topic are relayed.
         */
        _listenFor(topicName, topicContext) {
            const topicContextStr = (topicContext && topicContext.toLowerCase()) || null;
            const topic = getTopic(topicName);

            this.activeTopics.set(topicName, topic);

            this._resetEventListeners(topicName, topicContextStr);

            // If the topic context is already registered, we might already have the data. We just need to refire it.
            if (topic.lastUpdateAllEvent !== null && topic.lastUpdateAllEvent.detail.context === topicContext) {
                this._onSeverEventReceived(topic.lastUpdateAllEvent);
                this.lastTopicContext = topic.lastUpdateAllEvent.detail.context;
            } else if (topic.lastUpdateEvent !== null && topic.lastUpdateEvent.detail.context === topicContext) {
                this._onSeverEventReceived(topic.lastUpdateEvent);
                this.lastTopicContext = topic.lastUpdateEvent.detail.context;
            } else {
                changeContext(topicName, topicContextStr);
                this.lastTopicContext = topic.context;
            }
        }

        /**
         * @private
         * @param {string} topicName to listen to
         * @param {string} [topicContextStr] optional context to filter results by. If not supplied all messages in the topic are relayed.
         */
        _resetEventListeners(topicName, topicContextStr) {
            if (this.lastTopicContext !== null && this.lastTopicContext !== undefined) {
                // Remove event listener for previous context.
                const eventName = generateDomEventName(topicName, this.lastTopicContext);
                window.removeEventListener(eventName, this._onSeverEventReceived);
            }

            // Add event listener for data updates for the new context.
            const eventName = generateDomEventName(topicName, topicContextStr);
            window.removeEventListener(eventName, this._onSeverEventReceived);
            window.addEventListener(eventName, this._onSeverEventReceived);
        }

        /**
         * Makes a request for the current data available for the topic specified. Useful to call at the start for current topic state.
         * @param {string} topicName to listen to
         * @param {string} [topicContext] optional context to filter results by. If not supplied all messages in the topic are relayed.
         */
        async request(topicName, topicContext) {
            this._request(topicName, topicContext || '');
        }

        /**
         * @private
         * @param {string} topicName to listen to
         * @param {string} [topicContext] optional context to filter results by. If not supplied all messages in the topic are relayed.
         */
        _request(topicName, topicContext) {
            const topicContextStr = (topicContext && topicContext.toLowerCase()) || null;
            return request(topicName, topicContextStr);
        }

        /**
         * @private
         * @param {CustomEvent} event Internal DOM event used to listen to data pushed from server
         */
        _onSeverEventReceived(event) {
            if (event.detail.topic) {
                const topic = getTopic(event.detail.topic);
                if (topic && topic.connection && this.isConnected) {
                    this.serverEventReceived(event.detail.topic, event.detail.context, event.detail.data);
                }
            }
        }

        /**
         * This is called when data is received from the server.
         * Needs to be mplemented by sub-class.
         * @param {string} topic current topic name
         * @param {string} context current topic filter used to generate this data result
         * @param {any} data data result pushed and received
         */
        serverEventReceived(topic, context, data) {
            throw Error('Must implement serverEventReceived(context, data)');
        }

        /** Hook into disconnect life cycle event to tidy up hubs */
        disconnectedCallback() {
            // eslint-disable-next-line
            const topicsToRemove = new Map;
            this.activeTopics.forEach((topic, topicName) => {
                if (topic.count === 1) {
                    topicsToRemove.set(topicName, topic);

                    if (topic.updateActive && topic.context) {
                        const eventName = generateDomEventName(topicName, topic.context);
                        window.removeEventListener(eventName, this._onSeverEventReceived);
                    }

                    if (topic.updateAllActive) {
                        const eventName = generateDomEventName(topicName);
                        window.removeEventListener(eventName, this._onSeverEventReceived);
                    }
                } else {
                    topic.count -= 1;
                }
            });

            removeTopics(topicsToRemove);

            // @ts-ignore
            if (super.disconnectedCallback) {
                // @ts-ignore
                super.disconnectedCallback();
            }
        }
    };

/**
 * @typedef {Object} CoreServerEventTopic
 * @property {number} count - Number of listeners for this topic.
 * When 0 the connection will be closed and tidied.
 * New Web Components are connected before the old are disconnected
 * so the count is used to make sure we don't close a connection during the diconnectCallback if it's still in use
 * @property {string} [context] - The context for this topic. Null means listen for all.
 * @property {any} connection - The current SignalR connection being used for this topic/hub
 * @property {Array<{handler: function():Promise; success: function; fail: function; retry: boolean}>} asyncCommandQueue - List of callbacks that need to be executed in order.
 * @property {boolean} asyncCommandQueueRunning - List of callbacks that need to be executed in order.
 * @property {Promise} connectionPromise - The Promise that is resolved when the connection is started.
 * @property {function} connectionPromiseReject - The Promise reject handler.
 * @property {function} connectionPromiseResolve - The Promise resolve handler.
 * @property {function} handleUpdate - The function that SignalrR will call with updates
 * @property {function} handleUpdateAll - The function that SignalrR will call with updates for no context
 * @property {CustomEvent} lastUpdateEvent - Stores the last update event so that it can be refired for late subscribers
 * @property {CustomEvent} lastUpdateAllEvent - Stores the last update event so that it can be refired for late subscribers
 * @property {string} name - The topic name
 * @property {boolean} updateActive - Whether this topic is currently listening for update
 * @property {boolean} updateAllActive - Whether this topic is currently listening for updateAll
 */
/** @type {Map<string, CoreServerEventTopic>} */
const topics = new Map();

// Current use case is when server is not available
const connectionReconnectInterval = 5000;

/**
 *
 * @param {string} topicName - The name of the topic to get. It will be generated if it oes not exist.
 * @returns {CoreServerEventTopic}
 */
function getTopic(topicName) {
    if (topics.has(topicName) === false) {
        topics.set(topicName, {
            asyncCommandQueue: [],
            asyncCommandQueueRunning: false,
            count: 0,
            context: undefined,
            connection: null,
            connectionPromise: null,
            connectionPromiseReject: null,
            connectionPromiseResolve: null,
            handleUpdate: null,
            handleUpdateAll: null,
            lastUpdateAllEvent: null,
            lastUpdateEvent: null,
            name: topicName,
            updateActive: false,
            updateAllActive: false,
        });
    }

    return topics.get(topicName);
}

/**
 * If this is the first topic then the connection is started and initialized.
 * @param {string} topicName - name of the topic to subscribe/listen to.
 */
function addTopic(topicName) {
    const topic = getTopic(topicName);

    if (!topic.connection) {
        topic.connection = buildConnection(topicName);
    }

    if (topic.count === 0) {
        startTopic(topicName);
    }

    topic.count += 1;
}

/**
 * @param {Map<string, CoreServerEventTopic>} topicsToRemove - topics to unregister if empty
 */
function removeTopics(topicsToRemove) {
    topicsToRemove.forEach((topic, topicName) => {
        removeTopic(topicName);
    });
}

/**
 * If this is the last instance of this topic to be removed then connection will be tidied up.
 * @param {string} topicName - name of the topic to unsubscribe/stop listening to.
 */
function removeTopic(topicName) {
    const topic = getTopic(topicName);
    if (topic) {
        if (topic.connection) {
            const connected = topic.connection.connection.connectionState === 1;
            if (topic.updateActive) {
                if (connected) {
                    queueAsync(topic, () => topic.connection.invoke('StopListeningFor', topic.context));
                }

                stopUpdate(topicName);
            }

            if (topic.updateAllActive) {
                stopUpdateAll(topicName);
            }

            // make sure the topics don't get restarted as we close them
            // topic.connection.onclose = () => {};
            // Currently the only way to remove a callback is to manually remove it from this array.
            topic.connection.closedCallbacks = [];

            queueAsync(topic, () => topic.connection.stop());
        }
        topics.delete(topicName);
    }
}

/**
 * Handles responses from SignalR and fires DOM events with received data.
 * @param {string} topicName
 * @param {CoreServerEventTopic} topicRef
 * @param {string} context
 * @param {*} data
 */
function handleUpdateHandler(topicName, topicRef, context, data) {
    const topic = getTopic(topicName);
    const eventName = generateDomEventName(topicName, context);
    topic.lastUpdateEvent = new CustomEvent(eventName, {
        detail: {
            topic: topicName,
            context,
            data,
        },
    });
    window.dispatchEvent(topic.lastUpdateEvent);
}

/**
 * Handles responses from SignalR and fires DOM events with received data.
 * @param {string} topicName
 * @param {CoreServerEventTopic} topicRef
 * @param {*} data
 */
function handleUpdateAllHandler(topicName, topicRef, data) {
    const topic = getTopic(topicName);
    const eventName = generateDomEventName(topicName);
    topic.lastUpdateAllEvent = new CustomEvent(eventName, {
        detail: {
            topic: topicName,
            context: null,
            data,
        },
    });
    window.dispatchEvent(topic.lastUpdateAllEvent);
}

/**
 * Changes the context of the current topic.
 * Does nothing if the topic is already connected and the topic context has not changed
 * @param {string} topicName - the current topic. must be connected already.
 * @param {string} context - the current context we are connected to the topic with.
 */
function changeContext(topicName, context) {
    // TODO support different context for multiple listeners on the same topic
    const topic = getTopic(topicName);
    if (topic.connection) {
        if (context !== topic.context) {
            if (context) {
                queueAsync(topic, () => {
                    if (topic.context && topic.connection.connection.connectionState < 2) {
                        return topic.connection.invoke('StopListeningFor', topic.context);
                    }
                    return Promise.resolve();
                });
                topic.context = context;
                startUpdate(topicName);
                queueAsync(topic, () => topic.connection.invoke('ListenFor', context));
            }
            startUpdateAll(topicName);
        }
    }
}

/**
 * Makes a request for the current available data state
 * @param {string} topicName topic to request
 * @param {string} [context] topic context to filter by
 */
function request(topicName, context) {
    // TODO support different context for multiple listeners on the same topic
    const topic = getTopic(topicName);
    return new Promise((resolve, reject) => {
        if (topic.connection) {
            queueAsync(topic, () => topic.connection.invoke('Request', context || ''), resolve, reject);
        } else {
            reject(new Error('You must connect the SignalR hub first'));
        }
    });
}

/**
 * @param {string} topicName
 * @param {string} [context]
 */
function generateDomEventName(topicName, context) {
    return context ? `serverproxy-${topicName}-${context}`.toLowerCase() : `serverproxy-${topicName}`.toLowerCase();
}

/**
 * @param {string} topicName Topic name to build the connection for
 */
function buildConnection(topicName) {
    // @ts-ignore
    return new signalR.HubConnectionBuilder().withUrl(`/signalr/${topicName}`).build();
}

/**
 * Starts the connection for the given topic some connection and network resilience.
 * @param {string} topicName Topic name to start a connection for
 */
function startTopic(topicName) {
    const topic = getTopic(topicName);

    queueAsync(topic, () => topic.connection.start(), null, null, true);
    if (topic.connection.closedCallbacks.length === 0) {
        topic.connection.onclose(() => reconnect(topicName));
    }
}

/**
 * Starts the update connection for a topics conection
 * @param {string} topicName
 */
function startUpdate(topicName) {
    const topic = getTopic(topicName);
    if (topic.updateActive === false) {
        topic.handleUpdate = handleUpdateHandler.bind(this, topicName, topic);
        topic.connection.off('Update', topic.handleUpdate);
        topic.connection.on('Update', topic.handleUpdate);
        topic.updateActive = true;
    }
}

/**
 * Stops the update connection fora topics connection
 * @param {string} topicName
 */
function stopUpdate(topicName) {
    const topic = getTopic(topicName);
    if (topic.updateActive) {
        topic.connection.off('Update', topic.handleUpdate);
        topic.updateActive = false;
    }
}

/**
 * Starts the updateAll connection for a topics conection
 * @param {string} topicName
 */
function startUpdateAll(topicName) {
    const topic = getTopic(topicName);
    if (topic.updateAllActive === false) {
        topic.handleUpdateAll = handleUpdateAllHandler.bind(this, topicName, topic);
        topic.connection.off('UpdateAll', topic.handleUpdateAll);
        topic.connection.on('UpdateAll', topic.handleUpdateAll);
        topic.updateAllActive = true;
    }
}

/**
 * Stops the updateAll connection fora topics connection
 * @param {string} topicName
 */
function stopUpdateAll(topicName) {
    const topic = getTopic(topicName);
    if (topic.updateAllActive) {
        topic.connection.off('UpdateAll', topic.handleUpdateAll);
        topic.updateAllActive = false;
    }
}

/**
 * Checks for disconnected connections and attempts to reconnect them.
 * @param {string} topicName
 * @param {string} [topicContext]
 */
async function reconnect(topicName, topicContext) {
    const topic = getTopic(topicName);
    if (topic) {
        removeTopic(topicName);
        addTopic(topicName);
        changeContext(topicName, topicContext || topic.context);
    }
}

/**
 * Runs a sequence of asyncronous functions in series. The first task continues to completion before the next begins.
 * @param {CoreServerEventTopic} topic
 * @param {function():Promise} callback invoke method to call. Must return a Promise
 * @param {(value?: function) => void} [success]
 * @param {(reason?: function) => void} [fail]
 * @param {boolean} [retryOnFail]
 */
function queueAsync(topic, callback, success, fail, retryOnFail) {
    topic.asyncCommandQueue.push({ handler: callback, success, fail, retry: retryOnFail });
    if (topic.asyncCommandQueue.length > 0 && topic.asyncCommandQueueRunning === false) {
        releaseQueue(topic);
    }
}

/**
 * @param {CoreServerEventTopic} topic
 */
function releaseQueue(topic) {
    topic.asyncCommandQueueRunning = true;
    const next = topic.asyncCommandQueue[0];
    if (next) {
        next
            .handler()
            .then(() => {
                if (next.success) {
                    next.success();
                }
                topic.asyncCommandQueue.shift();
                releaseQueue(topic);
            })
            .catch(error => {
                if (next.fail) {
                    next.fail();
                }

                if (next.retry) {
                    setTimeout(releaseQueue.bind(this, topic), connectionReconnectInterval);
                }
            });
    } else {
        topic.asyncCommandQueueRunning = false;
    }
}

// For debugging
// window['topics'] = topics;
