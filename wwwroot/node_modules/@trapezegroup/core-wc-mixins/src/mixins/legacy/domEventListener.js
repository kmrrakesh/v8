// @ts-check
/**
 * @param {string} eventName
 * @returns {string}
 */
function nativeEvent(eventName) {
    let nativeEventName = eventName;
    if ('MouseScrollEvent' in window && eventName === 'mousewheel') {
        nativeEventName = 'DOMMouseScroll';
    }
    return nativeEventName;
}

/**
 * @param {{ new (): HTMLElement; new (): HTMLElement; prototype: HTMLElement; }} baseClass
 */
export const domEventListener = baseClass =>
    class extends baseClass {
        /** @inheritdoc */
        constructor() {
            super();

            this._observers = [];
        }

        /** @inheritdoc */
        disconnectedCallback() {
            this.dispose();

            // @ts-ignore
            super.disconnectedCallback && super.disconnectedCallback();
        }

        /** Tidy up for garbage collection */
        dispose() {
            if (this._observers) {
                while (this._observers[0]) {
                    this.stopObserving(this._observers[0].elem);
                }
                this._observers = null;
            }

            // @ts-ignore
            super.dispose && super.dispose();
        }

        /**
         * Adds a client-side event listener to an element.
         * Alternate signatures are available below where omitted parameters will use their default values.
         * @param {String} eventName - Event type to listen for. (ie. "mousedown")
         * @param {Element} [element] - Defaults to this. Element to add the event listener to.
         * @param {String} [method] - Defaults to on_&lt;eventName&gt; where the handler must exist. The name of the method on the class that will handle the event.
         * @param {Boolean} [capture] - Specify whether to add the event to the capture phase or not
         * @also
         * @param {String} eventName - Event type to listen for. (ie. "mousedown")
         * @param {Element} element - Element to add the event listener to.
         * @param {Boolean} capture - Specify whether to add the event to the capture phase or not
         * @also
         * @param {String} eventName - Event type to listen for. (ie. "mousedown")
         * @param {String} method - The name of the method on the class that will handle the event.
         * @param {Boolean} capture - Specify whether to add the event to the capture phase or not
         * @also
         * @param {String} eventName - Event type to listen for. (ie. "mousedown")
         * @param {Boolean} capture - Specify whether to add the event to the capture phase or not
         */
        observe(eventName, element, method, capture) {
            let targetElement = element;
            let methodName = method;
            let useCapture = capture;
            if (typeof targetElement === 'string') {
                // @ts-ignore
                useCapture = methodName;
                methodName = targetElement;
                targetElement = this;
            } else if (typeof methodName === 'boolean') {
                useCapture = methodName;
                methodName = `on_${eventName}`;
            } else if (typeof targetElement === 'boolean') {
                useCapture = targetElement;
                targetElement = this;
            } else targetElement = targetElement || this;
            const observer = this._getObserver(targetElement);
            const key = `${eventName}__${method || `on_${eventName}`}`;
            if (!observer.handlers[key]) {
                observer.handlers[key] = this.bindScope(methodName || `on_${eventName}`);
                targetElement.addEventListener(nativeEvent(eventName), observer.handlers[key], useCapture);
            }
        }

        /**
         * Removes a client-side event listener from an element.
         * @param {String} eventName - Event type to remove. If not specified and element is specified, then all events is removed from element.
         * @param {Element} [element] - Defaults to this. Element to remove the event listener from.
         * @param {string} [method] -
         * @also Removes all events from an element
         * @param {Element} element - Element to remove the event listener from. All listeners attached to the element will be removed.
         */
        stopObserving(eventName, element, method) {
            let eventNameDefault = eventName;
            let targetElement = element;
            if (typeof eventNameDefault !== 'string') {
                targetElement = eventNameDefault;
                eventNameDefault = null;
            }
            if (
                !targetElement ||
                (!(targetElement instanceof Element) && targetElement !== document && targetElement !== window)
            ) {
                targetElement = this;
            }

            const keyToRemove = `${eventName}__${method || ''}`;
            const observer = this._getObserver(targetElement);
            if (observer) {
                if (!eventNameDefault) {
                    const { handlers } = observer;
                    // eslint-disable-next-line no-restricted-syntax
                    for (const name in handlers) {
                        if (Object.prototype.hasOwnProperty.call(handlers, name)) {
                            targetElement.removeEventListener(nativeEvent(name), observer.handlers[name]);
                            delete observer.handlers[name];
                        }
                    }
                    this._tidyObserver(observer);
                } else if (observer.handlers[keyToRemove]) {
                    targetElement.removeEventListener(nativeEvent(eventNameDefault), observer.handlers[keyToRemove]);
                    delete observer.handlers[keyToRemove];
                    this._tidyObserver(observer);
                }
            }
        }

        /**
         *
         * @param {string} dragMethodName
         * @param {string} dropMethodName
         * @param {HTMLElement} [element]
         */
        observeDragAndDrop(dragMethodName, dropMethodName, element) {
            this.observe('mousemove', element, dragMethodName, true);
            this.observe('mouseup', element, dropMethodName, true);
        }

        /**
         *
         * @param {string} dragMethodName
         * @param {string} dropMethodName
         * @param {HTMLElement} [element]
         */
        stopObservingDragAndDrop(dragMethodName, dropMethodName, element) {
            this.stopObserving('mousemove', element, dragMethodName);
            this.stopObserving('mouseup', element, dropMethodName);
        }

        /** @private */
        _getObserver(element) {
            const len = this._observers.length;
            for (let i = 0; i < len; i++) {
                if (this._observers[i].elem === element) return this._observers[i];
            }
            const ctx = { elem: element, handlers: {} };
            this._observers[len] = ctx;
            return ctx;
        }

        /** @private Removes empty observers from the this._observers collection */
        _tidyObserver(observer) {
            if (!observer) {
                for (let i = 0, len = this._observers.length; i < len; i++) this._tidyObserver(this._observers[i]);
                return;
            }

            // eslint-disable-next-line no-restricted-syntax
            for (const name in observer.handlers) {
                if (Object.prototype.hasOwnProperty.call(observer.handlers, name)) {
                    return;
                }
            }
            this._observers.splice(this._observers.indexOf(observer), 1);
        }

        /**
         * Binds a function putting the obj as the closure not the method reference. This allows the method to be altered after the bind has taken place (by AOP for example).
         * @param {String} method - Name of the method to bind to the instance.
         */
        bindScope(method) {
            const obj = this;
            return function bindScope(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
                return obj[method](arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
            };
        }

        /**
         * Helper to create and dispatch a custom event.
         * @param {string} name - Custom event name
         * @param {*} eventContext - Custom Event Context
         * @returns {CustomEvent}
         */
        dispatchCustomEvent(name, eventContext) {
            const event = new CustomEvent(name, {
                bubbles: true,
                composed: true,
                detail: eventContext,
            });
            this.dispatchEvent(event);
            return event;
        }
    };
