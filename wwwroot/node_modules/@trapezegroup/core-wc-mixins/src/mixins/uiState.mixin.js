/**
 * Web Component class mixin that provides persistence for UI state. It's designed to persist UI based values like selection.
 * State is currently stored in local storage.
 * @example
 * import { uiState } from '../path/to/core-ui-state-mixin.js'
 *
 * class MyElement extends uiState(HTMLElement, 'MyElement') {
 *      connectedCallback() {
 *          // This mixin uses the connectedCallback to initialize the UI state.
 *          // Be sure to call super.connectedCallback or it wont work.
 *          super.connectedCallback();
 *
 *          // If you wish to access the state here, you best use the uiStateWhenReady Promise as the state may not be ready.
 *          this.uiStateWhenReady.then((uiState) => {
 *              // uiState is now ready and it is now safe to do something with the uiState
 *              ....
 *          });
 *      }
 *
 *      disconnectedCallback() {
 *          // This mixin uses the disconnectedCallback to store the UI state.
 *          // Be sure to call super.disconnectedCallback or it wont work.
 *          super.disconnectedCallback();
 *      }
 *
 *      getUiState() {
 *          // Called when it is time to put the current ui state into storage. This method should return a snapshot of the current UI state you which to persist.
 *          return {
 *              myProperty: 'somePropertyValue'
 *          };
 *      }
 *
 *      setUiState(uiState) {
 *          // The state has been initialized. This is the earliest point that it is available.
 *          // Here you can perform some initialization based on the ui state.
 *          this.myProp = uiState.myProperty;
 *      }
 *
 *      getStatekey() { return 'MyElement';} // This is require if a key was not passed to the mixin.
 *
 *      someMethod() {
 *          let myProp = this.uiState.myProperty;
 *          ...
 *      }
 * }
 *
 * @param {{ new (): HTMLElement; new (): HTMLElement; prototype: HTMLElement; }} baseClass
 * @param {string|function} [stateKey] - A unique key to use to store the value in. Can be a  Could use the web component class neame if it is unique enough. If not supplied then you must override getStateKey.
 */
export const uiState = (baseClass, stateKey) =>
    class extends baseClass {
        /** This mixin uses the connectedCallback to initialize the UI state.
         *  Be sure to call super.connectedCallback or it wont work.
         */
        constructor() {
            super();

            this.syncUiState = this.syncUiState.bind(this);

            // The connectedCallback is called before a previous element we are replacing has had it's disconnectedCallback. We need to try to run this afterwards.
            this.uiStateWhenReady = new Promise(resolves => {
                setTimeout(() => {
                    this.setUiState(this.uiState || {});
                    resolves(this.uiState);
                }, 0);
            });

            window.addEventListener('uiStateCommit', this.syncUiState);
        }

        /** This mixin uses the disconnectedCallback to store the UI state.
         *  Be sure to call super.disconnectedCallback or it wont work.
         */
        disconnectedCallback() {
            this.syncUiState();
            window.removeEventListener('uiStateCommit', this.syncUiState);

            // @ts-ignore
            super.disconnectedCallback && super.disconnectedCallback();
        }

        /**
         * Gets the current generated state
         * @returns {any} The state to store
         */
        getUiState() {
            return {};
        }

        /**
         * @param {any} state
         */
        setUiState(state) {
            return {};
        }

        /** Gets the current  */
        syncUiState() {
            this.uiState = this.getUiState();
        }

        /** @returns {Promise<any>} a promise that resolves once the UI State has been initialized. */
        get uiStateWhenReady() {
            return this._uiStateWhenReady;
        }

        /** @param {Promise<any>} promiseOfSettingState a promise that resolves once the UI State has been initialized. */
        set uiStateWhenReady(promiseOfSettingState) {
            if (this._uiStateWhenReady === undefined) {
                this._uiStateWhenReady = promiseOfSettingState;
            }
        }

        /** @returns {string} */
        getStatekey() {
            const key = typeof stateKey === 'string' ? stateKey : stateKey();
            return key;
        }

        /** @returns {any} Gets the currently stored ui state  */
        get uiState() {
            const currentStateKey = this.getStatekey();
            if (currentStateKey) {
                return getGlobalState()[currentStateKey];
            }
            return undefined;
        }

        /** @param {any} value Sets the curently stored ui state */
        set uiState(value) {
            const currentStateKey = this.getStatekey();
            if (currentStateKey) {
                getGlobalState()[currentStateKey] = value;
            }
        }
    };

let globalState = null;

/** Gets the singlton uiState object containing all uiState across components */
function getGlobalState() {
    if (!globalState) {
        globalState = JSON.parse(localStorage.uiState || '{}');
        window.addEventListener('unload', setGlobalState);
    }

    return globalState;
}

/** Sets the singlton uiState object containing all uiState across components */
function setGlobalState() {
    window.dispatchEvent(new CustomEvent('uiStateCommit'));
    localStorage.uiState = JSON.stringify(globalState);
}
