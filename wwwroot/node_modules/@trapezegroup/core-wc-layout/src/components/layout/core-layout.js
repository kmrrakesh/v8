/**  import litElement base class and html helper function */
import { LitElement, html, css } from 'lit-element';
import './core-header-layout.js';
import '../tabs/core-tab-content.js';

/**
 * Component for creating the layout for the screens
 * @example
 * import '@trapezegroup/core-wc-layout/src/components/layout/core-layout.js';
 * ...
 * <core-layout>
 *   <div slot="menu">Menu</div>
 *   <div slot="title">Core Layout</div>
 *   <div slot="filter">Filters</div>
 *   <div slot="content">Content Here</div>
 * </core-layout>
 *
 * @example
 * import '@trapezegroup/core-wc-layout/src/components/layout/core-layout.js';
 * ...
 * <core-layout>
 *   <div slot="menu">Menu</div>
 *   <div slot="filter">Filters</div>
 *   <core-tab-title>Tab 1</core-tab-title>
 *   <core-tab-content>Tab Pane 1</core-tab-content>
 *   <core-tab-title>Tab 2</core-tab-title>
 *   <core-tab-content>Tab Pane 2</core-tab-content>
 * </core-layout>
 * 
 * @example
 * import '@trapezegroup/core-wc-layout/src/components/layout/core-layout.js';
 * ...
 * <core-layout>
 *   <core-tab-title content-element="test-one">Web Component test-one</core-tab-title>
 *   <core-tab-title content-element="test-two">Web Component test-two</core-tab-title>
 * </core-layout>
 */
export class CoreLayout extends LitElement {
    /** @inheritdoc */
    static get styles() {
        return [
            css`
                :host {
                    display: grid;
                    height: 100%;
                    --layout-header-height: 5rem;
                    grid-template-rows: var(--layout-header-height) auto;
                }
            `,
        ];
    }

    /** We can initialize the properties here in the constructor */
    constructor() {
        // Must call superconstructor first.
        super();
    }

    /** @inheritdoc */
    render() {
        return html`
            ${this.headerTemplate}
            ${this.contentTemplate}
        `;
    }

    /**
     * @returns {import('lit-element').TemplateResult} the header template for the core layout
     */
    get headerTemplate() {
        return html`
        <core-header-layout>
            <slot name="menu" slot="menu"></slot>
            <slot name="title" slot="title" @click=${this._selectTab}></slot>
            <slot name="filter" slot="filter"></slot>
        </core-header-layout>
        `;
    }

    /**
     * @returns {import('lit-element').TemplateResult} the content template for the core layout
     */
    get contentTemplate() {
        return html`
        <slot name="content" slot="content"></slot>
        `;
    }

    /* ----- Start of tab support ----- */

    /** @inheritdoc initialize tabs */
    connectedCallback() {
        super.connectedCallback();

        if (this.isConnected) {
            const { selectedTabIndex } = this;
            this._showTabContent(selectedTabIndex > -1 ? selectedTabIndex : 0);
        }
    }

    /** @returns {Array<Element>} core-tab-title elements in this layout */
    get _tabTitles() {
        return Array.from(this.querySelectorAll('core-tab-title'));
    }

    /** @returns {Array<Element>} core-tab-content elements in this layout */
    get _tabContents() {
        return Array.from(this.querySelectorAll('core-tab-content'));
    }

    /** @returns {number} of the currently selected tab index */
    get selectedTabIndex() {
        return this._tabTitles.findIndex(t => t.hasAttribute('active'));
    }

    /** @param {Event} event click */
    _selectTab(event) {
        const { target } = event;
        if (target instanceof HTMLElement) {
            const tabTitle = target.closest('core-tab-title');
            if (tabTitle) {
                const tabTitles = this._tabTitles;
                if (tabTitles.length) {
                    const tabIndex = tabTitles.indexOf(tabTitle);
                    this._showTabContent(tabIndex);
                    // Don't want parent tabs layouts to also respond to this (in the case that this is a nested tab)
                    event.stopPropagation();
                }
            }
        }
    }

    /** @param {number} tabIndex to show */
    _showTabContent(tabIndex) {
        const tabTitles = this._tabTitles;
        if (tabTitles.length === 0) {
            return;
        }

        const tabTitle = tabTitles[tabIndex];
        const tabContents = this._tabContents;
        // add any missing core-tab-content elements
        for (let i = tabContents.length; i <= tabIndex; i++) {
            tabContents.push(this.appendChild(document.createElement('core-tab-content')));
        }
        const tabContent = tabContents[tabIndex];
        // If core-tab-content is empty, see if we can populate it with a web component
        // This is useful for lazy loading tab content
        if (tabContent.childNodes.length === 0) {
            const contentTagName = tabTitle.getAttribute('content-element');
            if (contentTagName) {
                tabContent.appendChild(document.createElement(contentTagName));
            }
        }
        // Activate tab and content
        if (tabTitle && tabContent) {
            tabTitles.forEach(tc => tc.removeAttribute('active'));
            tabTitle.setAttribute('active', 'active');
            tabContents.forEach(tc => tc.removeAttribute('active'));
            tabContent.setAttribute('active', 'active');
        }
    }

    /* ----- End of tab support ----- */
}
customElements.define('core-layout', CoreLayout);
