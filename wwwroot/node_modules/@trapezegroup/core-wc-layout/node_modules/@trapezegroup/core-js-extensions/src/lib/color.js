/* Bitwise is used in this file in Color algorithms */
/* eslint-disable no-bitwise */
// @ts-check
import { colorFromString, colorFromInt, colorFromArray, mod } from './methods.js';

/**
 * Basic Color functionality
 */
export class Color {
    /**
     * A class that handles color conversions.
     * @param {Array|Object|String} [color] -
     */
    constructor(color) {
        this.r = 255;
        this.g = 255;
        this.b = 255;
        this.a = 1;
        // summary:
        //	 	Takes a named string, hex string, array of rgb or rgba values,
        //	 	an object with r, g, b, and a properties, or another `Color` object
        //	 	and creates a new Color instance to work from.
        // example:
        //		Work with a Color instance:
        //	 | var c = new Color();
        //	 | c.setColor([0,0,0]); // black
        //	 | var hex = c.toHex(); // #000000
        // example:
        //		Work with a node's color:
        //	 | var color = someNode.style["backgroundColor"];
        //	 | var n = new Color(color);
        //	 | // adjust the color some
        //	 | n.r *= .5;
        //	 | console.log(n.toString()); // rgb(128, 255, 255);
        if (color) this.setColor(color);
    }

    /**
     *
     * @param {*} r
     * @param {*} g
     * @param {*} b
     * @param {*} a
     */
    _set(r, g, b, a) {
        const t = this;
        t.r = r;
        t.g = g;
        t.b = b;
        t.a = a;
    }

    /** Set the color value.
     * @param {Array|Object|String} color -
     */
    setColor(color) {
        // summary:
        //		Takes a named string, hex string, array of rgb or rgba values,
        //		an object with r, g, b, and a properties, or another `Color` object
        //		and sets this color instance to that value.
        // example:
        //	|	var c = new Color(); // no color
        //	|	c.setColor("#ededed"); // greyish
        if (typeof color === 'string') {
            colorFromString(color, this);
        } else if (typeof color === 'number') {
            colorFromInt(color, this);
        } else if (Array.isArray(color)) {
            colorFromArray(color, this);
        } else {
            this._set(color.r, color.g, color.b, color.a);
        }

        return this; // Color
    }

    // Returns a value between 0 and 255. The difference between contrast and the lightness in hsl is that
    // contrast is that it weights each colour component based on YIQ http://en.wikipedia.org/wiki/YIQ
    /** Returns the black and white contrast level of the colour. This is based on the YIQ spec for RGBY colours where Y is the gray scale used by old black and white televisions. More info on {@link http://en.wikipedia.org/wiki/YIQ YIQ} spec. */
    getContrast() {
        const t = this;
        return (t.r * 299 + t.g * 587 + t.b * 114) / 1000;
    }

    /**
     * Returns the perceived brightness of a color for RGB color spaces that use the ITU-R BT.709 primaries
     * http://en.wikipedia.org/wiki/Luminance_(relative)
     * @returns {number}
     */
    getLuminosity() {
        const t = this;

        const rRatio = t.r / 255;
        const gRatio = t.g / 255;
        const bRatio = t.b / 255;

        const r = rRatio <= 0.03928 ? rRatio / 12.92 : ((rRatio + 0.055) / 1.055) ** 2.4;
        const g = rRatio <= 0.03928 ? gRatio / 12.92 : ((gRatio + 0.055) / 1.055) ** 2.4;
        const b = rRatio <= 0.03928 ? bRatio / 12.92 : ((bRatio + 0.055) / 1.055) ** 2.4;

        return r * 0.2126 + g * 0.7152 + b * 0.0722;
    }

    /** Returns 3 element array of rgb values. */
    toRgb() {
        // summary:
        //		Returns a 4 component array of rgba values from the color
        //		represented by this object.
        const t = this;
        return [t.r, t.g, t.b, t.a.toPrecision(Color.ALPHA_PRECISION)]; // Array
    }

    /**
     * @param {boolean} includeAlpha whether to return rgb or rgba
     * @returns {string} CSS RGB string
     */
    toRgbStr(includeAlpha) {
        return includeAlpha
            ? `rgba(${this.r},${this.g},${this.b},${this.a.toPrecision(Color.ALPHA_PRECISION)})`
            : `rgb(${this.r},${this.g},${this.b})`;
    }

    /** Returns a CSS color string in hexadecimal representation. */
    toHex(includeAlpha) {
        // summary:
        //		Returns a CSS color string in hexadecimal representation
        // example:
        //	| 	console.log(new Color([0,0,0]).toHex()); // #000000
        const arr = [];
        for (let c = ['r', 'g', 'b'], i = 0; i < 3; i++) {
            const s = this[c[i]].toString(16);
            arr[i] = s.length < 2 ? `0${s}` : s;
        }
        if (includeAlpha) {
            const alpha = Math.round(this.a * 255);
            arr.unshift((alpha < 15 ? '0' : '') + alpha.toString(16));
        }
        return `#${arr.join('')}`; // String
    }

    /** Returns the current colour in the hsl (hue, saturation, lightness) spec. */
    toHsl() {
        // summary:
        //		Returns 3 component array of hsl values
        // example:
        //	|	var c = new Color("#000000");
        //	| 	console.log(c.toHsl()); // [0,0,0]
        const r = this.r / 255;
        const g = this.g / 255;
        const b = this.b / 255;
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        const c = max - min;
        let h;
        let s;
        const l = (max + min) / 2;

        if (c === 0) {
            h = 0;
            s = 0;
        } else {
            switch (max) {
                case r:
                    h = mod((g - b) / c, 6);
                    break;
                case g:
                    h = (b - r) / c + 2;
                    break;
                case b:
                    h = (r - g) / c + 4;
                    break;
                default:
            }
            h /= 6;
            s = c / (1 - Math.abs(2 * l - 1));
        }

        return [h, s, l, this.a];
    }

    /**
     *
     * @param {boolean} includeAlpha
     */
    toHslStr(includeAlpha) {
        const hsl = this.toHsl().map((value, i) => (i ? `${value * 100}%` : value * 360));
        return includeAlpha
            ? `hsla(${hsl[0]},${hsl[1]},${hsl[2]},${this.a.toPrecision(Color.ALPHA_PRECISION)})`
            : `hsl(${hsl[0]},${hsl[1]},${hsl[2]})`;
    }

    // TODO move format param to toString instead?
    /**
     * Returns a css color string in rgb(a) representation.
     * @param {boolean} [includeAlpha] - When set to TRUE, the alpha value is included with the result, otherwise the alpha value is not included.
     * @param {number} [format] - Color.FORMAT_HEX or Color.FORMAT_HEDEC or Color.FORMAT_CSS_HEX or Color.FORMAT_CSS_RGB or Color.FORMAT_CSS_HSL
     * @returns {string}
     */
    toCss(includeAlpha, format) {
        // summary:
        //		Returns a css color string in rgb(a) representation
        // example:
        //	|	var c = new Color("#FFF").toCss();
        //	|	console.log(c); // rgb('255','255','255')
        if (format === undefined) {
            const t = this;
            const rgb = `${t.r}, ${t.g}, ${t.b}`;
            return `${includeAlpha ? `rgba(${rgb}, ${t.a}` : `rgb(${rgb}`})`; // String
        }
        switch (format) {
            case Color.FORMAT_HEX:
                return this.toInt(includeAlpha).toString(16);
            case Color.FORMAT_DEC:
                return this.toInt(includeAlpha).toString(10);
            case Color.FORMAT_CSS_HEX:
                return this.toHex(includeAlpha);
            case Color.FORMAT_CSS_RGB:
                return this.toRgbStr(includeAlpha);
            case Color.FORMAT_CSS_HSL:
                return this.toHslStr(includeAlpha);

            default:
        }
        return null;
    }

    /**
     * Returns an integer containing ARGB bytes.
     * @param {Boolean} includeAlpha - When set to TRUE, the alpha value is included with the result, otherwise the alpha value is not included.
     */
    toInt(/* Boolean? */ includeAlpha) {
        // summary:
        //		Returns an integer containing ARGB bytes
        // example:
        //	|	var c = new Color("#FFF").toInt();
        //	|	console.log(c); // 16777215
        let c = this.b;
        c |= this.g << 8;
        c |= this.r << 16;

        if (includeAlpha) c = (c | (Math.round(this.a * 255) << 24)) >>> 0;

        return c; // Number
    }

    /** Returns an integer containing  COLOREF GBR bytes. */
    toCOLORREF() {
        // summary:
        //		Returns an integer containing  COLOREF GBR bytes
        let c = this.r;
        c |= this.g << 8;
        c |= this.b << 16;

        return c; // Number
    }

    /**
     * @returns {string} rgba CSS style string of the current Color value
     */
    toString() {
        // summary:
        //		Returns a visual representation of the color
        return this.toCss(true); // String
    }
}

Color.FORMAT_HEX = 10;
Color.FORMAT_DEC = 11;
Color.FORMAT_CSS_HEX = 20;
Color.FORMAT_CSS_RGB = 21;
Color.FORMAT_CSS_HSL = 22;
Color.ALPHA_PRECISION = 2;
