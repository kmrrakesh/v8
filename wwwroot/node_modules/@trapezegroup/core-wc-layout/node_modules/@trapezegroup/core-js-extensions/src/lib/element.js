/* eslint-disable no-param-reassign */
/* eslint-disable guard-for-in */
// @ts-check

import { toPrimitive } from './cast.js';

/**
 * Returns an Element property. First looks for a DOM property on the specified Element. If the DOM property does not exist getProperty will then look for a HTML attribute of the same name. If no HTML attribute is found with that name the default value is returned. If a default value is specified the return type from both DOM property or HTML attribute is cast to the same data type as the default value automatically.
 * @param {HTMLElement} element - The element to get the property or attribute from
 * @param {String} name - Name of the property/attribute to access.
 * @param {Object} [defaultValue] - The default value to return if no DOM property or HTML attribute is found. NOTE: it's always worth passing a default value because if the default value is specified it is used to cast the result from both DOM property and HTML attribute to.
 */
export const getProperty = function getProperty(element, name, defaultValue) {
    if (element != null) {
        if (name in element)
            return defaultValue === undefined ? element[name] : toPrimitive(element[name], typeof defaultValue);

        if (element instanceof HTMLElement && element.dataset && element.dataset[name])
            return defaultValue === undefined
                ? element.dataset[name]
                : toPrimitive(element.dataset[name], typeof defaultValue);

        if (element.hasAttribute && element.hasAttribute(name))
            return defaultValue === undefined
                ? element.getAttribute(name)
                : toPrimitive(element.getAttribute(name), typeof defaultValue);
    }
    return defaultValue;
};

/**
 * Calls getProperty and assigns the result to the DOM property of the element.
 * @param {HTMLElement} element - The element to set the property or attribute on
 * @param {String} name - Name of the property/attribute to access.
 * @param {Object} [defaultValue] - The default value to return if no DOM property or HTML attribute is found. NOTE: it's always worth passing a default value because if the default value is specified it is used to cast the result from both DOM property and HTML attribute to.
 */
export const setProperty = function setProperty(element, name, defaultValue) {
    element[name] = getProperty(element, name, defaultValue);
    return element[name];
};

/**
 * Looks to see if the name specified exists as either a DOM property or HTML attribute on the current Element.
 * @param {String} name - Name of the property/attribute to access.
 */
export function hasProperty(element, name) {
    return name in element || element.hasAttribute(name);
}

/**
 * @param {HTMLElement} startElement - The element to staret the search from
 * @param {string} name - the name of the property or attribtue to get
 * @param {any} [defaultValue] - The default value to return. Is also used for casting purposes.
 * @returns {any} value f the found property or attribute
 */
export const getAncestorProperty = function getAncestorProperty(startElement, name, defaultValue) {
    const ancestor = closest(`[${name}]`, startElement);
    return ancestor && ancestor instanceof HTMLElement ? getProperty(ancestor, name, defaultValue) : null;
};

/**
 * @param {HTMLElement} element
 * @returns {boolean} Whether the element is disabled
 */
export function isDisabled(element) {
    const hasAttr = hasProperty(element, 'disabled');
    if (hasAttr && getProperty(element, 'disabled') === '') return true;
    return getProperty(element, 'disabled', hasAttr);
}

/**
 * @param {HTMLElement} element
 * @returns {boolean} Whether the element is read only
 */
export function isReadOnly(element) {
    const hasAttr = hasProperty(element, 'readOnly');
    if (hasAttr && getProperty(element, 'readOnly') === '') return true;
    return getProperty(element, 'readOnly', hasAttr) || isDisabled(element);
}

/**
 * @param {HTMLElement} element
 * @returns {boolean} Whether the element is required
 */
export function isRequired(element) {
    const hasAttr = hasProperty(element, 'required');
    if (hasAttr && getProperty(element, 'required') === '') return true;
    return getProperty(element, 'required', hasAttr);
}

/**
 * Looks at the element passed in and all of it's parent HTMLElements to see if the element is currently visible.
 * @param {HTMLElement} element
 * @returns {boolean}
 */
export function isDisplayed(element) {
    return element.offsetParent === null;
}

/** @typedef {Object} Offset
 * @property {number} left
 * @property {number} top
 */
/**
 * @param {HTMLElement} element
 * @returns {Offset}
 */
export function cumulativeOffset(element) {
    let valueT = 0;
    let valueL = 0;
    let nextElement = element;
    if (nextElement.parentNode) {
        if (nextElement.parentNode instanceof DocumentFragment) {
            // @ts-ignore
            nextElement = nextElement.host;
        }

        do {
            valueT += nextElement.offsetTop || 0;
            valueL += nextElement.offsetLeft || 0;
            // @ts-ignore
            nextElement = nextElement.offsetParent;
        } while (nextElement);
    }
    return { left: valueL, top: valueT };
}

/**
 * @param {string} tagName - Tag of the element to create
 * @param {object} attributes - HTML Attributes
 * @param {...Element|String} [content] - The element/s to append to this node. Can also be String of valid HTML.
 */
export function createElement(tagName, attributes, content) {
    attributes = attributes || {};
    const element = document.createElement(tagName);
    writeAttribute(element, attributes);
    if (content !== undefined) {
        append(element, content);
    }
    return element;
}

/**
 * @param {HTMLElement} element
 * @param {Object} attributes
 */
function writeAttribute(element, attributes) {
    // eslint-disable-next-line no-restricted-syntax
    for (const attr in attributes) {
        const name = attributeTranslations[attr] || attr;
        const value = attributes[attr];
        if (value === false || value === null) element.removeAttribute(name);
        else if (value === true) element.setAttribute(name, name);
        else element.setAttribute(name, value);
    }
    return element;
}

const attributeTranslations = {
    className: 'class',
    htmlFor: 'for',
};

/** Adds a collections of Elements to the current Element. This makes it easier to write cleaner JavaScript code that builds HTML Dom.
 * It also performs this in a DOM perfomant way where childred are constructed and added to the parent meaning that minimal modifications are made to the current DOM tree.
 * Differences between this and native appendChild:
 * - appendChild takes only a single child making it difficult to write clean code for multiple inserts.
 * - appendChild returns a refence to the inserted child. This makes it very difficult to chain results.
 * @param {Element} element - The element to append content to.
 * @param {...Element|String} content - The element/s to append to this node. Can also be String of valid HTML.
 * @example
 * {code}
 *  let someTdWeNeedRefTo;
 *	tr.append(
 *		createElement("TD").append(
 *			createElement("LABEL", {}, "Hello")
 *		),
 *		(someTdIneedRefTo = createElement("TD").append(
 *			createElement("LABEL", {}, "World")
 *		)),
 *		"<TD>Hello</TD>"
 *	);
 * {code}
 */
export function append(element, content) {
    // eslint-disable-next-line prefer-rest-params
    const args = arguments;
    const nodes = [];
    for (let i = 1, iLen = args.length; i < iLen; i++) {
        const node = args[i];
        if (node) {
            if (Array.isArray(node)) {
                for (let j = 0, jLen = node.length; j < jLen; j++) nodes[nodes.length] = node[j];
            } else if (typeof node === 'string') {
                const container = document.createElement('DIV');
                container.innerHTML = node;
                const containerNodes = container.childNodes;
                for (let j = 0, jLen = containerNodes.length; j < jLen; j++) nodes[nodes.length] = containerNodes[j];
            } else nodes[nodes.length] = node;
        }
    }

    const iLen = nodes.length;
    const frag = iLen > 1 || typeof element === 'string' ? document.createDocumentFragment() : element;
    for (let i = 0; i < iLen; i++) frag.appendChild(nodes[i]);

    if (iLen > 1 && typeof element !== 'string') element.appendChild(frag);

    return element;
}

/**
 * Same as Element.prototype.closest but will cross Shadow DOMs
 * @param {String} selector CSS selector to search for
 * @param {Element} startElement The Element to start the search from
 */
export function closest(selector, startElement) {
    if (startElement instanceof Element) {
        const found = startElement.closest(selector);
        // @ts-ignore
        return found || closest(selector, startElement.getRootNode().host);
    }

    return null;
}
