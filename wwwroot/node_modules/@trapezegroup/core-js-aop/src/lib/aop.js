/* eslint-disable no-restricted-syntax */
/* eslint-disable func-names */
/* eslint-disable no-plusplus */
/* eslint-disable no-param-reassign */
// @ts-check

/** Aspect-Oriented Programming (AOP) compliments Object-Oriented Programming (OOP) by allowing separation of cross-cutting concerns. */
export const AOP = {
    /**
     * Executes the advice after the method. The return value from the original method is passed into each advice where each advice can modify the return value. The result of the returned value of the advice will be used.
     * @param {Object} object - The instance of the class object being wrapped.
     * @param {String} method - The name of the method being wrapped.
     * @param {Function} advice - The advice function.
     * @param {Object} [scope] - The instance of the class object to set the scope.
     * @example
     *   _my_advice = function(result               \*result from the original method*\,
     *                         origScope            \*scope of the original method being overridden*\,
     *                         arg1, arg2...., argn \*arguments passed to the original method*\)
     *   {
     *     if(arg1 == true)
     *       return "Some different value";
     *     else
     *       return result; \*return the original result so it looks like the advice was never called*\
     *   }
     */
    after(object, method, advice, scope) {
        this._addAspect(object, method, advice, scope, 'after');
    },

    /**
     * Convenience method to supply advice after
     * @param {any} object - the Object to apply advice to
     * @param {any} methodAdviceMap - Hash of method name to intercept and the function to call that will give the advice
     * @param {any} scope the alternate scope to use other than the scope of the object instance. If not given the scope of the object instance will be used.
     */
    afterAll(object, methodAdviceMap, scope) {
        // eslint-disable-next-line guard-for-in
        for (const methodToWrap in methodAdviceMap) {
            AOP.after(object, methodToWrap, methodAdviceMap[methodToWrap], scope);
        }
    },

    //
    // Apply advice to a method if it throws an error. The advice function is applied when the target
    // method throws an Error.
    // Once the advice is finished the original Error is re-thrown.
    /**
     * Executes the advice after the method only if the method throws an exception. Once all of the advices have been executed, the original Error is re-thrown.
     * @param {Object} object - The instance of the class object being wrapped.
     * @param {String} method - The name of the method being wrapped.
     * @param {Function} advice - The advice function.
     * @param {Object} [scope] - The instance of the class object to set the scope.
     * @example
     *    _my_advice = function(arg1, arg2...., argn \*arguments passed to the original method*\)
     *    {
     *      // Perform some corrective action after the Exception is thrown
     *    }
     */
    afterThrowing(object, method, advice, scope) {
        this._addAspect(object, method, advice, scope, 'afterThrowing');
    },

    //
    // Apply advice around another function.
    //
    // If possible use the before or after aspects.
    // As a rule, only use around if you need to modify the arguments before calling the original function.
    // If you are not modifying arguments then use before or after aspects.
    //
    // The advice is responsible for calling the original function with the correct scope.
    // The function and scope are passed into the advice as the first and second parameter.
    // The original function should be called like this:
    //
    // advice(origFunc, origScope, arg1, arg2, arg3)
    // {
    //	origFunc.call(origScope, arg1, arg2, arg3)
    // }
    //
    // object - (Required) the Object to apply advice to
    // method - (Required) the Name of the method in the Object to apply advice to
    // advice - (Required) the function to call that will give the advice
    // scope - (Optional) the alternate scope to use other than the scope of the object instance.
    //				   If not given the scope of the object instance will be used.
    /**
     * Executes the advice around the method. This should only be used if state needs to be maintained between the before and after advices. Otherwise, use before or after advices where possible. It is up to the the advice to call (or not call) the original method. The result of the returned value of the advice will be used.
     * @param {Object} object - The instance of the class object being wrapped.
     * @param {String} method - The name of the method being wrapped.
     * @param {Function} advice - The advice function.
     * @param {Object} [scope] - The instance of the class object to set the scope.
     * @example
     *   _my_advice = function(origMethodRef        \*ref to the original method*\,
     *                         origScope            \*scope of the original method being overridden*\,
     *                         arg1, arg2...., argn \*arguments passed to the original method*\)
     *   {
     *     if(arg1 == true)
     *       return "Some different value";
     *     else
     *       return result; \*return the original result so it looks like the advice was never called*\
     *   }
     */
    around(object, method, advice, scope) {
        this._addAspect(object, method, advice, scope, 'around');
    },

    //
    // Convenience method to supply advice around
    //
    // object - (Required) the Object to apply advice to
    // methodAdviceMap - (Required) Hash of method name to intercept and the function to call that will give the advice
    // scope - (Optional) the alternate scope to use other than the scope of the object instance.
    //				   If not given the scope of the object instance will be used.
    /**
     * Convenient method to apply one around advice per method to many methods at once.
     * @param {Object} object - The instance of the class object being wrapped.
     * @param {Object} methodAdviceMap - Map of advices being wrapped onto the object where the object key values is the object name and the object value is the advice.
     * @param {Object} [scope] - The instance of the class object to set the scope.
     */
    aroundAll(object, methodAdviceMap, scope) {
        // eslint-disable-next-line guard-for-in
        for (const methodToWrap in methodAdviceMap) {
            AOP.around(object, methodToWrap, methodAdviceMap[methodToWrap], scope);
        }
    },

    //
    // Apply advice to a method before the method is invoked.
    //
    // You can override the original method by simply returning anything other than undefined.
    // {returnValue: <returnValueToBePassedToCaller>}
    // So, the advice returning null will prevent a call being made to the original caller.
    //
    // object - (Required) the Object to apply advice to
    // method - (Required) the Name of the method in the Object to apply advice to
    // advice - (Required) the function to call that will give the advice
    // scope - (Optional) the alternate scope to use other than the scope of the object instance.
    //				   If not given the scope of the object instance will be used.
    /**
     * Executes the advice before the method. Execution of advices can be stopped if any one of the advices returns any value other than undefined; the original function will not be called as well.
     * @param {Object} object - The instance of the class object being wrapped.
     * @param {String} method - The name of the method being wrapped.
     * @param {Function} advice - The advice function.
     * @param {Object} [scope] - The instance of the class object to set the scope.
     * @example
     *   _my_advice = function(origScope            \*scope of the original method being overridden*\,
     *                         arg1, arg2...., argn \*arguments passed to the original method*\)
     *   {
     *     if(arg1 == true)
     *       return "Some different value"; // Because a value other than undefined is returned the original method will NOT be called
     *     else if (arg2 == true)
     *       return undefined; // undefined is being returned so the original method will be called and its return value used
     *       // nothing is being returned so the original method will be called and its return value used
     *   }
     */
    before(object, method, advice, scope) {
        this._addAspect(object, method, advice, scope, 'before');
    },

    //
    // Convenience method to supply advice before
    //
    // object - (Required) the Object to apply advice to
    // methodAdviceMap - (Required) Hash of method name to intercept and the function to call that will give the advice
    // scope - (Optional) the alternate scope to use other than the scope of the object instance.
    // If not given the scope of the object instance will be used.
    /**
     * Convenient method to apply one before advice per method to many methods at once.
     * @param {Object} object - The instance of the class object being wrapped.
     * @param {Object} methodAdviceMap - Map of advices being wrapped onto the object where the object key values is the object name and the object value is the advice.
     * @param {Object} [scope] - The instance of the class object to set the scope.
     */
    beforeAll(object, methodAdviceMap, scope) {
        // eslint-disable-next-line guard-for-in
        for (const methodToWrap in methodAdviceMap) {
            AOP.before(object, methodToWrap, methodAdviceMap[methodToWrap], scope);
        }
    },

    //
    // public wrapper method for private method "_removeAspect"
    /**
     * Removes an advice from a method.
     * @param {Object} object - The instance of the class object being wrapped.
     * @param {String} method - The name of the method being wrapped.
     * @param {Function} advice - The advice function.
     * @param {String} adviceType - The type of advice the advice function was wrapped on.
     */
    remove(object, method, advice, adviceType) {
        this._removeAspect(object, method, advice, adviceType);
    },
    /**
     * Removes an after advice from a method.
     * @param {Object} object - The instance of the class object being wrapped.
     * @param {String} method - The name of the method being wrapped.
     * @param {Function} advice - The advice function.
     */
    removeAfter(object, method, advice) {
        this._removeAspect(object, method, advice, 'after');
    },
    /**
     * Removes a before advice from a method.
     * @param {Object} object - The instance of the class object being wrapped.
     * @param {String} method - The name of the method being wrapped.
     * @param {Function} advice - The advice function.
     */
    removeBefore(object, method, advice) {
        this._removeAspect(object, method, advice, 'before');
    },
    /**
     * Removes an around advice from a method.
     * @param {Object} object - The instance of the class object being wrapped.
     * @param {String} method - The name of the method being wrapped.
     * @param {Function} advice - The advice function.
     */
    removeAround(object, method, advice) {
        this._removeAspect(object, method, advice, 'around');
    },
    /**
     * Removes an after throwing advice from a method.
     * @param {Object} object - The instance of the class object being wrapped.
     * @param {String} method - The name of the method being wrapped.
     * @param {Function} advice - The advice function.
     */
    removeAfterThrowing(object, method, advice) {
        this._removeAspect(object, method, advice, 'afterThrowing');
    },

    /**
     * @param {{ [x: string]: any; prototype: any; _aop: any; }} object
     */
    removeAllByObject(object) {
        // @ts-ignore
        if (typeof object !== 'object') object = object.prototype;

        if (!object._aop) return;

        let method;
        const { _aop } = object;
        // eslint-disable-next-line guard-for-in
        for (method in _aop) object[method] = _aop[method].original;

        delete object._aop;
    },

    /**
     * @param {{ [x: string]: any; prototype: any; _aop: { [x: string]: { adviceTypes: { [x: string]: any; }; }; }; }} object
     * @param {string | number} method
     * @param {any} advice
     * @param {any} scope
     * @param {string} adviceType
     */
    _addAspect(object, method, advice, scope, adviceType) {
        // Initialize the AOP context holder
        // @ts-ignore
        if (typeof object !== 'object' && !object[method]) object = object.prototype;
        if (!object._aop) object._aop = {};
        if (!object._aop[method])
            object._aop[method] = {
                adviceTypes: {},
                // @ts-ignore
                aroundDispatcher: null, // around wrapper pre-built when around advices are added or removed
                original: object[method],
            };

        scope = scope == null ? this : scope;

        // The after advice wrapper needs to be applied first since the before advice wrapper can
        // prevent subsequent advices including the original method from being called. For example,
        // if the before advice wrapper is wrapped first and one of the advice prevents subsequent
        // calls, the original method would not be called and the wrapper can exit falling into the
        // after advice wrapper if it has been wrapped where it is not aware of the before advice's
        // wrapper has prevented subsequent calls.
        if (adviceType === 'before' && !object._aop[method].adviceTypes.after)
            this._createAspectCollection(object, method, 'after');

        if (!object._aop[method].adviceTypes[adviceType]) this._createAspectCollection(object, method, adviceType);

        // add aspect
        const advices = object._aop[method].adviceTypes[adviceType];
        advices[advices.length] = {
            advice,
            scope,
        };

        // @ts-ignore
        if (adviceType === 'around') this._rebuildAroundDispatcher(object, method);
    },

    /**
     * @param {{ [x: string]: any; prototype: any; _aop: { [x: string]: { adviceTypes: { [x: string]: any; }; }; }; }} object
     * @param {string | number} method
     * @param {any} advice
     * @param {string} adviceType
     */
    _removeAspect(object, method, advice, adviceType) {
        // @ts-ignore
        if (typeof object !== 'object' && !object[method]) object = object.prototype;
        if (!object._aop || !object._aop[method] || !object._aop[method].adviceTypes[adviceType]) return;

        const advices = object._aop[method].adviceTypes[adviceType];
        if (advices) {
            let i = 0;
            while (i < advices.length) {
                if (advices[i].advice === advice) advices.splice(i, 1);
                else i++;
            }
        }

        // @ts-ignore
        if (adviceType === 'around') this._rebuildAroundDispatcher(object, method);
    },

    /**
     * @param {{ _aop: { [x: string]: { adviceTypes: { [x: string]: any[]; }; }; }; }} object
     * @param {string | number} method
     * @param {string} adviceType
     */
    _createAspectCollection(object, method, adviceType) {
        object._aop[method].adviceTypes[adviceType] = [];
        this[`_${adviceType}`](object, method);
    },

    /**
     * @param {{ [x: string]: (arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, arg6: any, arg7: any, arg8: any) => any; _aop: { [x: string]: { adviceTypes: { after: any; }; }; }; }} object
     * @param {string | number} method
     */
    _after(object, method) {
        const old = object[method];
        const { after } = object._aop[method].adviceTypes;
        object[method] /**
         * @param {any} arg1
         * @param {any} arg2
         * @param {any} arg3
         * @param {any} arg4
         * @param {any} arg5
         * @param {any} arg6
         * @param {any} arg7
         * @param {any} arg8
         */ = function(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
            let result = old.call(this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
            for (let i = 0; i < after.length; i++)
                result = after[i].advice.call(
                    after[i].scope,
                    result,
                    this,
                    arg1,
                    arg2,
                    arg3,
                    arg4,
                    arg5,
                    arg6,
                    arg7,
                    arg8,
                );
            return result;
        };
    },

    /**
     * @param {{ [x: string]: (arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, arg6: any, arg7: any, arg8: any) => any; _aop: { [x: string]: { adviceTypes: { afterThrowing: any; }; }; }; }} object
     * @param {string | number} method
     */
    _afterThrowing(object, method) {
        const old = object[method];
        object[method] /**
         * @param {any} arg1
         * @param {any} arg2
         * @param {any} arg3
         * @param {any} arg4
         * @param {any} arg5
         * @param {any} arg6
         * @param {any} arg7
         * @param {any} arg8
         */ = function(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
            try {
                return old.call(this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
            } catch (excp) {
                let newExcp;
                const { afterThrowing } = object._aop[method].adviceTypes;
                const size = afterThrowing.length;
                for (let i = 0; i < size; i++)
                    newExcp = afterThrowing[i].advice.call(
                        afterThrowing[i].scope,
                        this,
                        excp,
                        arg1,
                        arg2,
                        arg3,
                        arg4,
                        arg5,
                        arg6,
                        arg7,
                        arg8,
                    );
                if (newExcp === undefined && size) return undefined;
                throw newExcp || excp;
            }
        };
    },

    /**
     * @param {{ [x: string]: (arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, arg6: any, arg7: any, arg8: any) => any; _aop: { [x: string]: any; }; }} object
     * @param {string | number} method
     */
    _around(object, method) {
        const old = object[method];
        const around = object._aop[method];
        object[method] /**
         * @param {any} arg1
         * @param {any} arg2
         * @param {any} arg3
         * @param {any} arg4
         * @param {any} arg5
         * @param {any} arg6
         * @param {any} arg7
         * @param {any} arg8
         */ = function(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
            // the "this" parameter is only used by the "_originalAroundDispatcher" when all around
            // advices has been removed to call the original function in the current scope,
            // "_makeNextAroundWrapper" ignores the "this" parameter since advices have their own
            // specified scope
            return around.aroundDispatcher(this, old, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
        };
    },

    /**
     * @param {{ [x: string]: (arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, arg6: any, arg7: any, arg8: any) => any; _aop: { [x: string]: { adviceTypes: { before: any; }; }; }; }} object
     * @param {string | number} method
     */
    _before(object, method) {
        const old = object[method];
        const { before } = object._aop[method].adviceTypes;
        object[method] = function(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
            let result;
            for (let i = 0, size = before.length; i !== size; i++) {
                result = before[i].advice.call(before[i].scope, this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
                if (result !== undefined) return result;
            }
            return result !== undefined ? result : old.call(this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
        };
    },

    /**
     * @param {any} object
     * @param {{ [x: string]: { scope: any; }; }} advices
     * @param {any} original
     * @param {number} i
     */
    _makeNextAroundWrapper(object, advices, original, i) {
        i++;
        const nextAroundFunc = advices[i + 1] ? this._makeNextAroundWrapper(object, advices, original, i) : null;
        return function(scope, old, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
            // @ts-ignore
            return advices[i].advice.call(
                advices[i].scope,
                // @ts-ignore
                nextAroundFunc || old,
                scope,
                arg1,
                arg2,
                arg3,
                arg4,
                arg5,
                arg6,
                arg7,
                arg8,
            );
        };
    },

    // used to call original function after around advices has been added then removed
    /**
     * @param {any} scope
     * @param {{ call: (arg0: any, arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, arg6: any, arg7: any, arg8: any) => void; }} old
     * @param {any} arg1
     * @param {any} arg2
     * @param {any} arg3
     * @param {any} arg4
     * @param {any} arg5
     * @param {any} arg6
     * @param {any} arg7
     * @param {any} arg8
     */
    _originalAroundDispatcher(scope, old, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
        return old.call(scope, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
    },

    /**
     * @param {{ _aop: { [x: string]: { aroundDispatcher: any; }; }; }} object
     * @param {string | number} method
     */
    _rebuildAroundDispatcher(object, method) {
        const aopMethod = object._aop[method];
        // @ts-ignore
        object._aop[method].aroundDispatcher = aopMethod.adviceTypes.around.length
            ? // @ts-ignore
              // @ts-ignore
              this._makeNextAroundWrapper(object, aopMethod.adviceTypes.around, aopMethod.original, -1)
            : this._originalAroundDispatcher;
    },
};
