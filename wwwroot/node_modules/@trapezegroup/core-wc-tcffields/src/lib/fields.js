/* eslint-disable no-plusplus */
/* eslint-disable no-param-reassign */
/* eslint-disable no-continue */
/* eslint-disable no-restricted-syntax */
/* eslint-disable guard-for-in */
// @ts-nocheck

import { getStyleDeclaration } from '/node_modules/@trapezegroup/core-js-extensions/src/lib/styles.js';
import { clone } from '/node_modules/@trapezegroup/core-js-extensions/src/lib/json.js';

/**
 * Gets the friendly display String of a Core.Type.AbstractType implementation instance.
 * Will first look through supplied selectorData for the display value. If no matches are found in the selectorData the toString will be called on the dataType.
 * @param {import('/node_modules/@trapezegroup/core-js-tcftypes/src/lib/types.js').AbstractType} dataType -
 * @param {?Object} fieldsInfo -
 * @param {HTMLElement} [localeNodeOrContext] -
 */
export const toDisplayValue = function toDisplayValue(dataType, fieldsInfo, localeNodeOrContext) {
    // Type safety checks. We should only run these for debugging because of performance
    // if(dataType instanceof Core.Type.AbstractType == false){throw new Error("Core.Cast.toDisplayValue: expected parameter 'dataType' to be of type Core.Type.AbstractType");}
    // if(fieldsInfo != null && fieldsInfo instanceof Core.Type.Rowset == false){throw new Error("Core.Cast.toDisplayValue: expected parameter 'fieldsInfo' to be of type Core.Type.Rowset");}

    const value = dataType.getValue();

    if (value === null) return '';

    let locale = localeNodeOrContext;
    if (locale && locale.nodeType) {
        const className = dataType.constructor.name;
        locale =
            locale[`localeCache_${className}`] || (locale[`localeCache_${className}`] = dataType.initLocale(locale));
    }

    if (fieldsInfo && fieldsInfo.selector != null && fieldsInfo.selector.length > 0) {
        const { separator } = fieldsInfo;

        if (fieldsInfo.bitField) {
            if (typeof value !== 'string' || value.length)
                return findSelectorValuesFromBitField(fieldsInfo.selector, value).join(separator);
        } else
            return separator && value.indexOf && value.indexOf(separator) > -1
                ? findSelectorValues(fieldsInfo.selector, value.split(separator)).join(separator)
                : findSelectorValues(fieldsInfo.selector, [value])[0];
    }

    if (locale) dataType.initLocale(locale);

    return dataType.toString();
};

/**
 * Merges headers (field layout) info into the Rowset.
 * The colHeaders array details here: https://dev.trapsoft.com/confluence/x/SJI-AQ
 * @param {import('/node_modules/@trapezegroup/core-js-tcftypes/src/lib/rowset.js').Rowset} rowset
 * @param {object[]} colHeaders
 * @param {boolean} tempKeepRowsetColumns
 */
export function mergeInHeaders(rowset, colHeaders, tempKeepRowsetColumns) {
    // Number of columns is limited by data columns.
    // We assume that there may be more data columns than layout columns
    // (e.g. hidden data values).
    let colsLen = Math.min(rowset.getColCount(), colHeaders.length);

    // This value will determine the column range in the default grid column group
    rowset.layoutColCount = colsLen;
    rowset.layoutRowCount = rowset.getRowCount();

    for (let i = 0; i < colsLen; i++) {
        if (!tempKeepRowsetColumns)
            if (rowset.json.header[i].type === 11) {
                // TODO Temp Remove Rowset Columns Because they are not supported
                rowset.json.header.splice(i, 1);
                for (let j = 0, rowLen = rowset.getRowCount(); j < rowLen; j++) rowset.json.data[j].splice(i, 1);
                rowset.json.defaults.splice(i, 1);
                colHeaders.splice(i, 0);
                i--;
                colsLen--;
                continue;
            }

        for (const name in colHeaders[i]) {
            const colHeader = colHeaders[i][name];
            if (colHeader instanceof Array) {
                switch (name) {
                    // Header may contain array wrappers,
                    // replace them with objects.
                    case 'valueStyleMap': {
                        // Value style map entries may also contain array wrappers,
                        // replace them with objects.
                        const valueStyleMap = colHeader[0];
                        for (const value in valueStyleMap)
                            if (valueStyleMap[value] instanceof Array && valueStyleMap[value].length === 1)
                                // eslint-disable-next-line prefer-destructuring
                                valueStyleMap[value] = valueStyleMap[value][0];
                    }
                    // Fall through
                    case 'input':
                    case 'inputStyle':
                    case 'captionStyle':
                    case 'displayStyle':
                        // eslint-disable-next-line prefer-destructuring
                        if (colHeader.length === 1) rowset.json.header[i][name] = colHeader[0];
                        break;
                    default:
                        rowset.json.header[i][name] = colHeader;
                }
            } else rowset.json.header[i][name] = colHeader;
        }
    }
}

/**
 * Attempts to add missing field layout headers to the Rowset.
 * Only headers with missing information are updated.
 * @param {import('/node_modules/@trapezegroup/core-js-tcftypes/src/lib/rowset.js').Rowset} rowset
 */
export function applyDefaultHeaders(rowset) {
    if (rowset && rowset.json) {
        for (let i = 0, len = rowset.json.header.length, header = null, styles = stylesData; i < len; i++) {
            header = rowset.json.header[i];

            if (!header.input) header.input = {};

            if (!header.valueStyleMap) header.valueStyleMap = {};

            if (!header.displayMode) header.displayMode = 0;

            if (!header.captionStyle) header.captionStyle = getStyles(styles.defaultCaptionStyle);

            if (!header.displayStyle) header.displayStyle = {};

            if (!header.inputStyle) header.inputStyle = {};

            if (!('separator' in header)) header.separator = ',';

            let { type } = header;

            while (type.length < 6) type = `0${type}`;

            switch (type) {
                case '000001':
                case '010001': {
                    if (!header.input.name) header.input.name = 'booleantoggle';
                    const noDisplayStyle = !header.displayStyle || Object.keys(header.displayStyle).length === 0;
                    if (!header.valueStyleMap.false && noDisplayStyle)
                        header.valueStyleMap.false = getStyles(styles.editorBooleanToggleOff);
                    if (!header.valueStyleMap.true && noDisplayStyle)
                        header.valueStyleMap.true = getStyles(styles.editorBooleanToggleOn);
                    break;
                }
                case '000012': // TCF Binary type not supported, and will be passed as null in JSON, so make it a string.
                    header.type = '10';
                    break;
                default:
            }

            // Expand css styles into object attributes

            expandStyleFromCss(header, header.captionStyle);
            expandStyleFromCss(header, header.inputStyle);
            expandStyleFromCss(header, header.displayStyle);
        }
    }
}

/**
 *
 * @param {*} header
 * @param {*} style
 */
function expandStyleFromCss(header, style) {
    if (style.cssSelector || style.cssSource) {
        getStyles({ selector: style.cssSelector, sheet: style.cssSource });
        Object.assign(style, _styleCache[style.cssSelector]);
        delete style.cssSelector;
        delete style.cssSource;
    }

    if (style.cssValueSelector || style.cssValueSource) {
        header.valueStyleMap._dynamicStyle = { cssSelector: style.cssValueSelector, cssSource: style.cssValueSource };
        delete style.cssValueSelector;
        delete style.cssValueSource;
    }
}

/**
 *
 * @param {} ctx
 */
function getStyles(ctx) {
    _styleCache[ctx.selector] = _styleCache[ctx.selector] || getStyleDeclaration(ctx.selector, ctx.sheet);
    return clone(_styleCache[ctx.selector]);
}

const stylesData = {
    defaultCaptionStyle: { selector: '.GridDefaultCaptionStyle', sheet: 'Core/Res/css/W3C/system.less.css' },
    editorBooleanToggleOn: { selector: '.EditorBooleanToggleOn', sheet: 'Core/Res/css/W3C/system.less.css' },
    editorBooleanToggleOff: { selector: '.EditorBooleanToggleOff', sheet: 'Core/Res/css/W3C/system.less.css' },
};

const _styleCache = {};
let _composeStyleMapGuard = {};

/**
 *
 * @param {*} obj
 * @param {*} styleHeader
 * @param {*} header
 * @param {*} key
 * @param {*} [propNames]
 * @param {*} [_depth]
 */
export function composeStyleMap(obj, styleHeader, header, key, propNames, _depth) {
    key = `${key}`;
    propNames = Object.assign({}, propNames, { style: 'style', content: 'content' }, false);
    _depth = _depth === undefined ? 0 : _depth;

    if (_depth === 0) _composeStyleMapGuard = {};

    if (!_composeStyleMapGuard[key]) {
        _composeStyleMapGuard[key] = true;

        const dynamicStyle = styleHeader._dynamicStyle;
        if (dynamicStyle) {
            if (!header._grid_dynamicStyle)
                header._grid_dynamicStyle = getStyleDeclaration(`${dynamicStyle.cssSelector}_`, dynamicStyle.cssSource);

            if (styleHeader[key] === undefined) {
                // Perform a shallow copy of _grid_dynamicStyle
                styleHeader[key] = Object.assign({}, header._grid_dynamicStyle);
                Object.assign(
                    styleHeader[key],
                    getStyleDeclaration(`${dynamicStyle.cssSelector}_${key}`, dynamicStyle.cssSource),
                );
            }
        }

        for (const styleName in styleHeader[key]) {
            if (styleName === 'include') {
                composeStyleMap(obj, styleHeader, header, styleHeader[key][styleName], propNames, _depth + 1);
                continue;
            }

            obj[propNames.style][styleName] = styleHeader[key][styleName];
            if (
                (styleName.indexOf('background') > -1 || styleName.indexOf('BACKGROUND') > -1) &&
                header.input.name in
                    { imageOnly: 1, booleantoggle: 1, selectortoggle: 1, 'core/ui/lib/input/checkbox/main': 1 }
            )
                obj[propNames.content] = '';
        }
    }
}

//
// Get Display Value from Selectors
//
/**
 * Get Display Value from Selectors.
 * @param {Object} selectorData -
 * @param {Array} values -
 */
const findSelectorValues = function findSelectorValues(selectorData, values) {
    const selLen = selectorData.length;
    const selValues = [];
    for (let i = 0, il = values.length; i < il; i++) {
        for (let j = 0; j < selLen; j++) {
            if (selectorData[j].value === values[i]) {
                selValues.push(selectorData[j].key);
                break;
            }
        }
    }
    return selValues.length > 0 ? selValues : values;
};

/**
 *
 * @param {*} selectorData
 * @param {*} value
 */
const findSelectorValuesFromBitField = function findSelectorValuesFromBitField(selectorData, value) {
    const selValues = [];
    for (let i = 0, iLen = selectorData.length; i < iLen; i++)
        // eslint-disable-next-line no-bitwise
        if ((2 ** selectorData[i].value) & value) selValues.push(selectorData[i].key);
    return selValues.length > 0 ? selValues : [];
};
