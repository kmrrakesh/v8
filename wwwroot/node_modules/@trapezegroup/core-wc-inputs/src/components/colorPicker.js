// / <reference path="..\html-dom.js" />
// / <reference path="inputs.js" />
// / <reference path="slider.js" />

import { createElement } from '../../../core-wc-lib/src/lib/common/htmlElement';

$file(
    'Core/UserAgent/W3C/UI/colorPicker.js',
    ['Core/UserAgent/W3C/UI/inputs.js', 'Core/UserAgent/W3C/UI/slider.js'],
    () => {
        // /////////////////////////////////////////////////////////////////////////////////////////////////
        // basic colorpicker

        Core.Class('Core.UI.ColorPicker.Basic', {
            extend: 'Behavior',

            statics: {
                CLASS_PALETTE: 'Palette',
                CLASS_PALETTE_ROW: 'PaletteRow',
                CLASS_SWATCH: 'Swatch',
                CLASS_SWATCH_SELECTED: 'Selected',
                CLASS_PREVIEW_CONTAINER: 'PreviewContainer',
                CLASS_PREVIEW: 'Preview',
            },

            events: {
                on_mousedown(evt) {
                    this.mousedown = true;
                    this._on_mouseEvents(evt);
                },
                on_mousemove(evt) {
                    if (this.mousedown) this._on_mouseEvents(evt);
                },
                on_mouseup(evt) {
                    if (this.mousedown) this._on_mouseEvents(evt);
                    this.mousedown = false;
                },

                on_keydown(event) {
                    if (
                        !event.altKey &&
                        !event.ctrlKey &&
                        !event.shiftKey &&
                        event.keyCode >= Event.KEY_LEFT &&
                        event.keyCode <= Event.KEY_DOWN
                    ) {
                        let row = this.curCell ? this.curCell.getProperty('row').toInt() : 0;
                        let col = this.curCell ? this.curCell.getProperty('col').toInt() : 0;

                        if (this.curCell)
                            switch (event.keyCode) {
                                case Event.KEY_LEFT:
                                    col--;
                                    break;
                                case Event.KEY_UP:
                                    row--;
                                    break;
                                case Event.KEY_RIGHT:
                                    col++;
                                    break;
                                case Event.KEY_DOWN:
                                    row++;
                                    break;
                            }

                        col = Math.mod(col, this.arrColor[0].length);
                        row = Math.mod(row, this.arrColor.length);
                        this.setColorValue(this.arrColor[row][col]);
                        event.preventDefault();
                    }
                },
            },

            methods: {
                /**
                 * A color picker input control that allows users to easily select a color value.
                 * @param {Element|Object} obj - The Element the color picker will be created on.
                 */
                initialize(obj, options) {
                    this.callSuper(obj);
                    this.node.tabIndex = 0;
                    this.palette = this.node.appendChild(
                        createElement('div', { className: this.statics.CLASS_PALETTE }),
                    );
                    this.previewContainer = this.node.appendChild(
                        createElement('div', { className: this.statics.CLASS_PREVIEW_CONTAINER }),
                    );
                    this.preview = this.previewContainer.appendChild(
                        createElement('div', { className: this.statics.CLASS_PREVIEW }),
                    );

                    // conf parameters
                    this.options = options || {};
                    this.paletteWidth = this.node.getProperty('width', 24); // number of swatches to render horizontally, should be in multiples of 6 so primary and secondary colors are always present
                    this.paletteHeight = this.node.getProperty('height', 23); // number of swatches to render vertically, should be an odd number so that 50% lightness colors are always present
                    this.paletteIgnoreFirstRow = this.node.getProperty('ignoreFirstRow', true); // does not render a row of white (#FFF) swatches when set to true
                    this.paletteIgnoreLastRow = this.node.getProperty('ignoreLastRow', true); // does not render a row of black (#000) swatches when set to true
                    this.paletteGrayScaleCol = this.node.getProperty('grayScaleCol', true); // show grayscale column

                    // runtime
                    this.color = new Core.Color(); // used to convert colors
                    this.curCell = null; // currently selected cell
                    this.arrColor = []; // stores table of colors
                    this.tableCache = {}; // color value keys referenced to swatch DOM objects
                    this.mousedown = false;
                    this.colorValue = this.options.startHex || '#000000';

                    this.buildColorArr();
                    if (this.paletteGrayScaleCol) this.addGrayScale();
                    this.populateTable();
                    this.selectColorByValue(this.colorValue);
                    this.disabled(this.node.hasAttribute('disabled'));
                    this.created = true;
                },

                dispose() {
                    this.palette = null;
                    this.previewContainer = null;
                    this.preview = null;

                    this.color = null;
                    this.curCell = null;
                    this.arrColor = null;
                    this.tableCache = null;

                    this.callSuper();
                },

                _on_mouseEvents(evt) {
                    const element = Event.element(evt);
                    if (element.hasClassName(this.statics.CLASS_SWATCH) && element != this.curCell)
                        this.selectColorBySwatch(element);
                },

                /**
                 * Sets a new color value.
                 * @param {String} hex - New color value to set. It must be formatted as "#RRGGBB".
                 */
                setColorValue(hex) {
                    this.selectColorByValue(hex);
                },

                /** Returns the current color value. */
                getColorValue() {
                    return this.colorValue;
                },

                getPreviewNode() {
                    return this.preview;
                },

                // Builds array table of colors (this.arrColor) with values in "#RRGGBB"
                buildColorArr() {
                    let colSize = this.paletteWidth,
                        rowSize = this.paletteHeight;
                    let colStart = 0,
                        rowStart = 0; // starting colors
                    let colInt = 1 / colSize,
                        rowInt = 0; // color intervals
                    let h,
                        s = 1,
                        l;

                    // row
                    if (this.paletteIgnoreFirstRow && this.paletteIgnoreLastRow) rowInt = 1 / (rowSize + 2 - 1);
                    else if (this.paletteIgnoreFirstRow || this.paletteIgnoreLastRow) rowInt = 1 / (rowSize + 1 - 1);
                    else rowInt = 1 / (rowSize - 1);
                    rowStart = this.paletteIgnoreFirstRow ? rowInt : 0;

                    // build array
                    for (let i = 0; i < rowSize; i++) {
                        this.arrColor[i] = [];
                        l = 1 - (i * rowInt + rowStart);
                        for (let j = 0; j < colSize; j++) {
                            h = j * colInt + colStart;
                            this.arrColor[i][j] = Core.Color.colorFromHsl([h, s, l], this.color).toHex();
                            // this.arrColor[i][j] = Core.Color.colorFromHsl(Core.Color.colorFromHsl([h, s, l], this.color).toHsl()).toHex(); // TEST
                        }
                    }
                },

                // appends gray scale column to "this.arrColor"
                addGrayScale() {
                    const rows = this.arrColor.length;
                    const interval = 255 / (rows - 1);
                    const curCol = this.arrColor[0].length;
                    let curColor;

                    for (let i = 0; i < rows; i++) {
                        curColor = Math.round(255 - i * interval);
                        this.arrColor[i][curCol] = Core.Color.colorFromArray(
                            [curColor, curColor, curColor],
                            this.color,
                        ).toHex();
                    }
                },

                disabled(disable) {
                    const isDisabled = this.node.hasAttribute('disabled');
                    if (disable === true && (!this.created || !isDisabled)) {
                        this.node.setAttribute('disabled', 'disabled');
                        this.stopObserving('mousedown');
                        this.stopObserving('mousemove');
                        this.stopObserving('mouseup');
                        this.stopObserving('keydown');

                        for (
                            var swatches = this.node.select(`.${this.statics.CLASS_SWATCH}`),
                                i = 0,
                                size = swatches.length;
                            i < size;
                            i++
                        )
                            swatches[i].title = '';
                    } else if (disable === false && isDisabled) {
                        // Events are initially observed, so don't need to check "this.created"
                        this.node.removeAttribute('disabled', 'disabled');
                        this.observe('mousedown');
                        this.observe('mousemove');
                        this.observe('mouseup');
                        this.observe('keydown');

                        for (
                            var swatches = this.node.select(`.${this.statics.CLASS_SWATCH}`),
                                i = 0,
                                size = swatches.length;
                            i < size;
                            i++
                        )
                            swatches[i].title = this.arrColor[swatches[i].getProperty('row')][
                                swatches[i].getProperty('col')
                            ];
                    } else return isDisabled;
                },

                // builds table based on array structure
                populateTable() {
                    let contents = '';
                    for (let i = 0, sizei = this.arrColor.length; i < sizei; i++) {
                        contents += `<div class='${this.statics.CLASS_PALETTE_ROW}'>`;
                        for (let j = 0, sizej = this.arrColor[i].length; j < sizej; j++)
                            contents += `<div class='${
                                this.statics.CLASS_SWATCH
                            }' tabindex='1' col='${j}' row='${i}' style='background-color: ${
                                this.arrColor[i][j]
                            }; color: ${this.arrColor[i][j]};' title='${this.arrColor[i][j]}'></div>`;
                        contents += '</div>';
                    }
                    this.palette.innerHTML = contents;
                },

                getPalette() {
                    return this.node;
                },
                getSelectedSwatch() {
                    return this.curCell;
                },

                // select color based on element parameter
                selectColorBySwatch(element) {
                    this.unselectSwatch();
                    this.curCell = element;
                    this.curCell.addClassName(this.statics.CLASS_SWATCH_SELECTED);

                    this.updatePosition();
                    this.preview.style.backgroundColor = this.curCell.style.backgroundColor;
                    this.colorValue = value = this.color.setColor(this.curCell.style.backgroundColor).toHex();

                    if (this.options.onChange)
                        this.options.onChange(this.color.setColor(this.curCell.style.backgroundColor).toHex());
                },

                // select swatch based on this.target.value
                selectColorByValue(value) {
                    this.colorValue = value = this.color.setColor(value).toHex();
                    if (!(value in this.tableCache))
                        this.tableCache[value] = this.palette.selectFirst(`[title='${value}']`);
                    if (value in this.tableCache && this.tableCache[value])
                        this.selectColorBySwatch(this.tableCache[value]);
                    else this.unselectSwatch();
                },

                // unselects currently active swatch
                unselectSwatch() {
                    if (this.curCell) {
                        this.curCell.removeClassName(this.statics.CLASS_SWATCH_SELECTED);
                        this.curCell = null;
                        this.previewContainer.style.display = 'none';
                    }
                },

                updatePosition() {
                    if (this.curCell)
                        setStyleUnsafe(this.previewContainer, {
                            display: 'block',
                            height: `${this.curCell.offsetHeight}px`,
                            left: `${this.curCell.offsetLeft}px`,
                            top: `${this.curCell.offsetTop}px`,
                            width: `${this.curCell.offsetWidth}px`,
                        });
                },
            },
        });

        // /////////////////////////////////////////////////////////////////////////////////////////////////
        // colorpicker widget

        Core.UI.Editor.DefaultWidgetMap.set('colorpicker', 'Core.UI.Editor.Color');
        Core.UI.Editor.DefaultWidgetMap.set('Core.Type.Metric.Color', 'Core.UI.Editor.Color');
        Core.UI.Editor.DefaultWidgetMap.set('Core.Type.Metric.ColorAlpha', 'Core.UI.Editor.Color');

        Core.Class('Core.UI.Editor.Color', {
            extend: 'Core.UI.Editor.AbstractDropInput',

            statics: {
                DIALOG_CLASS_NAMES: { drop: 'colorpane dlgpane', pane: 'colorpicker' },
                TAG_NAME_LIST_ITEM: '.Swatch',
                DEFAULT_DATATYPE: Core.Type.Metric.Color,
                ALPHA_DATATYPE: [Core.Type.Metric.ColorAlpha, Core.Type.String],
                ALLOWED_DATATYPES: [
                    Core.Type.Metric.Color,
                    Core.Type.Metric.ColorAlpha,
                    Core.Type.Metric.ColorRef,
                    Core.Type.String,
                ],
                COLOR_KEYWORDS: { '': true, currentColor: true, inherit: true, transparent: true },
                DEFAULT_EMPTY_DISPLAY_VALUE: '',
                generateContainer(inputProperties) {
                    return createElement('CORE:COLORPICKER', inputProperties);
                },
                ALPHA_PRECISION: 2,
                SLIDER_CONTEXT: {
                    atHandlersEnabled: false,
                    clickStep: 0.05,
                    endValue: 1,
                    hideLabels: 'START,END,CURRENT',
                    mouseWheelStep: 0.05,
                    showMouseLabelOnMouseDown: true,
                    snapMouseLabelToTracker: true,
                    startValue: 0,
                    step: 0.01,
                    value: 1,
                },
                SHOW_DIALOG_ON_INPUT_FOCUS: true,
                CLOSE_DIALOG_ONSELECTION: false,
                DIALOG_IS_FIXED_SIZE: true,
                DIALOG_SELECTABLE: true,
                PASS_INPUT_KEYS_TO_DIALOG: false,
                DIALOG_KEY_MAPPING: {},
            },

            methods: {
                initialize(obj) {
                    this.callSuper(obj);
                    this.color = new Core.Color();

                    setProperty(this, 'mode', 'basic');
                    this.isMinimal = this.node.hasClassName('Minimal') || this.node.hasClassName('Custom');
                    this.mode = this.mode.toLowerCase();
                    this.hasAtPreviewUpdate = !!$AV(this.node, 'atPreviewUpdate');
                },

                init() {
                    // TODO mechanism temporarily used to check for extType
                    switch (this.node.getProperty('extType', '').toUpperCase()) {
                        case 'COLOR':
                            this.dataType = new Core.Type.Metric.Color();
                            break;
                        case 'COLORALPHA':
                            this.dataType = new Core.Type.Metric.ColorAlpha();
                            break;
                        case 'COLORREF':
                            this.dataType = new Core.Type.Metric.ColorRef();
                            break;
                        case 'CSS':
                        case 'STRING':
                            this.dataType = new Core.Type.String();
                            break;
                        default:
                            this.dataType = new Core.Type.Metric.Color();
                            break;
                    }

                    this.callSuper();
                    this.atPreviewUpdate();
                },

                setDataType(abstractDataType) {
                    this.callSuper(abstractDataType);
                    this.node.dialog.setAttribute('coloralpha', this._isAlphaDataType() ? 1 : 0);
                    this.node.dialog.style.height = this.node.dialog.style.width = 'auto'; // TODO dialog does not need to set width/height
                },

                initInputNode() {
                    const value = this.getDisplayValue();
                    const nodeName = this.isMinimal ? 'DIV' : 'INPUT';
                    const className = this.isMinimal ? 'in' : '';
                    const input = createElement(nodeName, {
                        autocomplete: 'off',
                        className,
                        key: '',
                        type: 'text',
                        value,
                    });
                    this.node.textInput = this.node.appendChild(input);

                    if (this.isDrop && !this.isMinimal) {
                        this.inputPreviewContainerNode = this.node.appendChild(
                            createElement('div', { className: 'InputPreviewContainer' }),
                        );
                        this.inputPreviewNode = this.inputPreviewContainerNode.appendChild(
                            createElement('div', { className: 'InputPreview' }),
                        );
                    }

                    if (!getProperty(this, 'required', true)) {
                        const clearButton = input.appendChild(createElement('DIV', { className: 'Clear' }));
                        this.observe('click', clearButton, 'clear');
                    }

                    this.setDisplayValue(value);
                    return this.node.textInput;
                },

                nondropInit(initialValue, initialText) {
                    this.callSuper(initialValue, initialText);
                    this.setColorPickerMode(this.mode);
                },

                _getNaturalSize(node) {
                    const size = {};
                    const origStyle = {
                        display: node.style.display,
                        height: node.style.height,
                        position: node.style.position,
                        width: node.style.width,
                    };
                    const newStyle = { display: 'inline-block', height: 'auto', position: 'fixed', width: 'auto' };

                    Object.extend(node.style, newStyle);
                    size.width = node.offsetWidth;
                    size.height = node.offsetHeight;
                    Object.extend(node.style, origStyle);

                    return size;
                },

                adjustWidth() {},

                generateDialogContent(event, aValue, items) {
                    const value = aValue === null ? '0' : this.color.setColor(aValue).toHex(this._isAlphaDataType());

                    if (!this.colorpickers) {
                        this.dialogWrapper = this.node.dialog.appendChild(
                            createElement('div', { className: 'DialogWrapper' }),
                        );
                        this.colorpickers = [];

                        const sliderContext = Object.extend(Object.extend({}, this.statics.SLIDER_CONTEXT), {
                            onSliderDragStop: this._handleOpacitySliderOnChange.bind(this),
                            value: this.color.setColor(value).a,
                        });
                        this.slider = new Core.UI.Slider(
                            this.dialogWrapper.appendChild(createElement('div')),
                            sliderContext,
                        );
                        Core.System.AOP.after(this.slider, 'setValue', this._selectItem, this);

                        const basicColorpickerNode = this.dialogWrapper.appendChild(
                            createElement('div', { className: 'Basic' }),
                        );
                        this.colorpickers.basic = new Core.UI.ColorPicker.Basic(basicColorpickerNode, {
                            onChange: this._selectItem.bind(this),
                            startHex: value,
                        });

                        const advancedColorpickerNode = this.dialogWrapper.appendChild(
                            createElement('div', { className: 'Advanced' }),
                        );
                        this.colorpickers.advanced = new Core.UI.ColorPicker.Advanced('cp1', {
                            container: advancedColorpickerNode,
                            onChange: this._selectItem.bind(this),
                            previewUpdate: !this.hasAtPreviewUpdate,
                            startHex: value.replace(/#/, ''),
                            startMode: 's',
                        });

                        this.modeToggleNode = this.node.dialog.appendChild(createElement('div', { className: 'Mode' }));
                        this.setColorPickerMode(this.mode);
                    }

                    this.node.dialog.setAttribute('coloralpha', this._isAlphaDataType() ? 1 : 0);
                    this.colorpickers[this.mode].setColorValue(value);
                },

                _handleOpacitySliderOnChange() {
                    const value = this.slider.getValue();

                    // this.colorpickers.basic.getPreviewNode().setOpacity(value);
                    this.colorpickers.advanced.getPreviewNode().setOpacity(value);

                    this.color.setColor(this.node.getProperty('value', 0));
                    this.color.a = value.round2(this.statics.ALPHA_PRECISION);
                    this._selectItem();
                },

                _handleModeToggle() {
                    this.setColorPickerMode(this.mode === 'basic' ? 'advanced' : 'basic');
                },

                setColorPickerMode(mode) {
                    const value = this.colorpickers[this.mode].getColorValue();
                    this.mode = mode.toLowerCase();
                    this.node.dialog.setAttribute('mode', this.mode.capitalizeFirstChar());
                    this.colorpickers[this.mode].setColorValue(value);

                    if (this.created) this.colorpickers[this.mode].node.focus(); // Setting focus to allow keyboard navigation
                    this.node.dialog.style.height = this.node.dialog.style.width = 'auto'; // TODO dialog does not need to set width/height

                    // Forcing IE8 to repaint
                    if (Prototype.Browser.IE8) {
                        const origDisplay = this.node.dialog.style.display;
                        this.node.dialog.style.display = 'none';
                        this.node.dialog.style.display = origDisplay;
                    }
                },

                disabled(disable) {
                    const isDisabled = this.node.hasAttribute('disabled');
                    if (disable === true && (!this.created || !isDisabled)) {
                        this.colorpickers[this.mode].disabled(true);
                        this.stopObserving('mousedown', this.modeToggleNode, '_handleModeToggle');
                        if (this.node.dialog) this.stopObserving('dblclick', this.node.dialog);
                        if (this.node.textInput) this.stopObserving('keypress', this.node.textInput, 'on_keyup');
                    } else if (disable === false && (!this.created || isDisabled)) {
                        this.colorpickers[this.mode].disabled(false);
                        this.observe('mousedown', this.modeToggleNode, '_handleModeToggle');
                        if (this.node.dialog) this.observe('dblclick', this.node.dialog);
                        if (this.node.textInput) this.observe('keypress', this.node.textInput, 'on_keyup');
                    }
                    return this.callSuper(disable);
                },

                readOnly(readOnly) {
                    const isReadOnly = this.node.hasAttribute('readOnly');
                    if (readOnly === true && (!this.created || !isReadOnly)) {
                        this.colorpickers[this.mode].disabled(true);
                        this.stopObserving('mousedown', this.modeToggleNode, '_handleModeToggle');
                        if (this.node.dialog) this.stopObserving('dblclick', this.node.dialog);
                        if (this.node.textInput) this.stopObserving('keypress', this.node.textInput, 'on_keyup');
                    } else if (readOnly === false && (!this.created || isReadOnly)) {
                        this.colorpickers[this.mode].disabled(false);
                        this.observe('mousedown', this.modeToggleNode, '_handleModeToggle');
                        if (this.node.dialog) this.observe('dblclick', this.node.dialog);
                        if (this.node.textInput) this.observe('keypress', this.node.textInput, 'on_keyup');
                    }
                    return this.callSuper(readOnly);
                },

                dragEnd(event) {
                    this.callSuper(event);

                    // Mouseup is not fired at the end of a capture in IE8, the mouseup
                    // event has to be manually fired, so that other components handle
                    // the UI updates appropriately
                    if (Prototype.Browser.IE8) event.target.dispatch('mouseup', event);
                },

                getData() {
                    return null;
                },
                getFocusItem() {
                    return this.colorpickers[this.mode].node;
                },
                getInitialItem() {
                    return null;
                },
                _getInitialValue() {
                    const defaultValue = this.dataType instanceof Core.Type.String ? '' : 0;
                    return getProperty(this, 'value', defaultValue) || defaultValue;
                },
                getSelectedValue() {
                    const value = this.dataType.getValue();
                    const isColorPickerActive =
                        document.activeElement === this.getInputElement() ||
                        document.activeElement === this.colorpickers.basic.node ||
                        document.activeElement === this.colorpickers.advanced.node;
                    return this.dataType instanceof Core.Type.String &&
                        isColorPickerActive &&
                        value in this.statics.COLOR_KEYWORDS
                        ? value
                        : this._getMergedValue(this.colorpickers[this.mode].getColorValue());
                },
                _isAlphaDataType() {
                    for (let i = 0, iLen = this.statics.ALPHA_DATATYPE.length; i < iLen; i++)
                        if (this.dataType instanceof this.statics.ALPHA_DATATYPE[i]) return true;
                    return false;
                },

                _createAtHandlerContext(event, newValue) {
                    const context = this.callSuper(event, newValue);
                    if (this.format !== undefined || this.dataType instanceof Core.Type.String)
                        context.newValue = this._convertValue(context.newValue, 'locale');
                    return context;
                },

                // Backwards compatibility method, values may need to be sent back to the server as a CSS color string if "format" attribute is set
                _convertValue(value, to) {
                    const dataType = this.dataType || new this.statics.DEFAULT_DATATYPE(null, this.node);
                    const localeValue = this.node.hasAttribute(localeKey)
                        ? this.node.getAttribute(localeKey)
                        : undefined;
                    var localeKey = dataType.getLocalizationKey();

                    if (this.format !== undefined) this.node.setAttribute(localeKey, this.format);

                    let newValue;
                    switch (to) {
                        case 'locale':
                            var dt = new $namespace.cache[(Core.Class.getClassName(dataType))](
                                undefined,
                                this.node,
                            ).fromString(value);
                            newValue = dt.toString();
                            break;
                        case 'raw':
                            var dt = new $namespace.cache[(Core.Class.getClassName(dataType))](
                                undefined,
                                this.node,
                            ).fromString(value);
                            newValue = dt.getValue();
                            break;
                    }

                    if (localeValue !== undefined) this.node.setAttribute(localeKey, localeValue);
                    else if (this.format !== undefined) this.node.removeAttribute(localeKey);

                    return newValue;
                },

                // Used as hook to correctly position of components after it has been made visible on the DOM...
                internalSetItemFocus() {
                    this.callSuper();
                    this.colorpickers[this.mode].updatePosition();
                },

                on_dblclick(event) {
                    if (this.isDrop && event.target.descendantOf(this.colorpickers[this.mode].getPalette()))
                        this.hidePopup();
                },

                on_keydown(event) {
                    const src = event.target;
                    if (
                        event.keyCode === Event.KEY_RETURN ||
                        event.keyCode === Event.KEY_TAB ||
                        src === this.node.dialog ||
                        !src.descendantOf(this.node.dialog)
                    )
                        switch (event.keyCode) {
                            case Event.KEY_LEFT:
                                if (event.target.descendantOf(this.node.dialog))
                                    if (event.altKey && this.isDrop) this.node.dropbutton.internalKeyDown(event);
                                    else {
                                        if (!this.node.dialog) this.generateDialog(event);
                                        this.selectPreviousItem(event, this.isDrop);
                                    }
                                break;
                            case Event.KEY_RIGHT:
                                if (event.target.descendantOf(this.node.dialog))
                                    if (event.altKey && this.isDrop) this.node.dropbutton.internalKeyDown(event);
                                    else {
                                        if (!this.node.dialog) this.generateDialog(event);
                                        this.selectNextItem(event, this.isDrop);
                                    }
                                break;
                            default:
                                this.callSuper(event);
                                break;
                        }
                },

                on_keyup(force) {
                    if (this.node.textInput && (force || document.activeElement === this.node.textInput)) {
                        this.color.setColor(this.node.textInput.value);
                        const alpha = this.color.a;
                        const hex = this.color.toHex();

                        this.colorpickers[this.mode].setColorValue(hex);
                        this.slider.setValue(alpha);
                        this._setInputPreviewNode(this.node.textInput.value);

                        const previewNode = this.colorpickers.advanced.getPreviewNode();
                        previewNode.style.backgroundColor = hex;
                        previewNode.setOpacity(alpha);
                    }
                },

                on_mouseup(event) {
                    const srcElem = event.target;
                    if (!srcElem.descendantOf(this.node.dialog) || srcElem.nodeName !== 'INPUT') this.callSuper(event);
                },

                replaceDialogContent() {},
                selectItemFromValue(event, aValue, update) {
                    aValue = aValue || 0;
                    if (update !== false)
                        this.colorpickers[this.mode].setColorValue(
                            this.color
                                .setColor(aValue instanceof Core.Type.AbstractType ? aValue.getValue() : aValue)
                                .toHex(),
                        );
                },

                setDisplayValue(value) {
                    if (value != null) {
                        if (this.isMinimal) this._setInputPreviewNode(value);
                        else {
                            this.callSuper(value);

                            if (this.colorpickers) {
                                let hex = this._getMergedValue(
                                    value instanceof Core.Type.AbstractType ? value.getValue() : value,
                                    false,
                                );
                                hex = this.color
                                    .setColor(hex)
                                    .toHex(this.dataType instanceof Core.Type.Metric.ColorAlpha);
                                this.colorpickers.basic.setColorValue(hex);
                                this.colorpickers.advanced.setColorValue(hex);
                            }

                            this._setInputPreviewNode(value);
                        }
                    }
                },

                _setInputPreviewNode(value) {
                    const elem = this.isMinimal ? this.node.textInput : this.inputPreviewNode;
                    if (elem) {
                        if (value in this.statics.COLOR_KEYWORDS) {
                            elem.style.backgroundColor = value;
                            elem.setOpacity(0);
                        } else {
                            elem.style.backgroundColor = this.color.setColor(value).toRgbStr();
                            elem.setOpacity(this.color.a);
                        }
                    }
                },

                // Ensure DOM "value" adhere to "format" attribute
                setValue(value) {
                    this.callSuper(value);
                    this.node.value =
                        this.format === undefined ? this.node.value : this._convertValue(this.node.value, 'locale');
                    this.atPreviewUpdate(value);
                },

                atPreviewUpdate(value) {
                    if (this.hasAtPreviewUpdate) {
                        const styles = this.node.atHandler('atPreviewUpdate', true, {
                            value: value || this.dataType.toString(),
                        });
                        if (styles) {
                            const previewNode = this.colorpickers.advanced.getPreviewNode();
                            previewNode.style.cssText = styles;
                            previewNode.style.height = previewNode.style.width = '100%';
                        }
                    }
                },

                // The colorpicker and opacity slider are separate components, so their values must be
                // merged together to produce the final color value
                _getMergedValue(color, isAlpha) {
                    isAlpha = isAlpha !== undefined ? isAlpha : this._isAlphaDataType();
                    this.color.setColor(color === undefined ? this.colorpickers[this.mode].getColorValue() : color);
                    this.color.a = isAlpha ? this.slider.getValue().round2(this.statics.ALPHA_PRECISION) : 1;
                    return this._convertValue(
                        this.dataType instanceof Core.Type.String
                            ? this.color.toCss(isAlpha)
                            : this.color.toHex(isAlpha),
                        'locale',
                    );
                },

                _selectItem() {
                    if (this.created) {
                        const value = this._getMergedValue(this.colorpickers[this.mode].getColorValue());
                        this.node.atHandler(
                            'atItemSelected',
                            true,
                            { behavior: this, widget: this.node, value: this.parseValue(value), item: null },
                            true,
                        );
                    }
                },

                clear(evt) {
                    if (this.node.textInput) {
                        this.hidePopup();
                        evt.stop();
                        this.node.textInput.value = '';
                        this.on_keyup(true);
                        this.update(null, evt);
                    }
                },

                showPopup(evt) {
                    if (!evt || evt.target.hasClassName('Clear') === false) return this.callSuper(evt);
                },

                scrollIntoView() {},
            },

            binders: {
                bind_data(binder) {
                    // Colour Picker has no data as it generates it's own.
                },

                bind_complete() {
                    // DEPRECIATED, now that the colorpicker supports Core.Type.String data type
                    // Backwards compatibility, controls formatting of color values sent to the server, accepts enums pre-defined in Core.Type.Locale.color
                    setProperty(this, 'format');

                    if (this.format !== undefined)
                        this.node.value = this._convertValue(this.node.getProperty('value'), 'raw');

                    this.callSuper();
                },
            },
        });

        Core.Class('Core.UI.Editor.Color.Hue', {
            extend: Core.UI.Slider,

            statics: {
                CSSCLASS_CONTAINER: 'EditorColorHue',
                DEFAULT_CONTEXT: { clickStep: 11.25 / 360, hideLabels: true, step: 1 / 360, value: 0 },
                STRICT_CONTEXT: { endValue: 1, startValue: 0 },
            },

            methods: {
                initialize(obj, context) {
                    this.callSuper(
                        obj,
                        Object.extend(
                            Object.extend(JSON.clone(this.statics.DEFAULT_CONTEXT), context),
                            this.statics.STRICT_CONTEXT,
                        ),
                    );
                    this.node.addClassName(this.statics.CSSCLASS_CONTAINER);
                    this.colorObj = new Core.Color();
                },

                setValue(value, notify) {
                    const retVal = this.callSuper(value, notify);
                    const hslArr = [this.getValue() % 1, 1, 0.5]; // Prototype.Browser.IE8, modulo needed for IE8
                    this.trackerNode.style.backgroundColor = Core.Color.colorFromHsl(hslArr, this.colorObj).toCss();
                    return retVal;
                },
            },
        });

        // /////////////////////////////////////////////////////////////////////////////////////////////////
        // implemented john dyer's color picker

        /** @ignore */
        Core.Class('Core.UI.ColorPicker.Advanced', { extend: 'Behavior', methods: Behavior });

        Core.UI.ColorPicker.Advanced.DefaultColorPickerSettings = {
            startMode: 'h',
            startHex: 'ff0000',
            clientFilesPath: '/Core/Res/img/Backgrounds/colorpicker/',

            // custom implementation
            container: null, // parent node
            onChanged: null, // gets called when color value changes, returns {h,s,b,r,g,b,hex}
            previewUpdate: true, // preview node updates when color changes if TRUE
        };

        Core.UI.ColorPicker.Advanced.DefaultSliderSettings = {
            xMinValue: 0,
            xMaxValue: 100,
            yMinValue: 0,
            yMaxValue: 100,
            arrowImage: '/Core/Res/img/Arrows/rangearrows.gif',
        };

        Core.UI.ColorPicker.Advanced.Color = function(init) {
            const color = {
                r: 0,
                g: 0,
                b: 0,

                h: 0,
                s: 0,
                v: 0,

                hex: '',

                setRgb(r, g, b) {
                    this.r = r;
                    this.g = g;
                    this.b = b;

                    const newHsv = Core.UI.ColorPicker.Advanced.ColorMethods.rgbToHsv(this);
                    this.h = newHsv.h;
                    this.s = newHsv.s;
                    this.v = newHsv.v;

                    this.hex = Core.UI.ColorPicker.Advanced.ColorMethods.rgbToHex(this);
                },

                setHsv(h, s, v) {
                    this.h = h;
                    this.s = s;
                    this.v = v;

                    const newRgb = Core.UI.ColorPicker.Advanced.ColorMethods.hsvToRgb(this);
                    this.r = newRgb.r;
                    this.g = newRgb.g;
                    this.b = newRgb.b;

                    this.hex = Core.UI.ColorPicker.Advanced.ColorMethods.rgbToHex(newRgb);
                },

                setHex(hex) {
                    this.hex = hex;

                    const newRgb = Core.UI.ColorPicker.Advanced.ColorMethods.hexToRgb(this.hex);
                    this.r = newRgb.r;
                    this.g = newRgb.g;
                    this.b = newRgb.b;

                    const newHsv = Core.UI.ColorPicker.Advanced.ColorMethods.rgbToHsv(newRgb);
                    this.h = newHsv.h;
                    this.s = newHsv.s;
                    this.v = newHsv.v;
                },
            };

            if (init) {
                if (init.hex) color.setHex(init.hex);
                else if (init.r) color.setRgb(init.r, init.g, init.b);
                else if (init.h) color.setHsv(init.h, init.s, init.v);
            }

            return color;
        };

        Core.UI.ColorPicker.Advanced.ColorMethods = {
            hexToRgb(hex) {
                hex = this.validateHex(hex);

                let r = '00',
                    g = '00',
                    b = '00';

                /*
		if (hex.length == 3) {
			r = hex.substring(0,1);
			g = hex.substring(1,2);
			b = hex.substring(2,3);
		} else if (hex.length == 6) {
			r = hex.substring(0,2);
			g = hex.substring(2,4);
			b = hex.substring(4,6);
		*/
                if (hex.length == 6) {
                    r = hex.substring(0, 2);
                    g = hex.substring(2, 4);
                    b = hex.substring(4, 6);
                } else {
                    if (hex.length > 4) {
                        r = hex.substring(4, hex.length);
                        hex = hex.substring(0, 4);
                    }
                    if (hex.length > 2) {
                        g = hex.substring(2, hex.length);
                        hex = hex.substring(0, 2);
                    }
                    if (hex.length > 0) {
                        b = hex.substring(0, hex.length);
                    }
                }

                return { r: this.hexToInt(r), g: this.hexToInt(g), b: this.hexToInt(b) };
            },
            validateHex(hex) {
                hex = new String(hex).toUpperCase();
                hex = hex.replace(/[^A-F0-9]/g, '0');
                if (hex.length > 6) hex = hex.substring(0, 6);
                return hex;
            },
            webSafeDec(dec) {
                dec = Math.round(dec / 51);
                dec *= 51;
                return dec;
            },
            hexToWebSafe(hex) {
                let r, g, b;

                if (hex.length == 3) {
                    r = hex.substring(0, 1);
                    g = hex.substring(1, 1);
                    b = hex.substring(2, 1);
                } else {
                    r = hex.substring(0, 2);
                    g = hex.substring(2, 4);
                    b = hex.substring(4, 6);
                }
                return (
                    intToHex(this.webSafeDec(this.hexToInt(r))) +
                    this.intToHex(this.webSafeDec(this.hexToInt(g))) +
                    this.intToHex(this.webSafeDec(this.hexToInt(b)))
                );
            },
            rgbToWebSafe(rgb) {
                return { r: this.webSafeDec(rgb.r), g: this.webSafeDec(rgb.g), b: this.webSafeDec(rgb.b) };
            },
            rgbToHex(rgb) {
                return this.intToHex(rgb.r) + this.intToHex(rgb.g) + this.intToHex(rgb.b);
            },
            intToHex(dec) {
                let result = dec.toInt().toString(16);
                if (result.length == 1) result = `0${result}`;
                return result.toUpperCase();
            },
            hexToInt(hex) {
                return hex.toInt(16);
            },
            rgbToHsv(rgb) {
                const r = rgb.r / 255;
                const g = rgb.g / 255;
                const b = rgb.b / 255;
                const hsv = { h: 0, s: 0, v: 0 };
                let delta;
                let min = 0;
                let max = 0;

                if (r >= g && r >= b) {
                    max = r;
                    min = g > b ? b : g;
                } else if (g >= b && g >= r) {
                    max = g;
                    min = r > b ? b : r;
                } else {
                    max = b;
                    min = g > r ? r : g;
                }

                hsv.v = max;
                hsv.s = max ? (max - min) / max : 0;

                if (!hsv.s) {
                    hsv.h = 0;
                } else {
                    delta = max - min;
                    if (r == max) {
                        hsv.h = (g - b) / delta;
                    } else if (g == max) {
                        hsv.h = 2 + (b - r) / delta;
                    } else {
                        hsv.h = 4 + (r - g) / delta;
                    }

                    hsv.h = Math.round(hsv.h * 60);
                    if (hsv.h < 0) {
                        hsv.h += 360;
                    }
                }

                hsv.s = Math.round(hsv.s * 100);
                hsv.v = Math.round(hsv.v * 100);

                return hsv;
            },
            hsvToRgb(hsv) {
                rgb = { r: 0, g: 0, b: 0 };

                let h = hsv.h;
                let s = hsv.s;
                let v = hsv.v;

                if (s == 0) {
                    if (v == 0) {
                        rgb.r = rgb.g = rgb.b = 0;
                    } else {
                        rgb.r = rgb.g = rgb.b = (v * 255 / 100).toInt();
                    }
                } else {
                    if (h == 360) {
                        h = 0;
                    }
                    h /= 60;

                    // 100 scale
                    s /= 100;
                    v /= 100;

                    const i = h.toInt();
                    const f = h - i;
                    const p = v * (1 - s);
                    const q = v * (1 - s * f);
                    const t = v * (1 - s * (1 - f));
                    switch (i) {
                        case 0:
                            rgb.r = v;
                            rgb.g = t;
                            rgb.b = p;
                            break;
                        case 1:
                            rgb.r = q;
                            rgb.g = v;
                            rgb.b = p;
                            break;
                        case 2:
                            rgb.r = p;
                            rgb.g = v;
                            rgb.b = t;
                            break;
                        case 3:
                            rgb.r = p;
                            rgb.g = q;
                            rgb.b = v;
                            break;
                        case 4:
                            rgb.r = t;
                            rgb.g = p;
                            rgb.b = v;
                            break;
                        case 5:
                            rgb.r = v;
                            rgb.g = p;
                            rgb.b = q;
                            break;
                    }

                    rgb.r = (rgb.r * 255).toInt();
                    rgb.g = (rgb.g * 255).toInt();
                    rgb.b = (rgb.b * 255).toInt();
                }

                return rgb;
            },
        };

        Core.UI.ColorPicker.Advanced.addMethods({
            initialize(id, settings) {
                this.callSuper(settings.container);
                this.node.tabIndex = 0;

                this.id = id;
                this.settings = Object.extend(
                    Object.extend({}, Core.UI.ColorPicker.Advanced.DefaultColorPickerSettings),
                    settings || {},
                );

                this._build(settings.container);

                // attach radio & check boxes
                // this._hueRadio = $(this.id + '_HueRadio');
                // this._saturationRadio = $(this.id + '_SaturationRadio');
                // this._valueRadio = $(this.id + '_BrightnessRadio');

                // this._redRadio = $(this.id + '_RedRadio');
                // this._greenRadio = $(this.id + '_GreenRadio');
                // this._blueRadio = $(this.id + '_BlueRadio');
                // this._webSafeCheck = $(this.id + '_WebSafeCheck');

                this._hueRadio.value = 'h';
                this._saturationRadio.value = 's';
                this._valueRadio.value = 'v';

                this._redRadio.value = 'r';
                this._greenRadio.value = 'g';
                this._blueRadio.value = 'b';

                // attach events to radio & checks
                this._event_onRadioClicked = this._onRadioClicked.bindAsEventListener(this);

                // this._event_webSafeClicked = this._onWebSafeClicked.bindAsEventListener(this);
                // Event.observe( this._webSafeCheck, 'click', this._event_webSafeClicked);

                // attach simple properties
                // this._preview = $(this.id + '_Preview');

                // MAP
                // this._mapBase = $(this.id + '_ColorMap');
                this._mapBase.style.border = 'solid 1px #000';
                this._mapBase.style.height = '258px';
                this._mapBase.style.margin = 0;
                this._mapBase.style.padding = 0;
                this._mapBase.style.position = 'relative';
                this._mapBase.style.width = '258px';

                this._mapL1 = createElement('img', {
                    src: `${this.settings.clientFilesPath}blank.gif`,
                    width: 256,
                    height: 256,
                }); // 'blank.gif'});
                this._mapL1.style.margin = '0px';
                this._mapBase.appendChild(this._mapL1);

                this._mapL2 = createElement('img', {
                    src: `${this.settings.clientFilesPath}blank.gif`,
                    width: 256,
                    height: 256,
                }); // 'blank.gif'});
                this._mapL2.style.clear = 'both';
                this._mapL2.style.left = '0px';
                this._mapL2.style.position = 'absolute';
                this._mapL2.style.top = '0px';
                this._mapL2.setOpacity(0.5);
                this._mapBase.appendChild(this._mapL2);

                // BAR
                // this._bar = $(this.id + '_ColorBar');
                this._bar.style.border = 'solid 1px #000';
                this._bar.style.height = '258px';
                this._bar.style.margin = '0px 10px';
                this._bar.style.padding = 0;
                this._bar.style.position = 'relative';
                this._bar.style.width = '22px';

                this._barL1 = createElement('img', {
                    src: `${this.settings.clientFilesPath}blank.gif`,
                    width: 20,
                    height: 256,
                });
                this._barL1.style.left = '0px';
                this._barL1.style.margin = '0px';
                this._barL1.style.position = 'absolute';
                this._barL1.style.top = '0px';
                this._bar.appendChild(this._barL1);

                this._barL2 = createElement('img', {
                    src: `${this.settings.clientFilesPath}blank.gif`,
                    width: 20,
                    height: 256,
                });
                this._barL2.style.left = '0px';
                this._barL2.style.position = 'absolute';
                this._barL2.style.top = '0px';
                this._bar.appendChild(this._barL2);

                this._barL3 = createElement('img', {
                    src: `${this.settings.clientFilesPath}blank.gif`,
                    width: 20,
                    height: 256,
                });
                this._barL3.style.backgroundColor = '#ff0000';
                this._barL3.style.left = '0px';
                this._barL3.style.position = 'absolute';
                this._barL3.style.top = '0px';
                this._bar.appendChild(this._barL3);

                this._barL4 = createElement('img', {
                    src: `${this.settings.clientFilesPath}bar-brightness.png`,
                    width: 20,
                    height: 256,
                });
                this._barL4.style.left = '0px';
                this._barL4.style.position = 'absolute';
                this._barL4.style.top = '0px';
                this._bar.appendChild(this._barL4);

                // attach map slider
                this._map = new Core.UI.ColorPicker.Advanced.Slider(this._mapL2, {
                    container: this._mapBase,
                    xMaxValue: 255,
                    yMinValue: 255,
                    arrowImage: `${this.settings.clientFilesPath}mappoint.gif`,
                    disabled: this.node.hasAttribute('disabled'),
                });

                // attach color slider
                this._slider = new Core.UI.ColorPicker.Advanced.Slider(this._barL4, {
                    container: this._bar,
                    xMinValue: 1,
                    xMaxValue: 1,
                    yMinValue: 255,
                    arrowImage: Core.UI.ColorPicker.Advanced.DefaultSliderSettings.arrowImage,
                    disabled: this.node.hasAttribute('disabled'),
                });

                // attach color values
                this._cvp = new Core.UI.ColorPicker.Advanced.ColorValuePicker(this.id, {
                    hueInput: this._hueInput,
                    valueInput: this._valueInput,
                    saturationInput: this._saturationInput,
                    redInput: this._redInput,
                    greenInput: this._greenInput,
                    blueInput: this._blueInput,
                    hexInput: this._hexInput,
                    onChange: this.settings.onChange,
                    disabled: this.node.hasAttribute('disabled'),
                });

                // link up events
                const cp = this;
                this._slider.onValuesChanged = function() {
                    cp.sliderValueChanged();
                };
                this._map.onValuesChanged = function() {
                    cp.mapValueChanged();
                };
                this._cvp.onValuesChanged = function() {
                    cp.textValuesChanged();
                };

                // browser!
                this.isLessThanIE7 = false;
                const version = parseFloat(navigator.appVersion.split('MSIE')[1]);
                if (version < 7 && document.body.filters) this.isLessThanIE7 = true;

                // initialize values
                this.setColorMode(this.settings.startMode);
                this.disabled(this.node.hasAttribute('disabled'));
                if (this.settings.startHex) this._cvp._hexInput.value = this.settings.startHex;
                this._cvp.setValuesFromHex();
                this.positionMapAndSliderArrows();
                this.updateVisuals();

                this.color = null;
                this.created = true;
            },
            dispose() {
                this.disabled(true);

                this._map.dispose();
                this._slider.dispose();
                this._cvp.dispose();

                this.settings.container = null;

                this._mapBase = null;
                this._mapL1 = null;
                this._mapL2 = null;

                this._bar = null;
                this._barL1 = null;
                this._barL2 = null;
                this._barL3 = null;
                this._barL4 = null;

                this._preview = null;
                this._map = null;
                this._slider = null;
                this._cvp = null;

                this._hueRadio = null;
                this._hueInput = null;
                this._saturationRadio = null;
                this._saturationInput = null;
                this._valueRadio = null;
                this._valueInput = null;
                this._redRadio = null;
                this._redInput = null;
                this._greenRadio = null;
                this._greenInput = null;
                this._blueRadio = null;
                this._blueInput = null;
                this._hexInput = null;
            },
            _build(container) {
                let table, tr, td, div;

                table = container.appendChild(createElement('table'));
                tr = table.appendChild(createElement('tr'));

                td = tr.appendChild(createElement('td', { valign: 'top' }));
                this._mapBase = td.appendChild(createElement('div'));

                td = tr.appendChild(createElement('td', { valign: 'top' }));
                this._bar = td.appendChild(createElement('div'));

                td = tr.appendChild(createElement('td', { valign: 'top' }));
                table = td.appendChild(createElement('table'));

                tr = table.appendChild(createElement('tr'));
                td = tr.appendChild(createElement('td', { colspan: '3' }));
                this._previewContainer = td.appendChild(
                    createElement('div', {
                        style:
                            'background-image: url("/core/res/img/backgrounds/transparency.png"); width: 74px; height: 60px; padding: 0; margin: 0 0 10px 0; border: solid 1px #000;',
                    }),
                );
                this._preview = this._previewContainer.appendChild(
                    createElement('div', { style: 'height: 100%; width: 100%;' }),
                );
                this._previewContainer.appendChild(createElement('br'));

                const radios = [
                    { name: 'hue', label: 'H', unit: '&deg;', value: 'h' },
                    { name: 'saturation', label: 'S', unit: '%', value: 's' },
                    { name: 'value', label: 'B', unit: '%', value: 'b' },
                    { name: 'red', label: 'R', unit: '', value: 'r' },
                    { name: 'green', label: 'G', unit: '', value: 'g' },
                    { name: 'blue', label: 'B', unit: '', value: 'b' },
                ];

                // Added "vertical-align:middle" on TDs to fix position for IE8 to be consistent with other browsers
                for (let i = 0, size = radios.length; i < size; i++) {
                    tr = table.appendChild(createElement('tr', { style: radios[i].style }));

                    td = tr.appendChild(createElement('td', { style: 'vertical-align: middle' }));
                    this[`_${radios[i].name}Radio`] = td.appendChild(
                        createElement('input', { name: 'mode', type: 'radio', value: radios[i].value }),
                    );

                    td = tr.appendChild(createElement('td', { style: 'vertical-align: middle' }));
                    td.appendChild(createElement('label').update(`${radios[i].label}:`));

                    td = tr.appendChild(createElement('td', { style: 'vertical-align: middle' }));
                    this[`_${radios[i].name}Input`] = td.appendChild(
                        createElement('input', { style: 'width: 40px;', type: 'text', value: '0' }),
                    );
                }

                tr = table.appendChild(createElement('tr'));
                tr.appendChild(createElement('td').update('#:'));
                td = tr.appendChild(createElement('td', { colspan: '2' }));
                this._hexInput = td.appendChild(createElement('input', { style: 'width: 57px;', type: 'text' }));
            },
            show() {
                this._map._arrow.style.display = '';
                this._slider._arrow.style.display = '';
                this._map.setPositioningVariables();
                this._slider.setPositioningVariables();
                this.positionMapAndSliderArrows();
            },
            hide() {
                this._map._arrow.style.display = 'none';
                this._slider._arrow.style.display = 'none';
            },
            _onRadioClicked(e) {
                this.setColorMode(e.target.value);
            },
            _onWebSafeClicked(e) {
                // reset
                this.setColorMode(this.ColorMode);
            },
            textValuesChanged() {
                this.positionMapAndSliderArrows();
                this.updateVisuals();
            },
            setColorMode(colorMode) {
                this.color = this._cvp.color;

                // reset all images
                function resetImage(cp, img) {
                    cp.setAlpha(img, 100);
                    img.style.backgroundColor = '';
                    img.src = `${cp.settings.clientFilesPath}blank.gif`;
                    img.style.filter = '';
                }
                resetImage(this, this._mapL1);
                resetImage(this, this._mapL2);
                resetImage(this, this._barL1);
                resetImage(this, this._barL2);
                resetImage(this, this._barL3);
                resetImage(this, this._barL4);

                this._hueRadio.checked = false;
                this._saturationRadio.checked = false;
                this._valueRadio.checked = false;
                this._redRadio.checked = false;
                this._greenRadio.checked = false;
                this._blueRadio.checked = false;

                switch (colorMode) {
                    case 'h':
                        this._hueRadio.checked = true;

                        // MAP
                        // put a color layer on the bottom
                        this._mapL1.style.backgroundColor = `#${this.color.hex}`;

                        // add a hue map on the top
                        this._mapL2.style.backgroundColor = 'transparent';
                        this.setImg(this._mapL2, `${this.settings.clientFilesPath}map-hue.png`);
                        this.setAlpha(this._mapL2, 100);

                        // SLIDER
                        // simple hue map
                        this.setImg(this._barL4, `${this.settings.clientFilesPath}bar-hue.png`);

                        this._map.settings.xMaxValue = 100;
                        this._map.settings.yMaxValue = 100;
                        this._slider.settings.yMaxValue = 359;

                        break;

                    case 's':
                        this._saturationRadio.checked = true;

                        // MAP
                        // bottom has saturation map
                        this.setImg(this._mapL1, `${this.settings.clientFilesPath}map-saturation.png`);

                        // top has overlay
                        this.setImg(this._mapL2, `${this.settings.clientFilesPath}map-saturation-overlay.png`);
                        this.setAlpha(this._mapL2, 0);

                        // SLIDER
                        // bottom: color
                        this.setBG(this._barL3, this.color.hex);

                        // top: graduated overlay
                        this.setImg(this._barL4, `${this.settings.clientFilesPath}bar-saturation.png`);

                        this._map.settings.xMaxValue = 359;
                        this._map.settings.yMaxValue = 100;
                        this._slider.settings.yMaxValue = 100;

                        break;

                    case 'v':
                        this._valueRadio.checked = true;

                        // MAP
                        // bottom: nothing

                        // top
                        this.setBG(this._mapL1, '000');
                        this.setImg(this._mapL2, `${this.settings.clientFilesPath}map-brightness.png`);

                        // SLIDER
                        // bottom
                        this._barL3.style.backgroundColor = `#${this.color.hex}`;

                        // top
                        this.setImg(this._barL4, `${this.settings.clientFilesPath}bar-brightness.png`);

                        this._map.settings.xMaxValue = 359;
                        this._map.settings.yMaxValue = 100;
                        this._slider.settings.yMaxValue = 100;
                        break;

                    case 'r':
                        this._redRadio.checked = true;
                        this.setImg(this._mapL2, `${this.settings.clientFilesPath}map-red-max.png`);
                        this.setImg(this._mapL1, `${this.settings.clientFilesPath}map-red-min.png`);

                        this.setImg(this._barL4, `${this.settings.clientFilesPath}bar-red-tl.png`);
                        this.setImg(this._barL3, `${this.settings.clientFilesPath}bar-red-tr.png`);
                        this.setImg(this._barL2, `${this.settings.clientFilesPath}bar-red-br.png`);
                        this.setImg(this._barL1, `${this.settings.clientFilesPath}bar-red-bl.png`);

                        break;

                    case 'g':
                        this._greenRadio.checked = true;
                        this.setImg(this._mapL2, `${this.settings.clientFilesPath}map-green-max.png`);
                        this.setImg(this._mapL1, `${this.settings.clientFilesPath}map-green-min.png`);

                        this.setImg(this._barL4, `${this.settings.clientFilesPath}bar-green-tl.png`);
                        this.setImg(this._barL3, `${this.settings.clientFilesPath}bar-green-tr.png`);
                        this.setImg(this._barL2, `${this.settings.clientFilesPath}bar-green-br.png`);
                        this.setImg(this._barL1, `${this.settings.clientFilesPath}bar-green-bl.png`);

                        break;

                    case 'b':
                        this._blueRadio.checked = true;
                        this.setImg(this._mapL2, `${this.settings.clientFilesPath}map-blue-max.png`);
                        this.setImg(this._mapL1, `${this.settings.clientFilesPath}map-blue-min.png`);

                        this.setImg(this._barL4, `${this.settings.clientFilesPath}bar-blue-tl.png`);
                        this.setImg(this._barL3, `${this.settings.clientFilesPath}bar-blue-tr.png`);
                        this.setImg(this._barL2, `${this.settings.clientFilesPath}bar-blue-br.png`);
                        this.setImg(this._barL1, `${this.settings.clientFilesPath}bar-blue-bl.png`);

                        // this.setImg(this._barL4, this.settings.clientFilesPath + 'bar-hue.png');

                        break;

                    default:
                        alert('invalid mode');
                        break;
                }

                switch (colorMode) {
                    case 'h':
                    case 's':
                    case 'v':
                        this._map.settings.xMinValue = 1;
                        this._map.settings.yMinValue = 1;
                        this._slider.settings.yMinValue = 1;
                        break;

                    case 'r':
                    case 'g':
                    case 'b':
                        this._map.settings.xMinValue = 0;
                        this._map.settings.yMinValue = 0;
                        this._slider.settings.yMinValue = 0;

                        this._map.settings.xMaxValue = 255;
                        this._map.settings.yMaxValue = 255;
                        this._slider.settings.yMaxValue = 255;
                        break;
                }

                this.ColorMode = colorMode;

                this.positionMapAndSliderArrows();

                this.updateMapVisuals();
                this.updateSliderVisuals();
            },
            mapValueChanged() {
                // update values

                switch (this.ColorMode) {
                    case 'h':
                        this._cvp._saturationInput.value = this._map.xValue;
                        this._cvp._valueInput.value = 100 - this._map.yValue;
                        break;

                    case 's':
                        this._cvp._hueInput.value = this._map.xValue;
                        this._cvp._valueInput.value = 100 - this._map.yValue;
                        break;

                    case 'v':
                        this._cvp._hueInput.value = this._map.xValue;
                        this._cvp._saturationInput.value = 100 - this._map.yValue;
                        break;

                    case 'r':
                        this._cvp._blueInput.value = this._map.xValue;
                        this._cvp._greenInput.value = 256 - this._map.yValue;
                        break;

                    case 'g':
                        this._cvp._blueInput.value = this._map.xValue;
                        this._cvp._redInput.value = 256 - this._map.yValue;
                        break;

                    case 'b':
                        this._cvp._redInput.value = this._map.xValue;
                        this._cvp._greenInput.value = 256 - this._map.yValue;
                        break;
                }

                switch (this.ColorMode) {
                    case 'h':
                    case 's':
                    case 'v':
                        this._cvp.setValuesFromHsv();
                        break;

                    case 'r':
                    case 'g':
                    case 'b':
                        this._cvp.setValuesFromRgb();
                        break;
                }

                this.updateVisuals();
            },
            sliderValueChanged() {
                switch (this.ColorMode) {
                    case 'h':
                        this._cvp._hueInput.value = 360 - this._slider.yValue;
                        break;
                    case 's':
                        this._cvp._saturationInput.value = 100 - this._slider.yValue;
                        break;
                    case 'v':
                        this._cvp._valueInput.value = 100 - this._slider.yValue;
                        break;

                    case 'r':
                        this._cvp._redInput.value = 255 - this._slider.yValue;
                        break;
                    case 'g':
                        this._cvp._greenInput.value = 255 - this._slider.yValue;
                        break;
                    case 'b':
                        this._cvp._blueInput.value = 255 - this._slider.yValue;
                        break;
                }

                switch (this.ColorMode) {
                    case 'h':
                    case 's':
                    case 'v':
                        this._cvp.setValuesFromHsv();
                        break;

                    case 'r':
                    case 'g':
                    case 'b':
                        this._cvp.setValuesFromRgb();
                        break;
                }

                this.updateVisuals();
            },
            positionMapAndSliderArrows() {
                this.color = this._cvp.color;

                // Slider
                let sliderValue = 0;
                switch (this.ColorMode) {
                    case 'h':
                        sliderValue = 360 - this.color.h;
                        break;

                    case 's':
                        sliderValue = 100 - this.color.s;
                        break;

                    case 'v':
                        sliderValue = 100 - this.color.v;
                        break;

                    case 'r':
                        sliderValue = 255 - this.color.r;
                        break;

                    case 'g':
                        sliderValue = 255 - this.color.g;
                        break;

                    case 'b':
                        sliderValue = 255 - this.color.b;
                        break;
                }

                this._slider.yValue = sliderValue;
                this._slider.setArrowPositionFromValues();

                // color map
                let mapXValue = 0;
                let mapYValue = 0;
                switch (this.ColorMode) {
                    case 'h':
                        mapXValue = this.color.s;
                        mapYValue = 100 - this.color.v;
                        break;

                    case 's':
                        mapXValue = this.color.h;
                        mapYValue = 100 - this.color.v;
                        break;

                    case 'v':
                        mapXValue = this.color.h;
                        mapYValue = 100 - this.color.s;
                        break;

                    case 'r':
                        mapXValue = this.color.b;
                        mapYValue = 256 - this.color.g;
                        break;

                    case 'g':
                        mapXValue = this.color.b;
                        mapYValue = 256 - this.color.r;
                        break;

                    case 'b':
                        mapXValue = this.color.r;
                        mapYValue = 256 - this.color.g;
                        break;
                }
                this._map.xValue = mapXValue;
                this._map.yValue = mapYValue;
                this._map.setArrowPositionFromValues();
            },
            updateVisuals() {
                this.updatePreview();
                this.updateMapVisuals();
                this.updateSliderVisuals();
            },
            updatePreview(force) {
                try {
                    if (force || this.settings.previewUpdate)
                        this._preview.style.backgroundColor = `#${this._cvp.color.hex}`;
                } catch (e) {}
            },
            updateMapVisuals() {
                this.color = this._cvp.color;

                switch (this.ColorMode) {
                    case 'h':
                        // fake color with only hue
                        var color = new Core.UI.ColorPicker.Advanced.Color({ h: this.color.h, s: 100, v: 100 });
                        this.setBG(this._mapL1, color.hex);
                        break;

                    case 's':
                        this.setAlpha(this._mapL2, 100 - this.color.s);
                        break;

                    case 'v':
                        this.setAlpha(this._mapL2, this.color.v);
                        break;

                    case 'r':
                        this.setAlpha(this._mapL2, this.color.r / 256 * 100);
                        break;

                    case 'g':
                        this.setAlpha(this._mapL2, this.color.g / 256 * 100);
                        break;

                    case 'b':
                        this.setAlpha(this._mapL2, this.color.b / 256 * 100);
                        break;
                }
            },
            updateSliderVisuals() {
                this.color = this._cvp.color;

                switch (this.ColorMode) {
                    case 'h':
                        break;

                    case 's':
                        var saturatedColor = new Core.UI.ColorPicker.Advanced.Color({
                            h: this.color.h,
                            s: 100,
                            v: this.color.v,
                        });
                        this.setBG(this._barL3, saturatedColor.hex);
                        break;

                    case 'v':
                        var valueColor = new Core.UI.ColorPicker.Advanced.Color({
                            h: this.color.h,
                            s: this.color.s,
                            v: 100,
                        });
                        this.setBG(this._barL3, valueColor.hex);
                        break;
                    case 'r':
                    case 'g':
                    case 'b':
                        var hValue = 0;
                        var vValue = 0;

                        if (this.ColorMode == 'r') {
                            hValue = this._cvp._blueInput.value;
                            vValue = this._cvp._greenInput.value;
                        } else if (this.ColorMode == 'g') {
                            hValue = this._cvp._blueInput.value;
                            vValue = this._cvp._redInput.value;
                        } else if (this.ColorMode == 'b') {
                            hValue = this._cvp._redInput.value;
                            vValue = this._cvp._greenInput.value;
                        }

                        var horzPer = hValue / 256 * 100;
                        var vertPer = vValue / 256 * 100;

                        var horzPerRev = (256 - hValue) / 256 * 100;
                        var vertPerRev = (256 - vValue) / 256 * 100;

                        this.setAlpha(this._barL4, vertPer > horzPerRev ? horzPerRev : vertPer);
                        this.setAlpha(this._barL3, vertPer > horzPer ? horzPer : vertPer);
                        this.setAlpha(this._barL2, vertPerRev > horzPer ? horzPer : vertPerRev);
                        this.setAlpha(this._barL1, vertPerRev > horzPerRev ? horzPerRev : vertPerRev);

                        break;
                }
            },
            setBG(el, c) {
                try {
                    el.style.backgroundColor = `#${c}`;
                } catch (e) {}
            },
            setImg(img, src) {
                if (src.indexOf('png') && this.isLessThanIE7) {
                    img.pngSrc = src;
                    img.src = `${this.settings.clientFilesPath}blank.gif`;
                    img.style.filter = `progid:DXImageTransform.Microsoft.AlphaImageLoader(src='${src}');`;
                } else {
                    img.src = src;
                }
            },
            setAlpha(obj, alpha) {
                if (this.isLessThanIE7) {
                    const src = obj.pngSrc;
                    // exception for the hue map
                    if (src != null && src.indexOf('map-hue') == -1)
                        obj.style.filter = `progid:DXImageTransform.Microsoft.AlphaImageLoader(src='${src}') progid:DXImageTransform.Microsoft.Alpha(opacity=${alpha})`;
                } else {
                    obj.setOpacity(alpha / 100);
                }
            },

            setColorValue(hex) {
                hex = hex.replace(/#/, '');
                this._cvp._hexInput.value = hex;
                this._cvp.setValuesFromHex();
                this.positionMapAndSliderArrows();
                this.updateVisuals();
            },
            disabled(disable) {
                const isDisabled = this.node.hasAttribute('disabled');
                if (disable === true && (!this.created || !isDisabled)) {
                    this.node.setAttribute('disabled', 'disabled');
                    this._cvp.disabled(true);
                    this._map.disabled(true);
                    this._slider.disabled(true);
                    Event.stopObserving(this._hueRadio, 'click', this._event_onRadioClicked);
                    Event.stopObserving(this._saturationRadio, 'click', this._event_onRadioClicked);
                    Event.stopObserving(this._valueRadio, 'click', this._event_onRadioClicked);
                    Event.stopObserving(this._redRadio, 'click', this._event_onRadioClicked);
                    Event.stopObserving(this._greenRadio, 'click', this._event_onRadioClicked);
                    Event.stopObserving(this._blueRadio, 'click', this._event_onRadioClicked);
                } else if (disable === false && (!this.created || isDisabled)) {
                    this.node.removeAttribute('disabled');
                    this._cvp.disabled(false);
                    this._map.disabled(false);
                    this._slider.disabled(false);
                    Event.observe(this._hueRadio, 'click', this._event_onRadioClicked);
                    Event.observe(this._saturationRadio, 'click', this._event_onRadioClicked);
                    Event.observe(this._valueRadio, 'click', this._event_onRadioClicked);
                    Event.observe(this._redRadio, 'click', this._event_onRadioClicked);
                    Event.observe(this._greenRadio, 'click', this._event_onRadioClicked);
                    Event.observe(this._blueRadio, 'click', this._event_onRadioClicked);
                } else return isDisabled;
            },
            getColorValue() {
                return `#${this._cvp._hexInput.value}`;
            },
            getPalette() {
                return this._mapBase;
            },
            getPreviewNode() {
                return this._preview;
            },
            updatePosition() {
                this.positionMapAndSliderArrows();
                this.updateVisuals();
            },
        });

        Core.Class('Core.UI.ColorPicker.Advanced.ColorValuePicker', {
            /** @ignore */
            initialize(id, settings) {
                this.id = id;
                this.settings = settings;

                this.onValuesChanged = null;

                this._hueInput = settings.hueInput;
                this._valueInput = settings.valueInput;
                this._saturationInput = settings.saturationInput;

                this._redInput = settings.redInput;
                this._greenInput = settings.greenInput;
                this._blueInput = settings.blueInput;

                this._hexInput = settings.hexInput;

                // assign events

                // events
                this._event_onHsvKeyUp = this._onHsvKeyUp.bindAsEventListener(this);
                this._event_onHsvBlur = this._onHsvBlur.bindAsEventListener(this);
                this._event_onRgbKeyUp = this._onRgbKeyUp.bindAsEventListener(this);
                this._event_onRgbBlur = this._onRgbBlur.bindAsEventListener(this);
                this._event_onHexKeyUp = this._onHexKeyUp.bindAsEventListener(this);

                this.disabled(this.settings.disabled);
                this.color = new Core.UI.ColorPicker.Advanced.Color();

                // get an initial value
                if (this._hexInput.value != '') this.color.setHex(this._hexInput.value);

                // set the others based on initial value
                this._hexInput.value = this.color.hex;

                this._redInput.value = this.color.r;
                this._greenInput.value = this.color.g;
                this._blueInput.value = this.color.b;

                this._hueInput.value = this.color.h;
                this._saturationInput.value = this.color.s;
                this._valueInput.value = this.color.v;

                this.created = true;
            },
            dispose() {
                this.disabled(true);

                this._hueInput = null;
                this._valueInput = null;
                this._saturationInput = null;
                this._redInput = null;
                this._greenInput = null;
                this._blueInput = null;
                this._hexInput = null;
            },
            _onHsvKeyUp(e) {
                if (e.target.value == '') return;
                this.validateHsv(e);
                this.setValuesFromHsv();
                if (this.onValuesChanged) this.onValuesChanged(this);
            },
            _onRgbKeyUp(e) {
                if (e.target.value == '') return;
                this.validateRgb(e);
                this.setValuesFromRgb();
                if (this.onValuesChanged) this.onValuesChanged(this);
            },
            _onHexKeyUp(e) {
                if (e.target.value == '') return;
                this.validateHex(e);
                this.setValuesFromHex();
                if (this.onValuesChanged) this.onValuesChanged(this);
            },
            _onHsvBlur(e) {
                if (e.target.value == '') this.setValuesFromRgb();
            },
            _onRgbBlur(e) {
                if (e.target.value == '') this.setValuesFromHsv();
            },
            HexBlur(e) {
                if (e.target.value == '') this.setValuesFromHsv();
            },
            validateRgb(e) {
                if (!this._keyNeedsValidation(e)) return e;
                this._redInput.value = this._setValueInRange(this._redInput.value, 0, 255);
                this._greenInput.value = this._setValueInRange(this._greenInput.value, 0, 255);
                this._blueInput.value = this._setValueInRange(this._blueInput.value, 0, 255);
            },
            validateHsv(e) {
                if (!this._keyNeedsValidation(e)) return e;
                this._hueInput.value = this._setValueInRange(this._hueInput.value, 0, 359);
                this._saturationInput.value = this._setValueInRange(this._saturationInput.value, 0, 100);
                this._valueInput.value = this._setValueInRange(this._valueInput.value, 0, 100);
            },
            validateHex(e) {
                if (!this._keyNeedsValidation(e)) return e;
                let hex = new String(this._hexInput.value).toUpperCase();
                hex = hex.replace(/[^A-F0-9]/g, '0');
                if (hex.length > 6) hex = hex.substring(0, 6);
                this._hexInput.value = hex;
            },
            _keyNeedsValidation(e) {
                if (
                    e.keyCode == 9 || // TAB
                    e.keyCode == 16 || // Shift
                    e.keyCode == 38 || // Up arrow
                    e.keyCode == 29 || // Right arrow
                    e.keyCode == 40 || // Down arrow
                    e.keyCode == 37 || // Left arrow
                    (e.ctrlKey && (e.keyCode == 'c'.charCodeAt() || e.keyCode == 'v'.charCodeAt()))
                )
                    return false;

                return true;
            },
            _setValueInRange(value, min, max) {
                if (value == '' || isNaN(value)) return min;

                value = value.toInt();
                if (value > max) return max;
                if (value < min) return min;

                return value;
            },
            setValuesFromRgb() {
                this.color.setRgb(this._redInput.value, this._greenInput.value, this._blueInput.value);
                this._hexInput.value = this.color.hex;
                this._hueInput.value = this.color.h;
                this._saturationInput.value = this.color.s;
                this._valueInput.value = this.color.v;

                if (this.settings.onChange)
                    this.settings.onChange({
                        r: this._redInput.value,
                        g: this._greenInput.value,
                        b: this._blueInput.value,
                        h: this.color.h,
                        s: this.color.s,
                        v: this.color.v,
                        hex: this.color.hex,
                    });
            },
            setValuesFromHsv() {
                this.color.setHsv(this._hueInput.value, this._saturationInput.value, this._valueInput.value);
                this._hexInput.value = this.color.hex;
                this._redInput.value = this.color.r;
                this._greenInput.value = this.color.g;
                this._blueInput.value = this.color.b;

                if (this.settings.onChange)
                    this.settings.onChange({
                        r: this.color.r,
                        g: this.color.g,
                        b: this.color.b,
                        h: this._hueInput.value,
                        s: this._saturationInput.value,
                        v: this._valueInput.value,
                        hex: this.color.hex,
                    });
            },
            setValuesFromHex() {
                this.color.setHex(this._hexInput.value);

                this._redInput.value = this.color.r;
                this._greenInput.value = this.color.g;
                this._blueInput.value = this.color.b;

                this._hueInput.value = this.color.h;
                this._saturationInput.value = this.color.s;
                this._valueInput.value = this.color.v;

                if (this.settings.onChange)
                    this.settings.onChange({
                        r: this.color.r,
                        g: this.color.g,
                        b: this.color.b,
                        h: this.color.h,
                        s: this.color.s,
                        v: this.color.v,
                        hex: this._hexInput.value,
                    });
            },

            disabled(disable) {
                if (disable === true && (!this.created || !this.settings.disabled)) {
                    this.settings.disabled = true;
                    Event.stopObserving(this._hueInput, 'keyup', this._event_onHsvKeyUp);
                    Event.stopObserving(this._valueInput, 'keyup', this._event_onHsvKeyUp);
                    Event.stopObserving(this._saturationInput, 'keyup', this._event_onHsvKeyUp);
                    Event.stopObserving(this._hueInput, 'blur', this._event_onHsvBlur);
                    Event.stopObserving(this._valueInput, 'blur', this._event_onHsvBlur);
                    Event.stopObserving(this._saturationInput, 'blur', this._event_onHsvBlur);
                    Event.stopObserving(this._redInput, 'keyup', this._event_onRgbKeyUp);
                    Event.stopObserving(this._greenInput, 'keyup', this._event_onRgbKeyUp);
                    Event.stopObserving(this._blueInput, 'keyup', this._event_onRgbKeyUp);
                    Event.stopObserving(this._redInput, 'blur', this._event_onRgbBlur);
                    Event.stopObserving(this._greenInput, 'blur', this._event_onRgbBlur);
                    Event.stopObserving(this._blueInput, 'blur', this._event_onRgbBlur);
                    Event.stopObserving(this._hexInput, 'keyup', this._event_onHexKeyUp);
                } else if (disable === false && (!this.created || this.settings.disabled)) {
                    this.settings.disabled = false;
                    Event.observe(this._hueInput, 'keyup', this._event_onHsvKeyUp);
                    Event.observe(this._valueInput, 'keyup', this._event_onHsvKeyUp);
                    Event.observe(this._saturationInput, 'keyup', this._event_onHsvKeyUp);
                    Event.observe(this._hueInput, 'blur', this._event_onHsvBlur);
                    Event.observe(this._valueInput, 'blur', this._event_onHsvBlur);
                    Event.observe(this._saturationInput, 'blur', this._event_onHsvBlur);
                    Event.observe(this._redInput, 'keyup', this._event_onRgbKeyUp);
                    Event.observe(this._greenInput, 'keyup', this._event_onRgbKeyUp);
                    Event.observe(this._blueInput, 'keyup', this._event_onRgbKeyUp);
                    Event.observe(this._redInput, 'blur', this._event_onRgbBlur);
                    Event.observe(this._greenInput, 'blur', this._event_onRgbBlur);
                    Event.observe(this._blueInput, 'blur', this._event_onRgbBlur);
                    Event.observe(this._hexInput, 'keyup', this._event_onHexKeyUp);
                } else return this.settings.disabled;
            },
        });

        Core.UI.ColorPicker.Advanced.SlidersList = [];

        Core.Class('Core.UI.ColorPicker.Advanced.Slider', {
            _bar: null,
            _arrow: null,

            /** @ignore */
            initialize(id, settings) {
                this.id = id;
                this.settings = Object.extend(
                    Object.extend({}, Core.UI.ColorPicker.Advanced.DefaultSliderSettings),
                    settings || {},
                );

                this.xValue = 0;
                this.yValue = 0;

                // hook up controls
                this._bar = $(this.id);

                // build controls
                this._arrow = document.createElement('img');
                this._arrow.border = 0;
                this._arrow.src = this.settings.arrowImage;
                this._arrow.margin = 0;
                this._arrow.padding = 0;
                this._arrow.style.position = 'absolute';
                this._arrow.style.top = '0px';
                this._arrow.style.left = '0px';
                this.settings.container.appendChild(this._arrow);

                // attach 'this' to html objects
                const slider = this;

                this.setPositioningVariables();

                this._event_arrowMouseDown = this._arrow_mouseDown.bindAsEventListener(this);
                this._event_barMouseDown = this._bar_mouseDown.bindAsEventListener(this);
                this._event_docMouseMove = this._docMouseMove.bindAsEventListener(this);
                this._event_docMouseUp = this._docMouseUp.bindAsEventListener(this);

                // set initial position
                this.setArrowPositionFromValues();

                // fire events
                if (this.onValuesChanged) this.onValuesChanged(this);

                // final setup
                this.disabled(this.settings.disabled);
                Core.UI.ColorPicker.Advanced.SlidersList.push(this);
                this.created = true;
            },

            dispose() {
                this.disabled(true);

                // Same as _docMouseUp
                Event.stopObserving(document, 'mouseup', this._event_docMouseUp);
                Event.stopObserving(document, 'mousemove', this._event_docMouseMove);

                this._bar = null;
                this._arrow = null;
            },

            setPositioningVariables() {
                // calculate sizes and ranges
                // BAR

                this._parentPadLeft = this.settings.container.parentNode.getStyle('paddingLeft').toInt();
                this._parentPadTop = this.settings.container.parentNode.getStyle('paddingTop').toInt();
                this._parentLeft = (this.settings.container.parentNode.getStyle('left') || 0).toInt();
                this._parentTop = (this.settings.container.parentNode.getStyle('top') || 0).toInt();

                this._barWidth = this._bar.getWidth();
                this._barHeight = this._bar.getHeight();

                const scroll = this._bar.cumulativeScrollOffset();
                const pos = this._bar.cumulativeOffset();
                this._barTop = pos.top - scroll.top;
                this._barLeft = pos.left - scroll.left;

                this._barBottom = this._barTop + this._barHeight;
                this._barRight = this._barLeft + this._barWidth;

                // ARROW
                this._arrow = $(this._arrow);
                this._arrowWidth = this._arrow.getWidth();
                this._arrowHeight = this._arrow.getHeight();

                // MIN & MAX
                this.MinX = this._barLeft;
                this.MinY = this._barTop;

                this.MaxX = this._barRight;
                this.MinY = this._barBottom;
            },

            setArrowPositionFromValues(e) {
                this.setPositioningVariables();

                // sets the arrow position from XValue and YValue properties

                let arrowOffsetX = 0;
                var arrowOffsetY = 0;

                // X Value/Position
                if (this.settings.xMinValue != this.settings.xMaxValue) {
                    if (this.xValue == this.settings.xMinValue) {
                        arrowOffsetX = 0;
                    } else if (this.xValue == this.settings.xMaxValue) {
                        arrowOffsetX = this._barWidth - 1;
                    } else {
                        let xMax = this.settings.xMaxValue;
                        if (this.settings.xMinValue < 1) {
                            xMax = xMax + Math.abs(this.settings.xMinValue) + 1;
                        }
                        let xValue = this.xValue;

                        if (this.xValue < 1) xValue += 1;

                        arrowOffsetX = xValue / xMax * this._barWidth;

                        if (arrowOffsetX.toInt() == xMax - 1) arrowOffsetX = xMax;
                        else arrowOffsetX = arrowOffsetX.toInt();

                        // shift back to normal values
                        if (this.settings.xMinValue < 1) {
                            arrowOffsetX = arrowOffsetX - Math.abs(this.settings.xMinValue) - 1;
                        }
                    }
                }

                // X Value/Position
                if (this.settings.yMinValue != this.settings.yMaxValue) {
                    if (this.yValue == this.settings.yMinValue) {
                        arrowOffsetY = 0;
                    } else if (this.yValue == this.settings.yMaxValue) {
                        arrowOffsetY = this._barHeight - 1;
                    } else {
                        let yMax = this.settings.yMaxValue;
                        if (this.settings.yMinValue < 1) {
                            yMax = yMax + Math.abs(this.settings.yMinValue) + 1;
                        }

                        let yValue = this.yValue;

                        if (this.yValue < 1) yValue += 1;

                        var arrowOffsetY = yValue / yMax * this._barHeight;

                        if (arrowOffsetY.toInt() == yMax - 1) arrowOffsetY = yMax;
                        else arrowOffsetY = arrowOffsetY.toInt();

                        if (this.settings.yMinValue < 1) {
                            arrowOffsetY = arrowOffsetY - Math.abs(this.settings.yMinValue) - 1;
                        }
                    }
                }

                this._setArrowPosition(arrowOffsetX, arrowOffsetY);
            },
            _setArrowPosition(offsetX, offsetY) {
                this.setPositioningVariables();

                // validate
                if (offsetX < 0) offsetX = 0;
                if (offsetX > this._barWidth) offsetX = this._barWidth;
                if (offsetY < 0) offsetY = 0;
                if (offsetY > this._barHeight) offsetY = this._barHeight;

                let posX = offsetX;
                let posY = offsetY;

                // check if the arrow is bigger than the bar area
                if (this._arrowWidth > this._barWidth) {
                    posX -= this._arrowWidth / 2 - this._barWidth / 2;
                } else {
                    posX -= (this._arrowWidth / 2).toInt();
                }
                if (this._arrowHeight > this._barHeight) {
                    posY -= this._arrowHeight / 2 - this._barHeight / 2;
                } else {
                    posY -= (this._arrowHeight / 2).toInt();
                }
                this._arrow.style.left = `${posX + this._parentPadLeft + this._parentLeft}px`;
                this._arrow.style.top = `${posY + this._parentPadTop + this._parentTop}px`;
            },
            _bar_mouseDown(e) {
                this._mouseDown(e);
            },

            _arrow_mouseDown(e) {
                this._mouseDown(e);
            },

            _mouseDown(e) {
                Core.UI.ColorPicker.Advanced.ActiveSlider = this;

                this.setPositioningVariables();
                this.setValuesFromMousePosition(e);

                Event.observe(document, 'mousemove', this._event_docMouseMove);
                Event.observe(document, 'mouseup', this._event_docMouseUp);

                eventStop(e);
            },

            _docMouseMove(e) {
                this.setValuesFromMousePosition(e);

                eventStop(e);
            },

            _docMouseUp(e) {
                Event.stopObserving(document, 'mouseup', this._event_docMouseUp);
                Event.stopObserving(document, 'mousemove', this._event_docMouseMove);
                eventStop(e);
            },

            setValuesFromMousePosition(e) {
                // this.setPositioningVariables();

                const mouse = Event.pointer(e);

                let relativeX = 0;
                let relativeY = 0;

                // mouse relative to object's top left
                if (mouse.x < this._barLeft) relativeX = 0;
                else if (mouse.x > this._barRight) relativeX = this._barWidth;
                else relativeX = mouse.x - this._barLeft + 1;

                if (mouse.y < this._barTop) relativeY = 0;
                else if (mouse.y > this._barBottom) relativeY = this._barHeight;
                else relativeY = mouse.y - this._barTop + 1;

                const newXValue = (relativeX / this._barWidth * this.settings.xMaxValue).toInt();
                const newYValue = (relativeY / this._barHeight * this.settings.yMaxValue).toInt();

                // set values
                this.xValue = newXValue;
                this.yValue = newYValue;

                // position arrow
                if (this.settings.xMaxValue == this.settings.xMinValue) relativeX = 0;
                if (this.settings.yMaxValue == this.settings.yMinValue) relativeY = 0;
                this._setArrowPosition(relativeX, relativeY);

                // fire events
                if (this.onValuesChanged) this.onValuesChanged(this);
            },

            disabled(disable) {
                if (disable === true && (!this.created || !this.settings.disabled)) {
                    this.settings.disabled = true;
                    this._arrow.setOpacity(0.5);
                    Event.stopObserving(this._bar, 'mousedown', this._event_barMouseDown);
                    Event.stopObserving(this._arrow, 'mousedown', this._event_arrowMouseDown);
                } else if (disable === false && (!this.created || this.settings.disabled)) {
                    this.settings.disabled = false;
                    this._arrow.setOpacity(1);
                    Event.observe(this._bar, 'mousedown', this._event_barMouseDown);
                    Event.observe(this._arrow, 'mousedown', this._event_arrowMouseDown);
                } else return this.settings.disabled;
            },
        });
    },
); // $file
