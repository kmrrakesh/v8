/* eslint-disable camelcase */
/* eslint-disable no-continue */
/* eslint-disable no-plusplus */
/* eslint-disable no-param-reassign */
/* eslint-disable prefer-destructuring */
/* eslint-disable require-jsdoc */
// @ts-check
import { TcfDate } from '/node_modules/@trapezegroup/core-js-tcftypes/src/lib/types.js';
import { locale } from '/node_modules/@trapezegroup/core-js-tcftypes/src/lib/locale.js';
import {
    getIsoYear,
    getIsoMonth,
    isoMonthToMonth,
    isoDateToDate,
    getIsoDay,
    isoDayToDay,
    getYear,
    isLeapYear,
} from '/node_modules/@trapezegroup/core-js-extensions/src/lib/date.js';
import {
    createElement,
    getProperty,
    setProperty,
} from '/node_modules/@trapezegroup/core-js-extensions/src/lib/element.js';
import { clone } from '/node_modules/@trapezegroup/core-js-extensions/src/lib/json.js';
import { getStyle } from '/node_modules/@trapezegroup/core-js-extensions/src/lib/styles.js';
import { eventStop, EventKeys } from '/node_modules/@trapezegroup/core-js-extensions/src/lib/event.js';
import { CoreInputDropBase } from './core-input-drop-base.js';

const PREVIOUS_YEAR = '&#xAB;';
const PREVIOUS_MONTH = '&#x8B;';
const NEXT_MONTH = '&#x9B;';
const NEXT_YEAR = '&#xBB;';
const TODAY = 'today';
const CLEAR = '&#xD7;';

export class CoreInputCalendar extends CoreInputDropBase {
    static DIALOG_CLASS_NAMES = { drop: 'caldroppane dlgpane', pane: 'caldlg' };
    static DIALOG_CAN_OVERLAP_WIDGET = true;
    static TAG_NAME_LIST_ITEM = '.CalendarDay';
    static DEFAULT_DATATYPE = TcfDate;
    static ALLOWED_DATATYPES = [TcfDate];
    static DEFAULT_EMPTY_DISPLAY_VALUE = '';
    static SHOW_DIALOG_ON_INPUT_FOCUS = true;
    static CLOSE_DIALOG_ONSELECTION = function CLOSE_DIALOG_ONSELECTION() {
        return this.selectionMode !== 1;
    };

    DIALOG_KEY_MAPPING = (function DIALOG_KEY_MAPPING() {
        const mapping = clone(CoreInputDropBase.DIALOG_KEY_MAPPING);
        mapping[EventKeys.KEY_END] = '';
        mapping[EventKeys.KEY_HOME] = '';
        mapping[EventKeys.KEY_LEFT] = 'selectPreviousItem';
        mapping[EventKeys.KEY_RIGHT] = 'selectNextItem';
        mapping[EventKeys.KEY_UP] = 'selectPreviousRow';
        mapping[EventKeys.KEY_DOWN] = 'selectNextRow';
        return mapping;
    })();

    connectedCallback() {
        // Just adding localDateFormat
        this.localFormatDate = this.getLocaleValue('localeFormatDate');
        this.localDateFormat = this.localFormatDate
            ? locale.getFormatSpec(this.localFormatDate, 'date')
            : this.getLocaleValue('localeDateFormat');
        this.localDatePattern = this.localFormatDate
            ? locale.getParseSpec(this.localFormatDate, 'date')
            : this.getLocaleValue('localeDatePattern');

        const value = getProperty(this, 'value', '');
        // Convert format = 8 to system raw format
        if (value.indexOf('-') > -1) {
            const dt = new TcfDate(undefined, this);
            const localeKey = dt._localeKey;
            dt._localeKey = 8;
            dt.fromString(value);
            dt._localeKey = localeKey;
            this.setNodeValue(dt.getValue());
        }
    }

    constructor() {
        super();

        this.fromDate = 0;
        this.toDate = 0;
        this.dialogGenerated = false;
        this.monthbar = null;
        this.dowbar = null;
        this.caldata = null;
        this.buttons = [];
        this.selectionMode = 0;
        this.size = 0;
    }

    // getDataType()
    // {
    //	this.dataType.fromString(this.getInputElement().getProperty("key"));
    //	return this.dataType;
    // }

    setDataType(calendarDataType) {
        super.setDataType(calendarDataType);
        const input = this.getInputElement();
        if (input instanceof HTMLInputElement) input.value = '';

        const displayValue = this.getDisplayValue();
        this.setNodeValue(this.dataType.getValue());
        if (displayValue !== null) this.setDisplayValue(displayValue);
    }

    getData() {
        return null;
    }

    _getInitialItem() {
        return null;
    }
    _getInitialValue(initialItem) {
        const value = getProperty(this, 'value', '') || '';
        const dt = new TcfDate(undefined, this);
        dt.setValue(value.toInt());
        return dt.getValue();
    }

    setNodeValue(value) {
        super.setNodeValue(value == null ? '' : value);
    }

    setData() {}

    initProperties() {
        setProperty(this, 'fromDate', -1);
        setProperty(this, 'toDate', -1);
        super.initProperties();
    }

    _eventState(on) {
        super._eventState(on);

        if (on) {
            this.observe('dblclick');
            if (this.dialog) this.observe('mousewheel', this.dialog);
        } else {
            this.stopObserving('dblclick');
            if (this.dialog) this.stopObserving('mousewheel', this.dialog);
        }
    }

    replaceDialogContent(listItems, aValue) {}

    initDialog(event, aValue) {
        super.initDialog(event, aValue);

        // @ts-ignore
        this.dialog.internalSetWidgetFocus = this.internalSetWidgetFocus.bind(this);

        if (this.isDrop && this.classList.contains('Invert')) this.dialog.classList.add('Invert');
    }

    generateDialogContent(event) {
        this.dialog.innerHTML = '';
        this.dialog.appendChild(this._createDialogContent());

        const dialogChildren = this.dialog.children;

        this.monthbar = dialogChildren[0];
        this.dowbar = dialogChildren[1];
        this.caldata = dialogChildren[2];
        this.dowbar.innerHTML = '';
        this.dowbar.appendChild(this.createDowbarContent());
        this.caldata.innerHTML = '';
        this.caldata.appendChild(this.createCaldataContent());

        const navbar = dialogChildren[3];
        const navChildren = navbar.children;

        this.buttons[PREVIOUS_YEAR] = navChildren[0];
        this.buttons[PREVIOUS_MONTH] = navChildren[1];
        this.buttons[TODAY] = navChildren[2];
        this.buttons[NEXT_MONTH] = navChildren[3];
        this.buttons[NEXT_YEAR] = navChildren[4];

        this.observe('click', this.buttons[PREVIOUS_YEAR], 'selectPreviousYear');
        this.observe('click', this.buttons[PREVIOUS_MONTH], 'selectPreviousMonth');
        this.observe('click', this.buttons[TODAY], 'selectToday');
        this.observe('click', this.buttons[NEXT_MONTH], 'selectNextMonth');
        this.observe('click', this.buttons[NEXT_YEAR], 'selectNextYear');

        const options = this.getOptions();

        for (let ix = 0; ix < options.length; ix++) {
            options[ix].unselectable = true;
            options[ix].setAttribute('tabindex', -1);
        }

        // this.internalSetItemFocus();
        this.dialogGenerated = true;
    }

    _createDialogContent() {
        const divCalNavBar = createElement('div', { className: 'calnavbar' });
        divCalNavBar.appendChild(
            createElement('button', { className: 'vcr TextButton', tabindex: '-1', type: 'button' }, PREVIOUS_YEAR),
        );
        divCalNavBar.appendChild(
            createElement('button', { className: 'vcr TextButton', tabindex: '-1', type: 'button' }, PREVIOUS_MONTH),
        );
        divCalNavBar.appendChild(
            createElement(
                'button',
                { className: 'vcrmiddle TextButton', tabindex: '-1', type: 'button' },
                this.getLocaleValue('localeToday'),
            ),
        );
        divCalNavBar.appendChild(
            createElement('button', { className: 'vcr TextButton', tabindex: '-1', type: 'button' }, NEXT_MONTH),
        );
        divCalNavBar.appendChild(
            createElement('button', { className: 'vcr TextButton', tabindex: '-1', type: 'button' }, NEXT_YEAR),
        );

        const container = document.createDocumentFragment();
        const monthBar = createElement('div', { className: 'monthbar' });
        monthBar.appendChild(createElement('span', { className: 'CalMonth' }));
        monthBar.appendChild(createElement('span', { className: 'CalYear' }));

        if (!this.isRequired()) monthBar.appendChild(createElement('span', { className: 'CalClear' }, CLEAR));

        container.appendChild(monthBar);
        container.appendChild(createElement('div', { className: 'dowbar' }));
        container.appendChild(createElement('div', { className: 'caldata' }));
        container.appendChild(divCalNavBar);

        return container;
    }

    update(value, event) {
        if (value === undefined) value = new TcfDate(this.getSelectedValue().toInt()).toString();
        return super.update(value, event);
    }

    passUserInputToDialog() {
        return this.getInputElement() !== document.activeElement;
    }

    createDowbarContent() {
        let dow = this.getLocaleArray('localefirstdow');
        const content = document.createDocumentFragment();
        const localeWeekdaysShort = this.getLocaleArray('localeWeekdaysShort');
        for (let colix = 0; colix < 7; colix++) {
            content.appendChild(createElement('div', localeWeekdaysShort[dow]));
            dow++;
            if (dow === 7) dow = 0;
        }

        return content;
    }

    createCaldataContent() {
        const rowContent = createElement('div', { className: 'weekrow' });
        for (let i = 0; i < 7; i++) rowContent.appendChild(createElement('div', { tabindex: -1 }));

        const content = document.createDocumentFragment();
        for (let i = 0; i < 5; i++) content.appendChild(rowContent.cloneNode(true));
        content.appendChild(rowContent);

        return content;
    }

    getOptionValue(option) {
        if (!option) return '';
        const optionValue = option.getProperty('value');
        option.value = optionValue;
        return option.value;
    }

    getItemFromValue(aValue) {
        const ix = this.getListIndex(aValue);
        const options = this.getOptions();
        const option = ix > -1 ? options[ix] : null;
        return option;
    }

    getCell(colix, rowix) {
        const rows = this.getRows();
        const row = rows ? rows[rowix] : null;
        const cells = row ? row.children : null;
        return cells ? cells[colix] : null;
    }

    getCurrentIsoDate() {
        let isoDate = this.getOptionValue(this.getSelectedItem());
        if (!isoDate) {
            if (this.isoMonth && this.isoYear) isoDate = `${this.isoYear + this.isoMonth}01`;
        }
        return isoDate;
    }

    loadMonth(isoMonth, isoYear) {
        if (this.isoMonth === isoMonth && this.isoYear === isoYear) return;

        if (!isoMonth || !isoYear) {
            const today = TcfDate.getTodayValue().toString();
            isoYear = getIsoYear(today);
            isoMonth = getIsoMonth(today);
        }

        const monthStr = this.getLocaleArray('localeMonthsLong')[isoMonthToMonth(isoMonth)];
        const monthElem = this.monthbar.firstChild;
        if (monthElem.firstChild) monthElem.firstChild.nodeValue = monthStr;
        else monthElem.appendChild(document.createTextNode(monthStr));

        const yearElem = this.monthbar.firstChild.nextSibling;
        if (yearElem.firstChild) yearElem.firstChild.nodeValue = isoYear;
        else yearElem.appendChild(document.createTextNode(isoYear));

        this.isoMonth = isoMonth;
        this.isoYear = isoYear;
        const daysInMonth = this.getDaysInMonth(isoMonth, isoYear);

        const firstDayDow = isoDateToDate(`${isoYear}${isoMonth}01`).getDay();

        const rows = this.getRows();
        const rowCount = rows.length;
        const colCount = rows[0].children.length;
        let colix = firstDayDow - this.getLocaleValue('localeFirstDOW');

        if (colix < 0) colix += 7;

        let rowix = 0;

        const className = CoreInputCalendar.TAG_NAME_LIST_ITEM.substr(1);
        for (let ix = 0; ix < colix; ix++) {
            const cell = this.getCell(ix, 0);

            if (cell) {
                cell.innerHTML = '&nbsp;';
                cell.classList.remove(className);
                cell.classList.remove(CoreInputCalendar.CSSCLASS_SELECTED);
                // @ts-ignore
                cell.value = null;
            }
        }

        const yearYonth = this.isoYear + this.isoMonth;
        const fromDate = this.fromDate;
        const toDate = this.toDate;
        for (let day = 1; day <= daysInMonth; day++) {
            const cell = this.getCell(colix, rowix);

            if (cell) {
                cell.innerHTML = `${day}`;
                cell.classList.add(className);
                const value = yearYonth + day.toString().padStart(2, '0');
                // @ts-ignore
                cell.value = value;

                if (value in this._selectionValues) cell.classList.add(CoreInputCalendar.CSSCLASS_SELECTED);
                else cell.classList.remove(CoreInputCalendar.CSSCLASS_SELECTED);

                const visible =
                    (fromDate === -1 || parseInt(value, 10) >= fromDate) &&
                    (toDate === -1 || parseInt(value, 10) <= toDate);
                cell instanceof HTMLElement && (cell.style.visibility = visible ? 'visible' : 'hidden');
            }

            colix++;

            if (colix < colCount) continue;

            colix = 0;
            rowix++;
        }

        while (rowix < rowCount) {
            while (colix < colCount) {
                const cell = this.getCell(colix, rowix);

                if (cell) {
                    cell.innerHTML = '&nbsp;';
                    cell.classList.remove(className);
                    cell.classList.remove(CoreInputCalendar.CSSCLASS_SELECTED);
                    // @ts-ignore
                    cell.value = null;
                }
                colix++;
            }
            colix = 0;
            rowix++;
        }
    }

    getDaysInMonth(isoMonth, isoYear) {
        const month = Number(isoMonth);
        const year = Number(isoYear);
        let days = 0;

        switch (month.valueOf()) {
            case 1:
            case 3:
            case 5:
            case 7:
            case 8:
            case 10:
            case 12:
                days = 31;
                break;
            case 4:
            case 6:
            case 9:
            case 11:
                days = 30;
                break;
            case 2:
                days = isLeapYear(year) ? 29 : 28;
                break;
            default:
        }

        return days;
    }

    adjustWidth() {
        this.dialog.style.width = '165px';
    }

    /** @returns  */
    getRows() {
        // let list = this.listpane ? this.listpane : this;
        return this.caldata.children;
    }

    sanitaizeDate(isoDate) {
        let isoMonth = getIsoMonth(isoDate);
        let isoYear;
        if (parseInt(isoMonth, 10) > 12) {
            isoMonth = '01';
            isoYear = this.getNextIsoYear(isoDate);
        } else if (parseInt(isoMonth, 10) < 1) {
            isoMonth = '12';
            isoYear = this.getPreviousIsoYear(isoDate);
        } else isoYear = getIsoYear(isoDate);

        let isoDay = parseInt(getIsoDay(isoDate), 10);
        const maxDay = this.getDaysInMonth(isoMonth, isoYear);
        if (isoDayToDay(isoDay.toString()) > maxDay) isoDay = maxDay;

        let sanitized = parseInt(isoYear + isoMonth + isoDay, 10);

        if (this.fromDate > -1 && sanitized < this.fromDate) sanitized = this.fromDate;

        if (this.toDate > -1 && sanitized > this.toDate) sanitized = this.toDate;

        return sanitized;
    }

    selectItemFromValue(event, value, update) {
        let item = this.getItemFromValue(value);
        if (!item) {
            value = this.sanitaizeDate(value);
            this.loadMonth(getIsoMonth(value), getIsoYear(value));
            item = this.getItemFromValue(value);
            if (this.selectionMode === 1) return undefined;
        }
        if (update || item !== this.getSelectedItem()) this.selectItem(event, item, this.isDrop, update);
        if (item && this && getStyle(this, 'display') !== 'none' && getStyle(this.dialog, 'display') !== 'none')
            item.focus();
        return item;
    }

    selectPreviousItem(event) {
        const selectedItem = this.getSelectedItem();

        if (!selectedItem) this.selectItem(event, this.getOptions()[0]);
        else if (selectedItem.previousSibling && this.getOptionValue(selectedItem.previousSibling))
            this.selectItem(event, selectedItem.previousSibling);
        else if (
            selectedItem.parentNode.previousSibling &&
            selectedItem.parentNode.previousSibling.lastChild &&
            this.getOptionValue(selectedItem.parentNode.previousSibling.lastChild)
        )
            this.selectItem(event, selectedItem.parentNode.previousSibling.lastChild);
        else {
            this.selectPreviousMonth(event);
            const options = this.getOptions();

            for (let ix = options.length - 1; ix > -1; ix--) {
                const option = options[ix];

                if (!option.childElementCount && this.getOptionValue(option)) {
                    this.selectItem(event, option);
                    break;
                }
            }
        }
        return undefined;
    }

    selectNextItem(event) {
        const selectedItem = this.getSelectedItem();

        if (!selectedItem) this.selectItem(event, this.getOptions()[0]);
        else if (selectedItem.nextSibling && this.getOptionValue(selectedItem.nextSibling))
            this.selectItem(event, selectedItem.nextSibling);
        else if (
            selectedItem.parentNode.nextSibling &&
            selectedItem.parentNode.nextSibling.firstChild &&
            this.getOptionValue(selectedItem.parentNode.nextSibling.firstChild)
        )
            this.selectItem(event, selectedItem.parentNode.nextSibling.firstChild);
        else {
            this.selectNextMonth(event);
            const options = this.getOptions();

            for (let ix = 0; ix < options.length; ix++) {
                const option = options[ix];
                if (!option.childElementCount && this.getOptionValue(option)) {
                    this.selectItem(event, option);
                    break;
                }
            }
        }
        return undefined;
    }

    getColIndex(item) {
        let ix = -1;
        for (; item; item = item.previousSibling) ix++;
        return ix;
    }

    selectPreviousRow(event) {
        let selectedItem = this.getSelectedItem();
        const selectedRow = selectedItem ? selectedItem.parentNode : null;
        let previousRow = selectedRow ? selectedRow.previousSibling : null;

        if (previousRow) {
            selectedItem = previousRow.children[this.getColIndex(selectedItem)];

            if (selectedItem && this.getOptionValue(selectedItem)) {
                this.selectItem(event, selectedItem);
                return;
            }
        }

        const colIndex = this.getColIndex(selectedItem);
        this.selectPreviousMonth(event);
        const rows = this.getRows();
        previousRow = rows[rows.length - 1];

        for (
            selectedItem = null;
            previousRow && (!selectedItem || !this.getOptionValue(selectedItem));
            previousRow = previousRow.previousSibling
        )
            selectedItem = previousRow.children[colIndex];

        if (selectedItem && this.getOptionValue(selectedItem)) this.selectItem(event, selectedItem);
    }

    selectNextRow(event) {
        let selectedItem = this.getSelectedItem();
        const selectedRow = selectedItem ? selectedItem.parentNode : null;
        let nextRow = selectedRow ? selectedRow.nextSibling : null;

        if (nextRow) {
            selectedItem = nextRow.children[this.getColIndex(selectedItem)];

            if (selectedItem && this.getOptionValue(selectedItem)) {
                this.selectItem(event, selectedItem);
                return;
            }
        }

        const colIndex = this.getColIndex(selectedItem);
        this.selectNextMonth(event);
        nextRow = this.getRows()[0];

        for (
            selectedItem = null;
            nextRow && (!selectedItem || !this.getOptionValue(selectedItem));
            nextRow = nextRow.nextSibling
        )
            selectedItem = nextRow.children[colIndex];

        if (selectedItem && this.getOptionValue(selectedItem)) this.selectItem(event, selectedItem);
    }

    getPreviousIsoYear(isoDate) {
        let year = getYear(isoDate);
        year--;

        if (year < 1) return null;

        return year.toString().padStart(4, '0');
    }

    getNextIsoYear(isoDate) {
        let year = getYear(isoDate);
        year++;

        if (year > 9999) return null;

        return year.toString().padStart(4, '0');
    }

    selectPreviousYear(event) {
        let isoDate = this.getCurrentIsoDate();

        if (isoDate && isoDate.length) {
            isoDate =
                (Number(getIsoYear(isoDate)) - 1).toString().padStart(4, '0') +
                getIsoMonth(isoDate) +
                getIsoDay(isoDate);
            if (this.getSelectedItem()) this.selectItemFromValue(event, isoDate);
            else {
                isoDate = this.sanitaizeDate(isoDate);
                this.loadMonth(getIsoMonth(isoDate), getIsoYear(isoDate));
            }
        }
    }

    selectPreviousMonth(event) {
        let isoDate = this.getCurrentIsoDate();

        if (isoDate && isoDate.length) {
            isoDate =
                getIsoYear(isoDate) +
                (Number(getIsoMonth(isoDate)) - 1).toString().padStart(2, '0') +
                getIsoDay(isoDate);
            if (this.getSelectedItem()) this.selectItemFromValue(event, isoDate);
            else {
                isoDate = this.sanitaizeDate(isoDate);
                this.loadMonth(getIsoMonth(isoDate), getIsoYear(isoDate));
            }
            if (this) this.relayDay = getIsoDay(isoDate);
        }
        return undefined;
    }

    selectPreviousPageItem(event) {
        return this.selectPreviousMonth(event);
    }

    selectToday(event) {
        this.selectItemFromValue(event, TcfDate.getTodayValue());
        this.updateValue(event);
        this.hidePopup(event);
    }

    selectNextMonth(event) {
        let isoDate = this.getCurrentIsoDate();

        if (isoDate && isoDate.length) {
            isoDate =
                getIsoYear(isoDate) +
                (Number(getIsoMonth(isoDate)) + 1).toString().padStart(2, '0') +
                getIsoDay(isoDate);
            if (this.getSelectedItem()) this.selectItemFromValue(event, isoDate);
            else {
                isoDate = this.sanitaizeDate(isoDate);
                this.loadMonth(getIsoMonth(isoDate), getIsoYear(isoDate));
            }
            if (this) this.relayDay = getIsoDay(isoDate);
        }
        return undefined;
    }

    selectNextPageItem(event) {
        return this.selectNextMonth(event);
    }

    selectNextYear(event) {
        let isoDate = this.getCurrentIsoDate();

        if (isoDate && isoDate.length) {
            isoDate =
                (Number(getIsoYear(isoDate)) + 1).toString().padStart(4, '0') +
                getIsoMonth(isoDate) +
                getIsoDay(isoDate);
            if (this.getSelectedItem()) this.selectItemFromValue(event, isoDate);
            else {
                isoDate = this.sanitaizeDate(isoDate);
                this.loadMonth(getIsoMonth(isoDate), getIsoYear(isoDate));
            }
        }
    }

    setDisplayValue(displayValue) {
        if (this.selectionMode === 1) {
            const values = Object.keys(this._selectionValues).sort();
            for (let i = 0, iLen = values.length; i < iLen; i++) values[i] = this.getDisplayValue(+values[i]);
            super.setDisplayValue(values.join(','));
        } else super.setDisplayValue(displayValue);
        return undefined;
    }

    on_dblclick(event) {
        const source = event.target;

        if (source.tagName === 'BUTTON') return;

        if (this.isSelectable(source)) {
            this.selectItem(event, source);
            this.updateValue(event);
        }

        if (this.isDrop) {
            this.dialog.style.display = 'none';

            if (this.textInput) {
                this.textInput.focus();

                if (this.textInput instanceof HTMLInputElement)
                    // TODO We overide select in common.js to select element not user selection. Review this code.
                    this.textInput.select();
            }
        }
    }

    on_mouseup(event) {
        const srcElem = event.target;

        if (srcElem.hasClassName('CalClear')) {
            this.removeSelection();
            this.removeLastSelected();
            this.updateValue(event);
            this.hidePopup(event);
            return;
        }

        const item = this.getOption(srcElem);
        if (item) {
            super.on_mouseup(event);
            if (this.isDrop && this.selectionMode === 1) this.setDisplayValue();
        }
    }

    isSelectable(option) {
        if (!option || !this.getOptionValue(option)) return false;
        // if(!Element.descendantOf(option, this))
        // return false;
        return option.parentNode.classList.contains('weekrow');
    }

    on_mousewheel(event) {
        const elem = event.target;
        const dir = event.getWheelDelta() > 0;
        if (elem.hasClassName('CalMonth')) {
            dir ? this.selectNextMonth(event) : this.selectPreviousMonth(event);
            eventStop(event);
        } else if (elem.hasClassName('CalYear')) {
            dir ? this.selectNextYear(event) : this.selectPreviousYear(event);
            eventStop(event);
        } else if (elem.descendantOf(this.caldata) || elem.descendantOf(this.dowbar)) {
            dir ? this.selectNextItem(event) : this.selectPreviousItem(event);
            eventStop(event);
        }
    }

    setDate(event, date) {
        this.update(date, event);
    }

    stripDashes(aValue) {
        if (aValue && aValue !== '' && aValue.split) return aValue.split('-').join('');
        return aValue;
    }

    // //////////////////////////////////
    // Drop dialog functionality
    // //////////////////////////////////

    initInputNode() {
        const input = createElement('INPUT', { autocomplete: 'off', type: 'text', value: this.getDisplayValue() });
        if (this.isRequired()) input.setAttribute('required', 'true');

        // set events on new elements
        this.observe('mousewheel', input);
        this.textInput = this.appendChild(input);
        return this.textInput;
    }

    dropInit(initialValue, initialText) {
        let keyValue = this.stripDashes(initialValue);
        const accessKey = this.accessKey;
        if (keyValue && keyValue.isBad) keyValue = '';
        if (!keyValue) keyValue = '';

        super.dropInit(initialValue, initialText);
        this.selectItemFromValue(null, initialValue);

        const input = this.textInput;

        // set properties on new elements
        // @ts-ignore
        input.key = keyValue;

        // other conditional setup
        if (this.size) input.setAttribute('size', this.size.toString());
        if (accessKey) {
            this.accessKey = null;
            input.setAttribute('accessKey', accessKey);
        }
    }

    nondropInit(initialValue, initialText) {
        if (this.innerHTML) this.innerHTML = '';
        this.appendChild(this.dialog);
        this.dataType.setValue(initialValue);
        this.selectItemFromValue(null, initialValue);
    }

    scrollIntoView() {}

    dispose() {
        if (this.dialogGenerated) {
            this.buttons[PREVIOUS_YEAR] = null;
            this.buttons[PREVIOUS_MONTH] = null;
            this.buttons[TODAY] = null;
            this.buttons[NEXT_MONTH] = null;
            this.buttons[NEXT_YEAR] = null;

            // @ts-ignore
            this.dialog.internalSetWidgetFocus = null;
            // @ts-ignore
            this.dialog.notifyChange = null;
            // @ts-ignore
            this.dialog.notifyChanged = null;
            this.monthbar = null;
            this.dowbar = null;
            this.caldata = null;

            this.putValue = null;
            this.getValue = null;
        }

        this.formatValue = null;
        this.setDate = null;
        this.focus = null;
        this.putValue = null;
        this.getValue = null;

        super.dispose();
    }
}

customElements.define('core-input-calendar', CoreInputCalendar);
