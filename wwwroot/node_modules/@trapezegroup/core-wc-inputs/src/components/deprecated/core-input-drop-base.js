/* eslint-disable no-multi-assign */
/* eslint-disable no-fallthrough */
/* eslint-disable camelcase */
/* eslint-disable no-plusplus */
/* eslint-disable no-nested-ternary */
/* eslint-disable no-return-assign */
/* eslint-disable default-case */
/* eslint-disable func-names */
/* eslint-disable guard-for-in */
/* eslint-disable no-restricted-syntax */
/* eslint-disable no-param-reassign */
/* eslint-disable prefer-destructuring */
/* eslint-disable require-jsdoc */
// @ts-check
import { EventKeys, eventStop } from '/node_modules/@trapezegroup/core-js-extensions/src/lib/event.js';
import { Rowset } from '/node_modules/@trapezegroup/core-js-tcftypes/src/lib/rowset.js';
import { TcfString, stringComparator } from '/node_modules/@trapezegroup/core-js-tcftypes/src/lib/types.js';
import { BrowserPlatform } from '/node_modules/@trapezegroup/core-js-browser/src/lib/browserPlatform.js';
import { toDisplayValue } from '/node_modules/@trapezegroup/core-wc-tcffields/src/lib/fields.js';
import {
    setProperty,
    getProperty,
    getAncestorProperty,
    hasProperty,
    isDisplayed,
} from '/node_modules/@trapezegroup/core-js-extensions/src/lib/element.js';
import { getStyle, setStyle } from '/node_modules/@trapezegroup/core-js-extensions/src/lib/styles.js';
import { AOP } from '/node_modules/@trapezegroup/core-js-aop/src/lib/aop.js';
import { clone } from '/node_modules/@trapezegroup/core-js-extensions/src/lib/json.js';

import { CoreInputBase } from './core-input-base.js';
import { EditorAdvice } from './core-inline-editor.js';
import { KeyBuffer } from '../core-wc-inputs/src/lib/keyBuffer.js';

/**
 * @typedef {HTMLElement} DropButton
 * @property {HTMLElement} auxButton
 * @property {HTMLElement} widget
 * @property {boolean} isFixedSize

 */

export class CoreInputDropBase extends CoreInputBase {
    static CSSCLASS_NODE = 'CoreInput';
    static CSSCLASS_SELECTED = 'Selected';
    static CSSCLASS_LASTSELECTED = 'Last';
    static DEFAULT_ISDROP = false;
    static DEFAULT_PLACE_BUTTON_OVER_INPUT = false;
    static DEFAULT_MULTISELECTION = false;
    static TAG_NAME_LIST_ITEM = 'DIV';
    static DIALOG_CLASS_NAMES = { drop: '', pane: '' };
    static DIALOG_SELECTABLE = false;
    static DIALOG_CAN_OVERLAP_WIDGET = false;
    static DEFAULT_DATATYPE = TcfString;
    static DEFAULT_EMPTY_DISPLAY_VALUE = '&nbsp;';
    static DEFAULT_INITIAL_VALUE = '';
    static SHOW_DIALOG_ON_INPUT_FOCUS = false;
    static ENABLE_KEYBUFFER = false;
    static CREATE_INPUT_FOR_NON_DROP = false;
    /** @type {boolean|function} */
    static CLOSE_DIALOG_ONSELECTION = true; // Boolean | Function
    static KEEP_FOCUS_ON_INPUT = false;
    static RETURN_CANCEL_BUBBLING_ON_INPUT = true;
    static MIN_MOUSE_MOVE_TO_CLOSE_DIALOG = 10;
    static DIALOG_KEY_MAPPING = (function() {
        const mapping = {};
        mapping[EventKeys.KEY_PAGEUP] = 'selectPreviousPageItem';
        mapping[EventKeys.KEY_PAGEDOWN] = 'selectNextPageItem';
        mapping[EventKeys.KEY_END] = 'selectLastItem';
        mapping[EventKeys.KEY_HOME] = 'selectFirstItem';
        mapping[EventKeys.KEY_UP] = 'selectPreviousItem';
        mapping[EventKeys.KEY_DOWN] = 'selectNextItem';
        return mapping;
    })();

    static CONTROLLER_ADVICE_KEYDOWN = function(event) {
        const element = event.element();
        const widget = element.getAncBehavior(CoreInputDropBase);
        if ((widget && event.altKey) || element.ancestor('.DropDownDialog')) return EditorAdvice.STOP_PROPAGATION;
        return EditorAdvice.CONTINUE;
    };

    static removeLastSelectionCallback = function(item) {
        item.removeClassName(CoreInputDropBase.CSSCLASS_LASTSELECTED);
        item.tabIndex = -1;
    };

    get size() {
        return parseInt(this.getAttribute('size'), 10);
    }

    get cascadesFrom() {
        return this.getAttribute('cascadesFrom');
    }

    attributeChangedCallback(name, oldValue, newValue) {
        if (newValue && newValue !== oldValue) {
            switch (name) {
                case 'cascadesFrom': {
                    this._applyCascadeHook();
                    break;
                }
                default:
            }
        }
    }

    // @ts-ignore
    static get observedAttributes() {
        // @ts-ignore
        return ['cascadesFrom'].concat(super.observedAttributes || []);
    }

    /** @inheritdoc */
    constructor() {
        super();

        this.hint = null;
        this.isBitField = undefined;
    }

    /** Attributes supported:
     * - drop - Whther the content will show in a drop down.
     * - value - The current value of the input.
     * - columnMapping - Is a CSV mapping the key,value,description to the data. Each entry should be a string of the name of the column.
     * - dataAttr - IS a CSV of columns whose data will be added to each Item element in the list of available items.
     * - sortItems - Boolean - Whether to sort the data by displayName before rednering the items.
     */
    connectedCallback() {
        this._selectionValues = {};
        this.internalKeyDown = this.on_keydown.bind(this); // TODO set for backward compatibility, to test and remove
    }

    dispose() {
        if (this.dialog) {
            this.stopObservingDragAndDrop('dragMove', 'dragEnd', this.dialog);
            // @ts-ignore
            this.dialog.adjustWidth = null;
            // @ts-ignore
            this.dialog.internalSetItemFocus = null;
            // @ts-ignore
            this.dialog.notifyChange = null;
            // @ts-ignore
            this.dialog.notifyChanged = null;
        }

        /** @type {HTMLElement} */
        this.dialog = null;
        this.lastSelectedItem = null;
        this._validationInput = null;
        this.checkValidity = null;

        if (this.hasAttribute('name')) {
            const form = this.closest('FORM');
            if (form) form[this.getAttribute('name')] = null;
        }

        if (this.isDrop) this.dropCleanup();

        if (this.cascadesFrom) {
            const el = this._getCascadeFromBehaviour();
            if (el) AOP.removeAfter(el, 'update', this._afterUpdate);
        }

        super.dispose();
    }

    init() {
        if (this.created) return;
        super.init();
        this.created = false;
        // if(this.isDrop)
        //	this.dropCleanup();

        // @ts-ignore
        if (!this.classList.contains(this.getStatic('CSSCLASS_NODE')))
            // @ts-ignore
            this.classList.add(this.getStatic('CSSCLASS_NODE'));

        // @ts-ignore
        setProperty(this, 'placeButtonOverInput', this.getStatic('DEFAULT_PLACE_BUTTON_OVER_INPUT'));
        // @ts-ignore
        this.setAttribute('placeButtonOverInput', this.getStatic('DEFAULT_PLACE_BUTTON_OVER_INPUT.toString()'));

        this.initProperties();
        this.getInputElement();
        this._initValidation();
        this.initDialog();
        this.disabled(this.hasAttribute('disabled'));
        if (!this.hasAttribute('disabled')) this.readOnly(this.hasAttribute('readonly'));

        // this.hint = this.isDrop && this.hasAttribute("placeholder") ? new CoreInputDropBase.Hint(this) : undefined;

        const selectionValues = this.getAttribute('selectionValues');
        if (selectionValues) this.setSelectionValues(selectionValues);

        if (this.hasAttribute('autofocus')) {
            this.getInputElement().focus();
        }

        this.created = true;
    }

    initProperties() {
        this.isDrop = getProperty(this, 'drop', this.getStatic('DEFAULT_ISDROP'));
        if (this.isDrop && !this.hasAttribute('drop')) this.setAttribute('drop', '1');
        this.defaultValue = getProperty(this, 'value');
        setProperty(this, 'max');
        setProperty(this, 'size', 11);
        setProperty(this, 'selectionMode', 0);
    }

    //
    // If the dialog has already been created it's contents are replaced. If there is no dialog then the _initInnerHTML is replaced.
    //
    replaceDialogContent(listItems, aValue) {
        this.generateDialogContent(null, aValue, listItems);
        this.adjustWidth();
    }

    // columnMapping is a CSV mapping the key,value,description to the data. Each entry should be a string of the name of the column.
    setData(data, columnMapping, required, append) {
        columnMapping = (columnMapping && columnMapping.csvSplit()) || [];
        let keyColumn = columnMapping[0] || 'key';
        let valueColumn = columnMapping[1] || 'value';
        // const descriptionColumn = columnMapping[2] || 'description';

        const newListArray = [];

        const dataAttr = getProperty(this, 'dataAttr', '')
            .split(',')
            .valueCount();

        if (data instanceof Rowset) {
            if (data.getColIndex(keyColumn) === -1) keyColumn = valueColumn;

            for (const name in dataAttr) {
                dataAttr[name] = data.getColIndex(name);
                if (dataAttr[name] === -1) delete dataAttr[name];
            }

            keyColumn = data.getColIndex(keyColumn);
            valueColumn = data.getColIndex(valueColumn);

            if (getProperty(this, 'sortItems', false)) {
                const comparator = function(a, b) {
                    return stringComparator(a[keyColumn], b[keyColumn]);
                };

                data.json.data = data.json.data.sort(comparator);
            }

            for (let row = 0, len = data.getRowCount(); row < len; row++) {
                const key = data.getField(row, keyColumn);
                const value = data.getField(row, valueColumn);
                const attrs = { tabindex: '-1', value: `${value}` };

                for (const name in dataAttr) attrs[`data-${name}`] = data.getField(row, dataAttr[name]).toString();

                const itemElem = document.createElement(this.getStatic('TAG_NAME_LIST_ITEM'));
                for (const name in attrs) {
                    itemElem.setAttribute(name, attrs[name]);
                }
                itemElem.innerText = key;

                newListArray.push(itemElem);
            }
        } else if (data) {
            if (getProperty(this, 'sortItems', false)) {
                const comparator = function(a, b) {
                    return stringComparator(a[keyColumn], b[keyColumn]);
                };
                data = clone(data).sort(comparator);
            }
            for (let row = 0, len = data.length; row < len; row++) {
                const value = data[row][valueColumn] == null ? '' : data[row][valueColumn].toString();
                const attrs = { tabindex: '-1', value: `${value}` };

                for (const name in dataAttr)
                    if (data[row][name] != null) attrs[`data-${name}`] = data[row][name].toString();

                const itemElem = document.createElement(this.getStatic('TAG_NAME_LIST_ITEM'));
                for (const name in attrs) {
                    itemElem.setAttribute(name, attrs[name]);
                }
                itemElem.innerText = data[row][keyColumn];
                newListArray.push(itemElem);
            }
        }

        if (this.created) this.replaceDialogContent(newListArray, append);
        else {
            const frag = document.createDocumentFragment();
            for (let i = 0; i < newListArray.length; i++) frag.appendChild(newListArray[i]);
            this.appendChild(frag);
        }
    }

    getData() {
        const data = [];
        const items = this.getOptions();
        for (let i = 0; i < items.length; i++)
            data.push({ key: this.getDisplayValue(items[i]), value: this.getOptionValue(items[i]) });
        return data;
    }

    setValue(value) {
        const result = super.setValue(value);
        this.selectItemFromValue(null, this.value, false);
        return result;
    }

    validate() {
        this._validateInvokeCustomValidation();
        this._validateInvokeHtml5Validation();
        const form = this.closest('FORM');
        const inputs =
            (form &&
                form instanceof HTMLElement &&
                Array.from(form.getElementsByTagName('*')).filter(elem => elem instanceof CoreInputDropBase)) ||
            [];
        for (let i = 0, iLen = inputs.length; i < iLen; i++) {
            const input = inputs[i];
            input instanceof CoreInputDropBase && input._validateInvokeHtml5Validation();
        }
        super.validate();
    }

    /** It is common to use onchange to customize the HTML5 validation attributes. This hooks into that common practice by invoking onchange. */
    _validateInvokeCustomValidation() {
        if (this.onchange) {
            // We're firing onchange on the component Element but we need it to act like an input Element. input has the "form" property available.
            // Mock the form object that exist for inputs but not for elements like Core:Calendar. This allows onchange handlers to reference "form".
            // @ts-ignore
            const _oldForm = window.form;
            // @ts-ignore
            window.form = this.closest('FORM');
            // @ts-ignore
            this.onchange();
            if (_oldForm !== undefined)
                // @ts-ignore
                window.form = _oldForm;
            // @ts-ignore
            else delete window.form;
        }
    }

    /** Custom implemetation of HTML 5 validation. We need to evaluate any HTML 5 attributes and test each one against the value */
    _validateInvokeHtml5Validation() {
        let valid = true;
        const validationAttrs = ['max', 'min'];
        const input = this.getInputElement();
        const value = this.getValue();
        for (let i = 0, iLen = validationAttrs.length; i < iLen && valid; i++)
            valid = this._setValidateAttr(validationAttrs[i], input, value);
    }

    /** Sets a validation attribute like min, max, pattern. Uses the pattern attribute to invalidate the input and the setCustomValidity to set the message. */
    _setValidateAttr(attrName, input, valueToValidate) {
        let valid = true;
        const attrValue = getProperty(this, attrName);
        if (attrValue === undefined) return true;
        let errorMessage = '';
        switch (attrName) {
            case 'min':
                valid = valueToValidate >= attrValue;
                errorMessage = 'Exceeds Min Value'; // TODO localize
                break;
            case 'max':
                valid = valueToValidate <= attrValue;
                errorMessage = 'Exceeds Max Value'; // TODO localize
                break;
        }

        input.setCustomValidity(valid ? '' : errorMessage);
        input[valid ? 'removeAttribute' : 'setAttribute']('pattern', '%%%%%');

        return valid;
    }

    /** Mimics the native input checkValidity funciton */
    checkValidity() {
        // @ts-ignore
        return this.getInputValidationElement().checkValidity();
    }

    initState() {
        const initialItem = this._getInitialItem();
        const initialValue = this._getInitialValue(initialItem);
        return {
            item: initialItem,
            value: initialValue,
            text: initialItem ? this.getDisplayValue(initialItem) : initialValue,
        };
    }

    getHint() {
        return this.hint;
    }
    _getInitialItem() {
        return this.getItemFromValue(getProperty(this, 'value'));
    }
    _getInitialValue(initialItem) {
        return this.getOptionValue(initialItem);
    }

    // TODO To consider...
    // constrainWidth - (Optional boolean) When TRUE, sets a width on drop-down box to prevent it from flowing horizontally
    adjustWidth(constrainWidth) {
        constrainWidth = constrainWidth == null ? true : constrainWidth;

        if (this.isDrop) {
            // We want the popup to expand it's width to be able to fit it's content. But we also want it's width to be at least the width of the input.
            // @ts-ignore
            this.dialog.style.minWidth = (this.textInput != null ? this.textInput.offsetWidth : this.offsetWidth).px();
            this.dialog.style.width = '';
            const options = this.getOptions();
            let offsetHeight;
            const displayed = this.dialog ? isDisplayed(this.dialog) : false;

            for (let ix = 0; ix < options.length; ix++)
                if (this.size && this.size === ix && displayed)
                    offsetHeight =
                        options[ix].offsetTop - (options[ix].offsetParent === this.dialog ? 0 : this.dialog.offsetTop);

            if (offsetHeight) {
                this.dialog.style.height = `${offsetHeight}px`;
                this.dialog.style.overflowY = 'scroll';
                // @ts-ignore
                this.dialog.sized = true;
            } else this.dialog && (this.dialog.style.height = '');
            return;
        }

        const options = this.getOptions();
        const maxLines = this.isDrop && this.size ? this.size : 11;

        if (!this.isDrop) {
            this.dialog.style.height = '100%';
            this.dialog.style.overflowY = 'auto';
        }

        if (this.isDrop && options.length > maxLines) {
            this.dialog.style.height = options[maxLines].offsetTop >= 0 ? options[maxLines].offsetTop.px() : 0;
            this.dialog.style.overflowY = 'scroll';
        }

        if (!this.dialog.style.minWidth) {
            const width = (getStyle(this, 'width') || 0).toInt();
            const borderLeftWidth = getStyle(this, 'border-left-width').toInt();
            const borderRightWidth = getStyle(this, 'border-right-width').toInt();
            this.dialog.style.minWidth = `${Math.max(0, width - borderLeftWidth - borderRightWidth)}px`;
        }
    }

    setWidth(width) {
        // Store width as we will need to set the size again when the GUI is visible
        this._width = width;
        const input = this.firstChild;
        if (input) {
            const button = this.querySelector('BUTTON');
            if (getAncestorProperty(this, 'includebuttoninwidth', 1)) {
                super.setWidth(width);
                if (button instanceof HTMLElement && input instanceof HTMLElement) {
                    input.style.width = `${width - button.offsetWidth}px`;
                }
            } else if (button instanceof HTMLElement && input instanceof HTMLElement) {
                this.style.width = `${width + button.offsetWidth}px`;
                input.style.width = `${width}px`;
            }
        }
    }

    hide() {
        this.hidePopup();
        super.hide();
    }

    show(clip) {
        super.show();
        this.setWidth(this._width);
        const input = this.firstChild;
        input instanceof HTMLElement && input.focus();
        input instanceof HTMLInputElement && input.select();
        this._applyClipping(this, clip);
    }

    // TODO abstract and remove...
    initInputNode() {}

    /**
     * @returns {HTMLElement}
     */
    getInputElement() {
        if (this.textInput == null) {
            const statics = this.constructor;
            /** @type {HTMLElement} */
            // @ts-ignore
            this.textInput = this.isDrop || statics.CREATE_INPUT_FOR_NON_DROP ? this.initInputNode() : undefined;
            // @ts-ignore
            if (this.textInput instanceof HTMLElement && this.getStatic('ENABLE_KEYBUFFER'))
                // @ts-ignore
                KeyBuffer(this.textInput, { onChange: this.bindScope('handleKeyBufferOnChange') });
        }
        // @ts-ignore
        return this.textInput;
    }

    _initValidation() {
        // TODO on timeout, run the onchange to init the validation.
        // ALSO set the start value.

        // Hook this node upto the FORM
        if (this.hasAttribute('name')) {
            const form = this.closest('FORM');
            if (form) form[this.getAttribute('name')] = this;
        }
        this.checkValidity = this.checkValidity.bind(this);
    }

    /** Looks for an input that will be used to run HTML5 validation for this input.
     * The validation input typicaly has the raw value. THis is so the raw value can be used for validation purposes.
     * @returns {HTMLElement} The input found. Typically a hidden input.
     */
    getInputValidationElement() {
        // @ts-ignore
        if (!this._validationInput) this._validationInput = this.textInput;
        // @ts-ignore
        return this._validationInput;
    }

    /**
     * @returns {DropDialogButton}
     */
    getButtonElement() {
        return this.appendChild(new DropDialogButton());
    }

    // @ts-ignore
    disabled(disable) {
        const isDisabled = this.hasAttribute('disabled');
        if (disable === true && (!this.created || !isDisabled)) {
            // @ts-ignore
            this.disabled = true;
            this.setAttribute('disabled', 'disabled');
            this.dialog.setAttribute('disabled', 'disabled'); // passing state along to dialog so styling can be applied
            this._eventState(false);
            for (let nodes = this.getElementsByTagName('*'), i = 0, size = nodes.length; i < size; i++) {
                if ('disabled' in nodes[i]) {
                    // @ts-ignore
                    nodes[i].disabled = true;
                    nodes[i].setAttribute('disabled', 'disabled');
                }
            }
        } else if (disable === false && (!this.created || isDisabled)) {
            // @ts-ignore
            this.disabled = false;
            this.removeAttribute('disabled');
            this.dialog.removeAttribute('disabled'); // passing state along to dialog so styling can be applied
            this._eventState(true);
            for (let nodes = this.getElementsByTagName('*'), i = 0, size = nodes.length; i < size; i++) {
                if ('disabled' in nodes[i]) {
                    // @ts-ignore
                    nodes[i].disabled = false;
                    nodes[i].removeAttribute('disabled');
                }
            }
        }
        return isDisabled;
    }

    readOnly(readonly) {
        const isReadOnly = this.hasAttribute('readonly');
        if (readonly === true && (!this.created || !isReadOnly)) {
            // @ts-ignore
            this.readOnly = true;
            this.setAttribute('readonly', 'readonly');
            this.dialog.setAttribute('readonly', 'readonly'); // passing state along to dialog so styling can be applied
            this._eventState(false);
            const nodes = Array.from(this.getElementsByTagName('*')).concat(
                Array.from(this.dialog.getElementsByTagName('*')),
            );
            for (let i = 0, size = nodes.length; i < size; i++)
                if ('readOnly' in nodes[i]) {
                    // @ts-ignore
                    nodes[i].readOnly = true;
                    nodes[i].setAttribute('readonly', 'readonly');

                    // Disable checkbox instead since readOnly doesn't prevent changing the checked state
                    // @ts-ignore
                    if (nodes[i].nodeName === 'INPUT' && nodes[i].type === 'checkbox')
                        nodes[i].setAttribute('disabled', 'disabled');
                }
        } else if (readonly === false && (!this.created || isReadOnly)) {
            // @ts-ignore
            this.readOnly = false;
            this.removeAttribute('readonly');
            this.dialog.removeAttribute('readonly'); // passing state along to dialog so styling can be applied
            this._eventState(true);
            const nodes = Array.from(this.getElementsByTagName('*')).concat(
                Array.from(this.dialog.getElementsByTagName('*')),
            );
            for (let i = 0, size = nodes.length; i < size; i++)
                if ('readOnly' in nodes[i]) {
                    // @ts-ignore
                    nodes[i].readOnly = false;
                    nodes[i].removeAttribute('readonly');

                    // @ts-ignore
                    if (nodes[i].nodeName === 'INPUT' && nodes[i].type === 'checkbox')
                        nodes[i].removeAttribute('disabled');
                }
        }
        return isReadOnly;
    }

    _eventState(on) {
        if (on) {
            if (this.dialog) {
                this.observe('keydown', this.dialog);
                this.observe('mousedown', this.dialog);
                this.observe('mouseup', this.dialog);
            }
            if (this.textInput && this.getStatic('SHOW_DIALOG_ON_INPUT_FOCUS'))
                this.observe('mousedown', this.textInput, 'showPopup');
        } else {
            if (this.dialog) {
                this.stopObserving('keydown', this.dialog);
                this.stopObserving('mousedown', this.dialog);
                this.stopObserving('mouseup', this.dialog);
                this.stopObservingDragAndDrop('dragMove', 'dragEnd', this.dialog);
            }
            if (this.textInput instanceof HTMLElement && this.getStatic('SHOW_DIALOG_ON_INPUT_FOCUS'))
                this.stopObserving('mousedown', this.textInput, 'showPopup');
        }
    }

    dropCleanup() {
        if (this.dropbutton) {
            this.doOnDialogClose = null;
            // @ts-ignore
            this.dropbutton.auxButton = null;
            // @ts-ignore
            this.dropbutton.widget = null;
            this.dropbutton = null;
        }

        if (this.textInput) this.textInput = null;
    }

    dropInit(initialValue, initialText) {
        const width = this.style.width;
        if (!width || width === 'auto') this.classList.add('DefaultWidth');

        this._initControls(initialValue);
        this.getInputElement();
    }

    nondropInit(initialValue, initialText) {
        if (this.innerHTML) this.innerHTML = '';
        this.appendChild(this.dialog);

        this.dataType.setValue(initialValue);

        let selected = false;
        if (initialValue) {
            this.selectItemFromValue(null, initialValue);
            selected = true;
        } else {
            const options = this.getOptions();
            if (options.length) {
                this.selectItem(null, options[0], true);
                selected = true;
            }
        }
        if (!selected) this.update(initialValue);
    }

    _initControls(value) {
        this.dataType.setValue(value);
        const displayValue = this.getDisplayValue();
        setProperty(this, 'value', '');
        if (displayValue !== null) this.setDisplayValue(displayValue);

        /** @type {DropDialogButton} */
        this.dropbutton = this.getButtonElement();

        // @ts-ignore
        this.dropbutton.auxButton = this.getInputElement();
        // @ts-ignore
        this.dropbutton.widget = this;
        // @ts-ignore
        this.dropbutton.isFixedSize = this.getStatic('DIALOG_IS_FIXED_SIZE');
        this.doOnDialogClose = this.bindScope('doOnDialogClose');

        if (!this.getStatic('DIALOG_SELECTABLE')) this.dialog.style.userSelect = 'none';
        // finalize
        try {
            // @ts-ignore
            this.dropbutton.attachPopup(this.dialog);
        } catch (e) {
            // @ts-ignore
            this.dropbutton.attached = this.dialog;
        }
    }

    generateDialog(event, aValue) {
        this.dialog = document.createElement('div');
        this.dialog.className = 'DropDownDialog';
        this.dialog.setAttribute('popupCanOverlapWidget', this.getStatic('DIALOG_CAN_OVERLAP_WIDGET'));

        if (this.classList.contains('Popout')) this.dialog.classList.add('Popout');
        if (hasProperty(this, 'dropDownClass')) this.dialog.classList.add(getProperty(this, 'dropDownClass'));

        if (this.id != null && this.id.length) this.dialog.id = `_${this.id}`;
        if (this.isDrop) {
            this.dialog.classList.add(this.getStatic('DIALOG_CLASS_NAMES').drop);
            setStyle(this.dialog, { display: 'none' });
        } else this.dialog.classList.add(this.getStatic('DIALOG_CLASS_NAMES').pane);

        // @ts-ignore
        this.dialog.adjustWidth = this.bindScope('adjustWidth');
    }

    generateDialogContent(event, aValue, items) {
        const frag = document.createDocumentFragment();

        items = items || this.getOptions();
        for (let i = 0, len = items.length; i < len; i++) frag.appendChild(items[i]);

        const dialog = this.dialog;
        dialog.innerHTML = '';
        dialog.appendChild(frag);
        this.selectItemFromValue(event, aValue);
    }

    initDialog(event, aValue) {
        if (this.dialog) return;

        const initState = this.initState();
        if (initState.value !== getProperty(this, 'value')) this.setNodeValue(initState.value);
        // Get the items before the dialog is created.
        const items = this.getOptions();
        this.generateDialog(null, initState.value);
        this.generateDialogContent(null, initState.value, items);
        if (this.isDrop) this.dropInit(initState.value, initState.text);
        else this.nondropInit(initState.value, initState.text);

        for (let i = 0, len = items.length; i < len; i++) items[i].tabIndex = -1;

        // @ts-ignore
        this.dialog.adjustWidth();

        this.dialog.scrollTop = this.dialogScrollTop || 0;

        // @ts-ignore
        this.dialog.internalSetItemFocus = this.internalSetItemFocus.bind(this);

        // @ts-ignore
        this.dialog.notifyChange = this.bindScope('notifyChange');
        // @ts-ignore
        this.dialog.notifyChanged = this.bindScope('notifyChanged');
    }

    findNextMatch(event, keyCode) {
        const options = this.getOptions();
        const keyValue = String.fromCharCode(keyCode);
        const selectedix = this.getSelectedItemIndex();
        let innerText;
        let ix;

        for (ix = selectedix + 1; ix < options.length; ix++) {
            innerText = options[ix].getInnerText().trim();
            if (innerText && innerText.length > 0 && innerText.charAt(0).toUpperCase() === keyValue) {
                this.selectItem(event, options[ix]);
                return;
            }
        }

        for (ix = 0; ix < selectedix; ix++) {
            innerText = options[ix].getInnerText().trim();
            if (innerText && innerText.length > 0 && innerText.charAt(0).toUpperCase() === keyValue) {
                this.selectItem(event, options[ix]);
                return;
            }
        }
    }

    findPartialMatch(value) {
        const options = this.getOptions();
        const testValue = value.toLowerCase();

        for (let i = 0, size = options.length; i < size; i++) {
            const optionValue = options[i].getInnerText().toLowerCase();
            if (optionValue && !optionValue.indexOf(testValue)) return options[i];
        }
        return undefined;
    }

    filterByMatch(value) {
        const filterHandler = this.dispatchCustomEvent('filter', { value, behavior: this });
        if (filterHandler.defaultPrevented === false || value.length === 0) {
            const options = this.getOptions();
            const testValue = new RegExp(value, 'i');

            for (let i = 0, size = options.length; i < size; i++) {
                const optionValue = options[i].getInnerText();
                const match = testValue.test(optionValue);
                options[i].style.display = match ? '' : 'none';
                options[i].nonselectable = !match;
            }
        }
    }

    focus() {
        const input = this.getInputElement();
        if (this.isDrop && this !== input) input.focus();
    }

    handleKeyBufferOnChange(context) {
        let item;

        if (context.isFirstCharacterMatch())
            this.findNextMatch(context.event, context.value.toUpperCase().charCodeAt(0));
        else if (context.isStringMatch()) {
            item = this.findPartialMatch(context.value);
            this.selectItem(context.event, item, true);

            if (this.getStatic('FILTER')) this.filterByMatch(context.value);
        }
    }

    containerKeyDown(event) {
        event.element().internalKeyDown(event);
    }

    getValueSeparator() {
        return ',';
    }

    getDisplayValue(item) {
        if (item instanceof HTMLElement) {
            item = item.querySelectorAll(':scope > core:concise') || item;
            return (
                (item && item.getInnerText()) ||
                getProperty(this, 'emptyDisplayValue', this.getStatic('DEFAULT_EMPTY_DISPLAY_VALUE'))
            );
        } else if (hasProperty(this, 'displayValue')) return getProperty(this, 'displayValue');

        const dt = item == null ? this.dataType : new this.dataType.constructor(item);

        if (dt && dt.getValue() != null) {
            const fieldsInfo = { selector: this.getData() };
            if (this.getStatic('DEFAULT_MULTISELECTION')) fieldsInfo.separator = this.getValueSeparator();
            if (this.isBitField) fieldsInfo.bitField = this.isBitField;
            return toDisplayValue(dt, fieldsInfo, this);
        }

        return getProperty(this, 'emptyDisplayValue', this.getStatic('DEFAULT_EMPTY_DISPLAY_VALUE'));
    }

    setDisplayValue(displayValue) {
        const input = this.getInputElement();
        if (!input) return undefined;
        if (displayValue instanceof HTMLElement || displayValue === undefined)
            displayValue = this.getDisplayValue(displayValue);

        if (input.tagName === 'INPUT' && input instanceof HTMLInputElement) {
            if (input.value === displayValue) return false;
            input.value = displayValue;
        } else {
            const textNode = input.firstChild || input.appendChild(document.createTextNode(''));
            if (textNode.nodeValue === displayValue) return false;
            textNode.nodeValue =
                displayValue || getProperty(this, 'emptyDisplayValue', this.getStatic('DEFAULT_EMPTY_DISPLAY_VALUE'));
        }
        return true;
    }

    getFocusItem() {
        const selectedItem = this.getSelectedItem();
        const focusItem = selectedItem || this.dialog.children[0];
        return focusItem;
    }

    getLocaleArray(name) {
        const value = this.getLocaleValue(name);
        return value ? value.split(',') : [];
    }

    getLocaleValue(name) {
        if (!this._localeCache) this._localeCache = {};
        if (this._localeCache[name]) return this._localeCache[name];

        const ancestor = this.closest(`[${name}]`);
        return (this._localeCache[name] = ancestor ? ancestor.getAttribute(name) : null);
    }

    // TODO getItem rename
    getOption(theElement) {
        return theElement.ancestor(this.getStatic('TAG_NAME_LIST_ITEM'));
    }

    // TODO To consider...
    // TODO getItems rename
    getOptions(className, callback) {
        let options = [];
        if (this.dialog)
            options = Array.from(this.dialog.querySelectorAll(className || this.getStatic('TAG_NAME_LIST_ITEM')) || []);
        if (this.tagName !== 'INPUT')
            options = Array.from(this.querySelectorAll(className || this.getStatic('TAG_NAME_LIST_ITEM')) || []);
        if (callback) {
            options.forEach(callback);
        }
        return options;
    }

    // TODO getItemValue rename
    getOptionValue(option) {
        if (!option) return '';
        const optionValue = option.getProperty('value');
        return (option.value = optionValue != null ? optionValue : option.getInnerText());
    }

    getSelectedValue() {
        // TODO update to support multi-selection
        return this.getOptionValue(this.getSelectedItem());
    }

    getPixels(pixelValue) {
        let pixelValueNumber;
        if (pixelValue.split) {
            pixelValueNumber = Number(pixelValue.split('px')[0]);
            if (isNaN(pixelValueNumber)) return 0;
            return pixelValueNumber;
        }
        return pixelValue;
    }

    removeSelection() {
        this.getOptions(`.${this.getStatic('CSSCLASS_SELECTED')}`, this.removeSelectionCallback.bind(this));
    }

    removeSelectionCallback(item) {
        item.removeClassName(CoreInputDropBase.CSSCLASS_SELECTED);
        this.removeSelectionValue(this.getOptionValue(item));
        item.tabIndex = -1;
    }

    removeLastSelected() {
        this.getOptions(`.${this.getStatic('CSSCLASS_LASTSELECTED')}`, this.getStatic('removeLastSelectionCallback'));
    }

    getSelectedItems() {
        return this.getOptions(`.${this.getStatic('CSSCLASS_SELECTED')}`);
    }

    getSelectedItem() {
        return this.getOptions(`.${this.getStatic('CSSCLASS_LASTSELECTED')}`)[0];
    }

    isSelected(item) {
        return item.classList.contains(this.getStatic('CSSCLASS_LASTSELECTED'));
    }

    getSelectedItemIndex() {
        const options = this.getOptions();
        if (options)
            for (let ix = 0; ix < options.length; ix++)
                if (options[ix].classList.contains(this.getStatic('CSSCLASS_SELECTED'))) return ix;
        return -1;
    }

    getListIndex(keyValue) {
        const options = this.getOptions();

        for (let ix = 0; ix < options.length; ix++) if (keyValue === this.getOptionValue(options[ix])) return ix;

        return -1;
    }

    getItemFromValue(aValue) {
        const ix = this.getListIndex(aValue);
        const options = this.getOptions();
        const option = ix > -1 ? options[ix] : this.isDrop ? options[0] : null;
        return option;
    }

    setSelectionValues(selectionValues) {
        const values = (selectionValues || '').split(',');
        for (let i = 0, len = values.length; i < len; i++) this._selectItem(this.getItemFromValue(values[i]));
    }

    getSelectionValues() {
        const selectionValues = this._selectionValues;
        let result = '';
        for (const value in selectionValues) result += `,${value}`;
        return result.substr(1);
    }

    addSelectionValue(value) {
        this._selectionValues[value] = true;
        if (this.created) this.setAttribute('selectionValues', this.getSelectionValues());
    }

    removeSelectionValue(value) {
        delete this._selectionValues[value];
        if (this.created) this.setAttribute('selectionValues', this.getSelectionValues());
    }

    hidePopup(event) {
        if (this.isDrop) {
            const wasClosed = this.dropbutton.hidePopup(event);
            if (wasClosed) this.dispatchCustomEvent('dialogClose', { event, behavior: this });
            return wasClosed;
        }
        return false;
    }

    showPopup(event) {
        if (this.isDrop) {
            if (this.dropbutton.isVisible() && event.isRightClick()) this.hidePopup(event);
            else if (
                (!event || event.isLeftClick()) &&
                this.dispatchCustomEvent('dialogOpen', { event, behavior: this }).defaultPrevented !== false
            )
                this.dropbutton.showPopup(event);
        }
    }

    togglePopup(event) {
        if (this.isDrop) this.dropbutton.isVisible() ? this.hidePopup(event) : this.showPopup(event);
    }

    internalSetItemFocus(nofocus) {
        if (!nofocus) {
            const item = this.getFocusItem();
            if (item) {
                try {
                    this.setFocus(item);
                } catch (e) {
                    // This block intentionally left empty. Ignore focus exception thatmay occur because the
                    // element is not visible or off-screen. In the future we may consider bringing the
                    // element into visible space or passing focus up to a default element.
                }
            }
        }
    }

    internalSetWidgetFocus() {
        this.getInputElement().focus();
    }

    isVisible() {
        return this.dropbutton.isVisible();
    }

    // TODO move to Element.prototype?
    scrollIntoView(elem, parent) {
        const elemOffset = elem.positionedOffset();
        const elemHeight = elem.offsetHeight;
        const parentHeight = parent.offsetHeight;
        const parentScrollTop = parent.scrollTop;

        if (elemOffset.top < parentScrollTop) parent.scrollTop = elemOffset.top;
        else if (elemOffset.top + elemHeight > parentScrollTop + parentHeight)
            parent.scrollTop = elemOffset.top - parentHeight + elemHeight;
    }

    addToSelection(event) {
        // @ts-ignore
        return this.selectionMode === 1 || (this.getStatic('DEFAULT_MULTISELECTION') && !!(event && event.ctrlKey));
    }

    rangeSelection(event) {
        return this.getStatic('DEFAULT_MULTISELECTION') && !!(event && event.shiftKey);
    }

    // TODO consider separating function usage as, event handler and widget api concerns to generalize signature
    // Signature: [event,] item[, nofocus]
    selectItem(event, item, nofocus, update) {
        // console.log(arguments);
        if (event instanceof HTMLElement || typeof item === 'boolean') {
            nofocus = item;
            item = event;
            event = undefined;
        }
        if (this.isDisabled() || this.isReadOnly()) return false;

        if (!item || item.getProperty('nonselectable', false)) return false;

        const selectedItem = this.getSelectedItem();

        // @ts-ignore
        if (selectedItem === item && this.selectionMode === 0) {
            if (nofocus) return false;
            if (item && this && getStyle(this, 'display') !== 'none' && getStyle(this.dialog, 'display') !== 'none')
                this.setFocus(item);
            return false;
        }

        this.lastSelectedItem = selectedItem;

        const addToSelection = this.addToSelection(event);
        const rangeSelection = this.rangeSelection(event);

        if (!addToSelection && !rangeSelection) this.removeSelection();

        if (rangeSelection && selectedItem) this.selectRange(selectedItem, item);

        if (item) this._selectItem(item);

        if (!this.created) return false;

        if (
            !nofocus &&
            item &&
            this &&
            getStyle(this, 'display') !== 'none' &&
            getStyle(this.dialog, 'display') !== 'none'
        )
            this.setFocus(item, nofocus);

        if (update !== false && (!this.isDrop || !(this.dialog && isDisplayed(this.dialog)))) this.updateValue(event);

        if (item && this.dialog) this.scrollIntoView(item, this.dialog);

        if (nofocus) return undefined;

        return true;
    }

    selectItemByIndex(ix, nofocus, event) {
        const options = this.getOptions();
        let item = options[ix] || options[(ix = 0)];

        while (item && item.getProperty('nonselectable', false)) item = options[++ix];

        if (item) this.selectItem(event, item, nofocus);
    }

    _selectItem(item) {
        if (item.getProperty('nonselectable', false)) return;

        const value = this.getOptionValue(item);
        this.removeLastSelected();
        item.classList.add(this.getStatic('CSSCLASS_LASTSELECTED'));

        // @ts-ignore
        if (this.selectionMode === 0) {
            item.classList.add(this.getStatic('CSSCLASS_SELECTED'));
            this.addSelectionValue(value);
            // @ts-ignore
        } else if (this.selectionMode === 1) {
            if (item.classList.contains(this.getStatic('CSSCLASS_SELECTED'))) {
                item.removeClassName(this.getStatic('CSSCLASS_SELECTED'));
                this.removeSelectionValue(value);
            } else {
                item.classList.add(this.getStatic('CSSCLASS_SELECTED'));
                this.addSelectionValue(value);
            }
        }

        if (this.created) this.dispatchCustomEvent('itemSelected', { widget: this, value, item, behavior: this });
    }

    selectRange(itemA, itemB) {
        if (itemA === itemB) {
            this._selectItem(itemA);
            return;
        }

        const items = this.getOptions();
        let startIndex = items.indexOf(itemA);
        let endIndex = items.indexOf(itemB);

        if (startIndex > endIndex) {
            const temp = startIndex;
            startIndex = endIndex;
            endIndex = temp;
        }

        for (let i = startIndex; i <= endIndex; i++) this._selectItem(items[i]);
    }

    selectRelativeItem(event, item, offset, nofocus) {
        const options = this.getOptions();
        const itemIndex = options.indexOf(item);

        if (!offset || !options.length || (item && itemIndex === -1)) return false;
        if (!item && getProperty(this, 'wrapselection', false)) item = options[0];

        const boundaryOffset = Math.abs(offset);
        const dir = offset / boundaryOffset;

        for (let i = 0; i < boundaryOffset && item; i++) {
            let nonSelectableOffset = 0;
            do {
                item = options[itemIndex + (i + nonSelectableOffset + 1) * dir];
                nonSelectableOffset++;
            } while (item && item.getProperty('nonselectable', false));
        }

        if (!item) this[offset > 0 && this.getSelectedItem() ? 'selectLastItem' : 'selectFirstItem'](event, nofocus);

        return this.selectItem(event, item, nofocus);
    }

    selectFirstItem(event, nofocus) {
        this.selectItemByIndex(0, nofocus, event);
    }
    selectLastItem(event, nofocus) {
        this.selectItemByIndex(this.getOptions().length - 1, nofocus, event);
    }

    selectNextItem(event, nofocus) {
        return this.selectRelativeItem(event, this.getSelectedItem(), 1, nofocus);
    }
    selectPreviousItem(event, nofocus) {
        return this.selectRelativeItem(event, this.getSelectedItem(), -1, nofocus);
    }

    selectNextPageItem(event, nofocus) {
        return this.selectRelativeItem(
            event,
            this.getSelectedItem(),
            Math.floor(this.getDialogVisibleItemCount()) - 1,
            nofocus,
        );
    }
    selectPreviousPageItem(event, nofocus) {
        return this.selectRelativeItem(
            event,
            this.getSelectedItem(),
            -(Math.floor(this.getDialogVisibleItemCount()) - 1),
            nofocus,
        );
    }

    getDialogVisibleItemCount() {
        const firstChild = this.dialog.children[0];
        return firstChild instanceof HTMLElement && this.dialog.offsetHeight / firstChild.offsetHeight;
    }

    selectItemFromValue(event, aValue, update) {
        const option = this.getItemFromValue(aValue);
        this.selectItem(event, option, this.isDrop, update);
        return option;
    }

    setFocus(item, nofocus) {
        if (nofocus || !this.created) return;

        if (item && getStyle(this.dialog, 'display') !== 'none') item.focus();
    }

    updateValue(event) {
        return this.update(undefined, event);
    }

    doOnDialogClose(event) {
        const input = this.getInputElement();
        this.updateValue(event);
        if (input) {
            input.focus();

            // if(input.select)
            //	input.select();
        }
    }

    on_mousedown(event) {
        this.dialogInitialMousePos = {
            x: event.clientX,
            y: event.clientY,
        };

        const srcElem = event.element();
        const dialog = this.dialog;
        if (srcElem.descendantOf(dialog)) {
            const item = this.getOption(srcElem);
            if (item) {
                this.selectItem(event, item, true, false);
                item.focus();
            }
            if (
                srcElem !== dialog &&
                srcElem.nodeName !== 'INPUT' &&
                srcElem.nodeName !== 'TEXTAREA' &&
                srcElem.nodeName !== 'SELECT'
            )
                this.observeDragAndDrop('dragMove', 'dragEnd', dialog);
            if (this.getStatic('KEEP_FOCUS_ON_INPUT')) eventStop(event);
        }
    }

    on_mouseup(event) {
        if (event.element() === this.dialog) return;

        const delta = this.getStatic('MIN_MOUSE_MOVE_TO_CLOSE_DIALOG');
        const initialMousePos = this.dialogInitialMousePos;
        const hideDialog =
            initialMousePos &&
            initialMousePos.x < event.clientX + delta &&
            initialMousePos.x > event.clientX - delta &&
            initialMousePos.y < event.clientY + delta &&
            initialMousePos.y > event.clientY - delta;

        if (this.isDrop && hideDialog) {
            switch (typeof this.getStatic('CLOSE_DIALOG_ONSELECTION')) {
                case 'boolean':
                    if (this.getStatic('CLOSE_DIALOG_ONSELECTION')) this.hidePopup(event);
                    break;
                case 'function':
                    if (this.getStatic('CLOSE_DIALOG_ONSELECTION').call(this)) this.hidePopup(event);
                    break;
            }
        }

        this.updateValue(event);
    }

    dragMove(event) {
        const option = this.getOption(event.element());
        if (option && option !== this.getSelectedItem()) this.selectItem(event, option, true, false);
    }

    dragEnd(event) {
        this.stopObservingDragAndDrop('dragMove', 'dragEnd', this.dialog);
    }

    on_keydown(event) {
        const result = this.dispatchCustomEvent('beforeKeyDown', { event, behavior: this });
        if (result.defaultPrevented === true) return;

        if (this.getStatic('DEFAULT_MULTISELECTION') && event.ctrlKey && event.keyCode === 65) {
            const items = this.getOptions();
            this.selectRange(items[0], items[items.length - 1]);
        }

        switch (event.keyCode) {
            case EventKeys.KEY_PAGEUP:
            case EventKeys.KEY_PAGEDOWN:
            case EventKeys.KEY_END:
            case EventKeys.KEY_HOME:
                if (event.altKey || event.ctrlKey || event.shiftKey) return;
            case EventKeys.KEY_UP:
            case EventKeys.KEY_DOWN:
            case EventKeys.KEY_LEFT:
            case EventKeys.KEY_RIGHT:
                if (event.altKey && this.isDrop) this.dropbutton.internalKeyDown(event);
                else {
                    if (!this.dialog) this.generateDialog(event);
                    if (!this.handleDialogKeyDown(event)) return;
                }
                break;
            case EventKeys.KEY_ESC:
                this.hidePopup(event);
                return;
            case EventKeys.KEY_TAB:
            case EventKeys.KEY_RETURN: {
                const popupWasOpen = this.hidePopup(event);
                if (!popupWasOpen) this.updateValue(event);
                // @ts-ignore
                if (this.returnCancelBubblingOnInput || this.getStatic('RETURN_CANCEL_BUBBLING_ON_INPUT'))
                    eventStop(event);
                return;
            }
            case EventKeys.KEY_SHIFT:
            case EventKeys.KEY_CTRL:
            case EventKeys.KEY_ALT:
                return;
            default: {
                if (event.altKey || event.ctrlKey) {
                    if (document.activeElement === this.getInputElement()) return;
                    break;
                }
                // use get key to account for numeric values, even if they're from the number pad.  We need to match on number characters
                const getKeyVal = event.getKey();
                if ((event.keyCode > 64 && event.keyCode < 90) || (getKeyVal >= 0 && getKeyVal <= 9)) {
                    if (!this.dialog) this.generateDialog(event);
                }
                return;
            }
        }
        // TODO is this reachable?
        eventStop(event);
    }

    // Dialog navigation is determined by, drop|non-drop, dialog|input focus, dialog open|close, input readonly|editable
    passUserInputToDialog(event) {
        const activeNode = document.activeElement;
        const inputNode = this.getInputElement();

        if (!this.isDrop) return true;
        else if (this.dialog.contains(activeNode)) return true;
        else if (activeNode === inputNode) {
            if (inputNode.nodeName === 'DIV') return true;
            else if (inputNode.nodeName === 'INPUT' || inputNode.nodeName === 'TEXTAREA') {
                if (isDisplayed(this.dialog)) return true;
                else if (
                    inputNode.nodeName !== 'TEXTAREA' &&
                    (event.keyCode === EventKeys.KEY_UP || event.keyCode === EventKeys.KEY_DOWN)
                )
                    return true;
            }
        }

        return false;
    }

    handleDialogKeyDown(event) {
        if (this.passUserInputToDialog(event)) {
            const keyMapping = this.getStatic('DIALOG_KEY_MAPPING')[event.keyCode];
            if (keyMapping) return this[keyMapping](event, this.isDrop);
        }
        return undefined;
    }

    on_change(event) {
        const inputElement = this.getInputElement();
        if (inputElement.contains(event.target)) {
            if (!this.dialog) this.generateDialog(event);
            // @ts-ignore
            this.update(inputElement.value, event);
        }
    }

    doCascade(key, cascadeFromBehavior) {
        let data = [];
        if (key) {
            // let selectorKeys = this.cascadesData[key];
            // for (let i = 0, iLen = selectorKeys.length; i < iLen; i++)
            // {
            //    data.push(this.allData[this.allDataMap[selectorKeys[i]]]);
            // }
            // @ts-ignore
            data = this.cascadesData[key] || data;
        }

        const value = this.getValue();

        this.setData(data);

        const entry = data[data.findPropertyValue('value', value)] || { value: null };

        // the setValue will take care of the case where value is not in the cascade list.
        this.setValue(entry.value);

        if (cascadeFromBehavior) {
            const atCascadeContext = {
                widget: this,
                behavior: this,
                cascadeFromWidget: cascadeFromBehavior.node,
                cascadeFromBehavior,
                newValue: value,
                cascadeFromValue: key,
            };

            this.dispatchCustomEvent('cascade', atCascadeContext);
        }
    }

    _getCascadeFromBehaviour() {
        if (this.cascadesFrom) {
            return this.closest('Form').querySelector(`[name='${this.cascadesFrom}']`);
        }
        return undefined;
    }

    _applyCascadeHook() {
        const el = this._getCascadeFromBehaviour();

        if (el) AOP.after(el, 'update', this._afterUpdate, this);
    }

    _afterUpdate(result, origScope, value, event) {
        if (result) this.doCascade(origScope.getValue(), origScope);
    }
}

// binders:
// {
// 	set_selectedValues(value)
// 	{
// 		if(value)
// 			this._selectionValues = value.split(',').valueCount();
// 	},

// 	get_selectedValues()
// 	{
// 		return Object.keys(this._selectionValues).join(",");
//     },

//     set_cascadesFrom (cascadesFrom)
//     {
//         this.cascadesFrom = cascadesFrom;

//         // this hook is present in case the behaviour being wrapped doesn't exist yet.
//         setTimeout(this._applyCascadeHook.bind(this), 0);
//     },

//     //set_cascadesData (data)
//     //{
//     //    if (Object.isArray(data))
//     //    {
//     //        data = data.valueCount();
//     //    }
//     //    this.cascadesData = data;
//     //},

//     bind_complete ()
//     {
//         if (this.cascadesFrom)
//         {
//             this.allData = JSON.clone(this.bind_context.data.toArray());
//             this.cascadesData = {};
//             for (let i = 0, iLen = this.allData.length; i < iLen; i++)
//             {
//                 let group = this.allData[i].parentKey;

//                 if (!(group in this.cascadesData))
//                 {
//                     this.cascadesData[group] = [];
//                 }
//                 this.cascadesData[group].push(this.allData[i]);
//                 //this.allDataMap[this.allData[i].value] = i;
//             }
//         }

//         this.callSuper();

//         let el = this._getCascadeFromBehaviour();
//         if (el)
//         {
//             this.doCascade(el.getValue());
//         }
//     }
// }

const SYMBOL_DROP = '&nbsp;';

class DropDialogButton extends HTMLButtonElement {
    connectedCallback() {
        document.body.addEventListener('mousedown', this.doBodyClick);
        if (BrowserPlatform.Desktop) {
            document.body.addEventListener('resize', this.doBodyClick);
        }
        document.body.addEventListener('scroll', this.doBodyClick);
    }

    disconnectedCallback() {
        document.body.removeEventListener('mousedown', this.doBodyClick);
        document.body.removeEventListener('resize', this.doBodyClick);
        document.body.removeEventListener('scroll', this.doBodyClick);
    }

    /** @inheritdoc */
    constructor() {
        super();
        this.isFixedSize = true;
        if (this.children.length === 0) this.innerText = SYMBOL_DROP;
        this.className = 'dropdlgbutton';
        this.setAttribute('tabIndex', '-1');
        this.setAttribute('type', 'button');
        this.doBodyClick = this.doBodyClick.bind(this);

        // @ts-ignore
        this.widget.setAttribute('dropdialogopened', 0);
        this.addEventListener('mousedown', this.on_mousedown.bind(this));
    }

    dispose() {
        // @ts-ignore
        const popupPane = this.popupPane || this.popupPane;
        if (popupPane && popupPane.parentNode) popupPane.remove();

        this.popupPane = null;
        this.popupPane = null;
        this.widget = null;

        // @ts-ignore
        this.internalKeyDown = null;
        // @ts-ignore
        this.doBodyEvent = null;
        // @ts-ignore
        this.attachPopup = null;
        // @ts-ignore
        this.showPopup = null;
        // @ts-ignore
        this.hidePopup = null;
        // @ts-ignore
        this.positionPopup = null;
        // @ts-ignore
        this.doAttachPopup = null;
        // @ts-ignore
        this.auxButton = null;
        // @ts-ignore
        this.isVisible = null;
        // @ts-ignore
        this.origHeight = null;
        // @ts-ignore
        this.origOverflowY = null;
        // bl_removeBodyListener(this);
    }

    /**
     * @param {MouseEvent} event
     */
    doBodyClick(event) {
        const source = event.target;
        if (source instanceof HTMLElement) {
            if (this.contains(source)) return;

            if (this.popupPane.contains(source)) return;

            if (this.auxButton.contains(source)) return;

            if (this.popupPane) {
                if (this.popupPane.style.display === 'block' && 'clientX' in event && 'clientY' in event) {
                    const pointed = document.elementFromPoint(event.clientX, event.clientY);

                    if (this.popupPane.contains(pointed)) return;
                }

                this.hidePopup(event, true);
            }
        }
    }

    internalKeyDown(event) {
        switch (event.keyCode) {
            case 9: // tab
            case 27: // esc
            case 13: // return
                this.hidePopup(event);
                break;
            case 38: // up
                if (event.altKey) this.hidePopup(event);
                break;
            case 40: // down
                if (event.altKey) this.showPopup(event);
                break;
        }
    }

    doAttachPopup(event) {
        if (this.widget && this.widget.generatePopup)
            // && !this.popupPane)
            this.widget.generatePopup(event, this);

        if (this.popupPane) {
            this.positionPopup(this.popupPane);
            // pop_attachPopup(this, this.popupPane);
            document.body.appendChild(this.popupPane);
        }
    }

    attachPopup(newPopup) {
        this.popupPane = this.popupPane = newPopup;
    }

    positionPopup(popup) {
        const widgetNode = this.widget;
        const widgetHeight = widgetNode.offsetHeight;
        const scrollOffset = widgetNode.cumulativeScrollOffset();
        const widgetTop = widgetNode.offsetTop - scrollOffset.top;
        const widgetLeft = widgetNode.offsetLeft - scrollOffset.left;
        const widgetBottom = widgetTop + widgetHeight;

        // set initial values of the popup to be positioned under the listbox
        // TODO collect all of the styles and apply them at the end in one shot.
        popup.style.top = `${widgetBottom}px`;
        popup.style.left = `${widgetLeft}px`;

        if (this.origHeight !== null) popup.style.height = this.origHeight;
        if (this.origOverflowY !== null) popup.style.overflowY = this.origOverflowY;
        if (popup.adjustWidth) popup.adjustWidth(false);

        if (popup.offsetHeight) {
            const pos = popup.getPositionSuggestion({
                reference: (widgetNode && widgetNode.textInput) || widgetNode,
                referenceOverlap: popup.getProperty('popupCanOverlapWidget', false),
            });
            popup.style.left = pos.left.px();
            popup.style.top = pos.top.px();

            if (this.isFixedSize) {
                popup.style.width = pos.width.px();
                popup.style.height = pos.height.px();

                // Fix a sizing issue occuring only in IE9 when an element has box-sizing:border-box, position:absolute, and overflow:auto|scroll. (Prototype.Browser)
                // - Problem described at, http://social.msdn.microsoft.com/Forums/en-US/iewebdevelopment/thread/47c5148f-a142-4a99-9542-5f230c78cb3b
                // - Isolated test at, /Core/UserAgent/Test/Bugs/ie_incorrect-dimensions.html
                if (popup.offsetWidth < pos.width)
                    popup.style.width = `${pos.width + (pos.width - popup.offsetWidth)}px`;
                if (popup.offsetHeight < pos.height)
                    popup.style.height = `${pos.height + (pos.height - popup.offsetHeight)}px`;
            }
        }
    }

    _buildAtHandlerContext() {
        return { behavior: this, widget: this };
    }

    hidePopup(event, skipFocus) {
        if (!this.isAttached) return false;

        if (this.popupPane.style.display === 'block') {
            // this.resumeMonitors();

            if (this.widget.doOnDialogClose) this.widget.doOnDialogClose(event);

            if (!skipFocus) {
                if (this.popupPane.internalSetWidgetFocus) this.popupPane.internalSetWidgetFocus();
                else if (this.widget.internalSetWidgetFocus) this.widget.internalSetWidgetFocus();
                else this.widget.focus();
            }

            this.widget.setAttribute('dropdialogopened', 0);
            this.widget.atHandler('atClose', true, this._buildAtHandlerContext());
            return true;
        }

        return false;
    }

    showPopup(event, nofocus) {
        if (getStyle(this.popupPane, 'display') === 'block') return true;

        if (!this.isAttached) {
            this.doAttachPopup(event);
            this.isAttached = true;
        }

        // this.suspendMonitors();

        this.popupPane.style.display = 'block';
        this.positionPopup(this.popupPane);

        if (this.popupPane.internalSetItemFocus) this.popupPane.internalSetItemFocus(nofocus);
        else if (!nofocus) this.popupPane.focus();

        this.widget.setAttribute('dropdialogopened', 1);
        this.widget.atHandler('atOpen', true, this._buildAtHandlerContext());
        return true;
    }

    isVisible() {
        return this.popupPane ? this.popupPane.style.display === 'block' : false;
    }

    on_mousedown(event) {
        if (this.widget) {
            if (!this.widget.hasAttribute('disabled') && event.isLeftClick()) {
                if (!this.hidePopup(event)) this.showPopup(event);
            } else this.previousSibling.dispatchEvent(event);

            event.preventDefault();
        }
    }
}
