// @ts-check
/* eslint-disable camelcase */
/* eslint-disable no-param-reassign */
/* eslint-disable require-jsdoc */
import { EventKeys, eventStop } from '/node_modules/@trapezegroup/core-js-extensions/src/lib/event.js';
import {
    getProperty,
    hasProperty,
    isDisplayed,
} from '/node_modules/@trapezegroup/core-js-extensions/src/lib/element.js';
import { valueCount } from '/node_modules/@trapezegroup/core-js-extensions/src/lib/array.js';
import { equals } from '/node_modules/@trapezegroup/core-js-extensions/src/lib/object.js';
import { CoreInputDropBase } from './core-input-drop-base.js';
import { KeyBuffer } from '../core-wc-inputs/src/lib/keyBuffer.js';

// eslint-disable-next-line require-jsdoc
export class CoreInputChecklist extends CoreInputDropBase {
    static VALUE_SEPARATOR = ',';
    static BOOLEAN_FALSE = '0';
    static BOOLEAN_TRUE = '1';
    static TAG_NAME_LIST_ITEM = 'CORE =CHECKITEM';
    static DIALOG_CLASS_NAMES = { drop: 'checkpane dlgpane', pane: 'checklist' };
    static DEFAULT_MULTISELECTION = true;
    static DEFAULT_EMPTY_DISPLAY_VALUE = '';
    static SHOW_DIALOG_ON_INPUT_FOCUS = true;
    static ENABLE_KEYBUFFER = true;
    static CLOSE_DIALOG_ONSELECTION = false;

    constructor() {
        super();
    }

    initProperties() {
        super.initProperties();
        this.isBitField = getProperty(this, 'bitField', false);
    }

    _getInitialValue(initialItem) {
        let value = getProperty(this, 'value', '');
        value = this.isBitField ? value : this.tokenize(value).join(this.getValueSeparator());
        return !hasProperty(this, 'required')
            ? value
            : value || (this.isBitField ? '1' : this.getOptionValue(this.getOptions()[0]));
    }

    initDialog(event, aValue) {
        super.initDialog(event, aValue);

        this.observe('click', this.dialog, 'checkboxCheckChange');

        // @ts-ignore
        this.dialog.formatValue = this.bindScope('formatValue');
        // @ts-ignore
        KeyBuffer(this.dialog, { onChange: this.bindScope('handleKeyBufferOnChange') });

        if (this.dialog.firstChild instanceof HTMLElement) this.dialog.firstChild.tabIndex = 0;
    }

    generateDialogContent(event, aValue, items) {
        super.generateDialogContent(event, aValue, items);
        const statusValues = valueCount(this.tokenize(aValue));

        items = this.getOptions();
        for (let ix = 0, len = items.length; ix < len; ix++) {
            const item = items[ix];
            const optionValue = this.getOptionValue(item);
            const displayValue = this.getDisplayValue(item);
            const statusValue = statusValues[optionValue]
                ? CoreInputChecklist.BOOLEAN_TRUE
                : CoreInputChecklist.BOOLEAN_FALSE;
            this.generateItem(optionValue, displayValue, statusValue, item);
        }

        if (items.length && !getProperty(this, 'selectionValues', '')) this._selectItem(items[0]);
    }

    doDisplayed() {
        // @ts-ignore
        if (this.dialog.sized || !isDisplayed(this)) return;

        const options = this.getOptions();
        let offsetHeight;
        for (let ix = 0; ix < options.length; ix++)
            if (this.size && this.size === ix) offsetHeight = options[ix].offsetTop - this.dialog.offsetTop;

        if (offsetHeight) {
            this.dialog.style.height = `${offsetHeight}`;
            this.dialog.style.overflowY = 'scroll';
            // @ts-ignore
            this.dialog.sized = true;
        }
    }

    cleanupItemBoxes() {
        if (this.dialog) {
            for (let ix = 0, itemBoxes = this.getOptions('INPUT'); ix < itemBoxes.length; ix++) {
                const itemBox = itemBoxes[ix];
                if (this.isCheckBox(itemBox)) this.stopObserving('click', itemBox);
            }
        }
    }

    tokenize(aValue) {
        const tokens = [];
        const tokensCache = {};

        if (this.isBitField) {
            let parseValue = aValue.toInt();

            // find the upper limit of the bits we have (ie get the floor of lg(parseValue)
            const upperLimit = Math.floor(Math.log(parseValue) / Math.log(2));

            for (let i = upperLimit; i >= 0; i--) {
                if (parseValue >= 2 ** i && parseValue < 2 ** (i + 1)) {
                    tokens[i] = i;
                    tokensCache[i] = 1;
                    parseValue -= 2 ** i;
                }
            }
        } else {
            const separator = this.getValueSeparator();
            if (aValue && aValue.length && separator.length) {
                const matches = aValue.split(separator);
                for (let i = 0, len = matches.length; i < len; i++) {
                    const match = matches[i].trim();
                    if (!(match in tokensCache)) {
                        tokens[tokens.length] = match;
                        tokensCache[match] = 1;
                    }
                }
            } else if (aValue && aValue.length) {
                // @ts-ignore
                const slice = this.slice && this.slice > 0 ? this.slice : 1;
                for (let offset = 0; offset < aValue.length; offset += slice) {
                    const value = aValue.substr(offset, slice).trim();
                    if (!(value in tokensCache)) {
                        tokens[tokens.length] = value;
                        tokensCache[value] = 1;
                    }
                }
            } else if (!aValue && typeof aValue === 'string') {
                tokens[tokens.length] = '';
                tokensCache[''] = 1;
            }
        }

        return tokens;
    }

    isValueEqual(valueA, valueB) {
        return (
            super.isValueEqual(valueA, valueB) ||
            equals(valueCount(this.tokenize(valueA)), valueCount(this.tokenize(valueB)))
        );
    }

    getValueSeparator() {
        // @ts-ignore
        if (this.slice != null) return '';
        return getProperty(this, 'separator', CoreInputChecklist.VALUE_SEPARATOR);
    }

    isCheckBox(theElement) {
        return theElement.tagName === 'INPUT' && theElement.type === 'checkbox';
    }

    generateItem(optionValue, displayValue, statusValue, item) {
        item.innerHTML = '';
        if (!item.getProperty('nonselectable', false)) {
            let input = item.selectFirst('INPUT');
            if (!input) {
                input = document.createElement('input');
                input.setAttribute('autocomplete', 'off');
                input.setAttribute('style', 'border-style: none');
                input.setAttribute('type', 'checkbox');
                input.setAttribute('tabindex', '-1');
            }
            if (statusValue === CoreInputChecklist.BOOLEAN_TRUE) input.setAttribute('checked', 'checked');
            if (this.isReadOnly() || this.isDisabled()) input.readOnly = true;
            item.appendChild(input);
        }

        let span = item.selectFirst('SPAN');

        if (!span) {
            span = document.createElement('span');
            span.setInnerText(this.parseValue(displayValue));
        }

        item.appendChild(span);

        return item;
    }

    moveSelectedUp() {
        const selectedItem = this.getSelectedItem();

        if (!selectedItem) return;

        if (selectedItem.previousSibling)
            selectedItem.parentNode.insertBefore(selectedItem, selectedItem.previousSibling);
    }

    moveSelectedDown() {
        const selectedItem = this.getSelectedItem();

        if (!selectedItem) return;

        if (selectedItem.nextSibling)
            selectedItem.parentNode.insertBefore(selectedItem, selectedItem.nextSibling.nextSibling);
    }

    getOptionValue(option) {
        if (!option) return '';

        option.value = option.getProperty('value');

        if (option.value != null) return option.value;

        return this.getDisplayValue(option);
    }

    getOptionState(option) {
        if (!option || !option.firstChild) return false;
        return ((option && option.firstChild) || option).checked;
    }

    setOptionState(item, checked) {
        if (typeof checked === 'string') checked = checked === CoreInputChecklist.BOOLEAN_TRUE;
        const checkBox = (item && item.firstChild) || item;
        if (checkBox) {
            if (checkBox.checked !== checked) checkBox.checked = checked;
            if (checked) checkBox.setAttribute('checked', 'checked');
            else if (checkBox.hasAttribute('checked')) checkBox.removeAttribute('checked');
        }
    }

    getSelectedValue() {
        let aValue;
        const separator = this.getValueSeparator();

        if (this.isBitField) aValue = 0;
        else aValue = '';

        if (!this.dialog) return getProperty(this, 'value');

        const { children } = this.dialog;

        for (let wix = 0; wix < children.length; wix++) {
            const option = children[wix];

            const optionState = this.getOptionState(option);
            const optionValue = this.getOptionValue(option);

            if (optionState) {
                // @ts-ignore
                if (this.isBitField) aValue += 2 ** parseInt(optionValue, 10);
                else {
                    // @ts-ignore
                    if (aValue.length) aValue += separator;

                    aValue += optionValue;
                }
            }
        }

        return `${aValue}`;
    }

    getItemFromValue(aValue) {
        const ix = this.getListIndex(aValue);
        const options = this.getOptions();
        const option = ix > -1 ? options[ix] : null;
        return option;
    }

    setDisplayValue(displayValue) {
        if (!this.isBitField && getProperty(this, 'raw', false)) {
            displayValue = '';

            const item = this.getItemFromValue('');
            const blankItemDisplayValue = item ? this.getDisplayValue(item) : '';
            const valueSeparator = this.getValueSeparator();
            const value = this.dataType.getValue();

            const itemValues = value.split(valueSeparator);
            for (let i = 0, iLen = itemValues.length; i < iLen; i++)
                displayValue += (displayValue.length ? valueSeparator : '') + (itemValues[i] || blankItemDisplayValue);
        }
        return super.setDisplayValue(displayValue);
    }

    selectItemFromValue(event, aValue, update) {
        const option = super.selectItemFromValue(event, aValue, update);
        if (aValue) {
            const statusValues = valueCount(this.tokenize(aValue));

            const items = this.getOptions();
            for (let ix = 0, len = items.length; ix < len; ix++) {
                const item = items[ix];
                const optionValue = this.getOptionValue(item);
                const statusValue = statusValues[optionValue]
                    ? CoreInputChecklist.BOOLEAN_TRUE
                    : CoreInputChecklist.BOOLEAN_FALSE;
                if (this.isCheckBox(item && (item.firstChild || item))) this.setOptionState(item, statusValue);
            }
        }
        return option;
    }

    selectItem(event, item, nofocus, update) {
        if (event && event.element && !this.isCheckBox(event.target))
            return super.selectItem(event, item, nofocus, update);
        return undefined;
    }

    getCheckedItems() {
        const items = this.getOptions("INPUT[type='checkbox']");
        const checkedItems = [];
        for (let i = 0, len = items.length; i < len; i++)
            if (items[i].checked === true) checkedItems[checkedItems.length] = items[i];

        return checkedItems;
    }

    checkboxCheckChange(event) {
        if (this.isDisabled() || this.isReadOnly()) return false;

        this.checkChange(event);
        return undefined;
    }

    checkChange(event, forceUpdate) {
        if (event) {
            const src = event.target;
            const isCheckBox = this.isCheckBox(src) && src.descendantOf(this.dialog);
            if (isCheckBox || event instanceof KeyboardEvent) {
                const currCheck = src.parentNode;
                const items = this.getSelectedItems();
                const selectedItem = items.indexOf(currCheck) > -1 ? currCheck : this.getSelectedItem();
                const checkIntent = this.getOptionState(selectedItem);
                this.setOptionState(selectedItem, checkIntent);

                for (let i = 0, iLen = items.length; i < iLen; i++)
                    if (!isCheckBox || items[i] !== selectedItem) this.setOptionState(items[i], checkIntent);

                if (hasProperty(this, 'required') && !this.getCheckedItems().length) {
                    this.setOptionState(currCheck, true);
                    const requiredValue = getProperty(this, 'required');
                    if (requiredValue && requiredValue !== 'required') alert(requiredValue);
                }
            }
        }
        if (forceUpdate || !this.isDrop || !isDisplayed(this.dialog)) this.update(this.getSelectedValue(), event);
    }

    addToSelection(event) {
        let addToSelection = super.addToSelection(event);
        if (!addToSelection && event) {
            const src = event.target;
            addToSelection = this.isCheckBox(src) && this.isSelected(src.parentNode);
        }
        return addToSelection;
    }

    on_keydown(
        event, // keydown for the dropped dialog
    ) {
        super.on_keydown(event);
        if (event.keyCode === EventKeys.KEY_SPACE) {
            eventStop(event);
            const selectedItem = this.getSelectedItem();

            if (selectedItem) {
                const src = event.target;

                if (this.isCheckBox(event.target)) {
                    const currentItem = src.parentNode;
                    currentItem.firstChild.checked = !currentItem.firstChild.checked;
                } else selectedItem.firstChild.checked = !selectedItem.firstChild.checked;

                this.checkChange(event);
            }
        }
    }

    initInputNode() {
        const input = document.createElement('div');
        input.className = 'in';
        input.setAttribute('contentEditable', 'false');
        input.setAttribute('tabindex', '0');
        input.setAttribute('unselectable', 'true');

        input.appendChild(document.createTextNode(this.getDisplayValue()));
        this.textInput = this.appendChild(input);
        return this.textInput;
    }

    dropInit(aValue) {
        // set properties on node
        this.internalDialogChange = this.bindScope('internalDialogChange');
        this.internalKeyDown = this.bindScope('on_keydown');
        this.internalSetWidgetFocus = this.bindScope('internalSetWidgetFocus');

        super.dropInit(aValue);

        const input = this.textInput;

        // set properties on new elements
        // @ts-ignore
        input.internalKeyDown = this.bindScope('on_keydown');

        // set events on new elements
        this.observe('keydown', input, 'containerKeyDown');
    }

    dropCleanup() {
        if (this.textInput) {
            // @ts-ignore
            this.textInput.internalKeyDown = null;
            // @ts-ignore
            this.textInput.widget = null; // TODO check if used
        }

        this.internalSetWidgetFocus = null;
        this.internalDialogChange = null;
        this.internalKeyDown = null;

        super.dropCleanup();
    }

    internalDialogChange() {
        this.update();
    }

    replaceDialogContent(listItems, aValue) {
        this.cleanupItemBoxes();
        super.replaceDialogContent(listItems, aValue);
    }

    dispose() {
        if (this.dialog) {
            this.cleanupItemBoxes();
            // @ts-ignore
            this.dialog.formatValue = null;
        }

        this.moveSelectedDown = null;
        this.checkChange = null;
        this.getOptionValue = null;
        this.getDisplayValue = null;
        this.formatValue = null;
        this.getSelectedItemIndex = null;
        this.selectItemByIndex = null;

        super.dispose();
    }

    on_mouseup() {}

    doOnDialogClose(event) {
        this.checkChange(event, true);
    }
}

customElements.define('core-input-checklist', CoreInputChecklist);
