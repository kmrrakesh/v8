/* eslint-disable no-new */
/* eslint-disable no-param-reassign */
/* eslint-disable require-jsdoc */
// @ts-check
import { getProperty, isDisplayed } from '/node_modules/@trapezegroup/core-js-extensions/src/lib/element.js';
import { Rowset } from '/node_modules/@trapezegroup/core-js-tcftypes/src/lib/rowset.js';
import { CoreInputDropBase } from './core-input-drop-base.js';
import { KeyBuffer } from '../core-wc-inputs/src/lib/keyBuffer.js';

export class CoreInputListbox extends CoreInputDropBase {
    static TAG_NAME_LIST_ITEM = 'core:listitem';
    static DIALOG_CLASS_NAMES = { drop: 'listpane dlgpane', pane: 'listbox' };
    static DEFAULT_EMPTY_DISPLAY_VALUE = '';
    static SHOW_DIALOG_ON_INPUT_FOCUS = true;
    static ENABLE_KEYBUFFER = true;

    constructor() {
        super();
    }

    setData(data, columnMapping, required, append) {
        if (data instanceof Rowset) {
            if (data.getColCount() === 0) data = this.addRowsetSelectorColumns(data);

            if (!required && (data.getField(0, 'key') !== '' || data.getField(0, 'value') !== ''))
                data.insertRowAt(0, ['', '', '']);
        }

        super.setData(data, columnMapping, required, append);
    }

    addRowsetSelectorColumns(data) {
        data.json.header.push({ name: 'key', type: '10' });
        data.json.header.push({ name: 'value', type: '10' });
        data.json.header.push({ name: 'description', type: '10' });
        return data;
    }

    dropCleanup() {
        if (this.textInput) {
            // @ts-ignore
            this.textInput.internalKeyDown = null;
            // @ts-ignore
            this.textInput.widget = null;
        }

        this.internalKeyDown = null;
        this.internalSetWidgetFocus = null;
        super.dropCleanup();
    }

    dropInit(initialValue, initialText) {
        // set properties on node
        this.internalKeyDown = this.bindScope('on_keydown');
        this.internalSetWidgetFocus = this.bindScope('internalSetWidgetFocus');

        super.dropInit(initialValue);

        const input = this.getInputElement();
        const accessKey = getProperty(this, 'accessKey');

        // set properties on new elements
        // @ts-ignore
        input.internalKeyDown = this.bindScope('on_keydown');
        // @ts-ignore
        input.widget = this;

        // set events on new elements
        this.observe('keydown', input, 'containerKeyDown');

        if (accessKey) {
            this.accessKey = null;
            input.setAttribute('accessKey', accessKey);
        }
    }

    generateDialogContent(event, aValue, listItems) {
        super.generateDialogContent(event, aValue, listItems);
        // fix up the blank items
        listItems = listItems || this.getOptions();

        for (let ix = 0; ix < listItems.length; ix++) {
            const listItem = listItems[ix];
            const itemValue = this.getOptionValue(listItem);
            const itemContent = listItem.innerHTML;

            if (!itemContent) {
                listItem.innerHTML = '';
                if (!itemValue) listItem.value = '';
            }
        }
    }

    initDialog(event, aValue) {
        super.initDialog(event, aValue);
        // Ensure that the element is in the DOM so that KeyBuffer regestration doesnt happen on the window.
        if (!this.dialog.parentNode) {
            this.parentNode.appendChild(this.dialog);
            new KeyBuffer(this.dialog, { onChange: this.bindScope('handleKeyBufferOnChange') });
            this.parentNode.removeChild(this.dialog);
        } else new KeyBuffer(this.dialog, { onChange: this.bindScope('handleKeyBufferOnChange') });
    }

    getOptionMap() {
        if (this.optionMap) return this.optionMap;
        const options = this.getOptions();
        const optionMap = {};

        for (let ix = 0; ix < options.length; ix++) {
            const option = options[ix];
            const optionValue = this.getOptionValue(option);
            const displayText = this.getDisplayValue(option);
            optionMap[optionValue] = displayText;
        }

        return optionMap;
    }

    doDisplayed() {
        // @ts-ignore
        if ((this.dialog && this.dialog.sized) || !isDisplayed(this)) return;

        const options = this.getOptions();
        let offsetHeight;
        for (let ix = 0; ix < options.length; ix++)
            if (this.size && this.size === ix) offsetHeight = options[ix].offsetTop - this.dialog.offsetTop;

        if (offsetHeight) {
            this.dialog.style.height = `${offsetHeight}px`;
            this.dialog.style.overflowY = 'scroll';
            // @ts-ignore
            this.dialog.sized = true;
        }
    }

    initInputNode() {
        const input = document.createElement('input');
        input.className = 'in';
        input.setAttribute('readOnly', 'true');
        input.setAttribute('tabIndex', '0');
        input.removeAttribute('contenteditable');

        input.appendChild(document.createTextNode(this.getDisplayValue()));
        if (this.isRequired()) input.setAttribute('required', 'true');
        this.textInput = this.appendChild(input);
        return this.textInput;
    }

    //
    // Sets the raw value of the combobox. If there is a corrisponding friendly value, it will be displayed.
    //
    setRawValue(rawValue) {
        this.update(rawValue);
    }

    dispose() {
        if (this.dialog) {
            // @ts-ignore
            this.dialog.notifyChange = null;
            // @ts-ignore
            this.dialog.notifyChanged = null;
        }

        this.internalSetItemFocus = null;
        this.doDisplayChanged = null;
        this.selectItemFromValue = null;
        this.focus = null;
        this.optionMap = null;
        this.getOptionMap = null;

        super.dispose();
    }
    getState() {
        const state = {};
        state.value = getProperty(this, 'value');
        state.open = this.isVisible();
        if (state.open) state.selected = this.getSelectedItemIndex();
        return state;
    }

    setState(state) {
        super.setState(state);
        this.setRawValue(state.value);
        if (state !== undefined) {
            if (state.open === true) this.showPopup();
            if (state.open === false) this.hidePopup();
            if (state.selected) this.selectItemByIndex(state.selected);
        }
        return state;
    }
}
customElements.define('core-input-listbox', CoreInputListbox);
