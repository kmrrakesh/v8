/* eslint-disable camelcase */
/* eslint-disable require-jsdoc */
import {
    AbstractType,
    TcfWeekdaysStr,
    TcfWeekdaysInt,
    TcfDate,
    TcfBoolean,
    TcfTime,
    TcfTimeSpan,
    TcfBigTimeSpan,
    TcfDistance,
    TcfDistanceInt,
    TcfSpeed,
    TcfVolume,
    TcfPressure,
    TcfAcceleration,
    TcfTemperature,
    TcfFuelEconomy,
    TcfDateTime,
    getDataType,
} from '/node_modules/@trapezegroup/core-js-tcftypes/src/lib/types.js';
import { domEventListener } from '/node_modules/@trapezegroup/core-wc-mixins/src/mixins/legacy/domEventListener.js';
import { eventStop } from '/node_modules/@trapezegroup/core-js-extensions/src/lib/event.js';
import { CoreInputText } from './core-input-text.js';

// @ts-check
//
// The default Widget Map that maps data types (int32, weekdays etc.) to their corresponding  Editor Widget.
// Generally speaking, the data type is the key and the value is the Editor UI Class name.
// The exception is the key of 'default'. This is used if the requested data type does not have a key entry in the Hash.
//

// TODO convert values to HTML tag names OR each class should add it's own entry just like grid plug-ins do
export const defaultWidgetMap = new Map([
    ['text', CoreInputText],
    ['localizededitor', 'Core.UI.Editor.LocalizedEditor'],
    ['checklist', 'ChecklistBehavior'],
    ['weekdays', 'WeekdaysBehavior'],
    ['combobox', 'ComboboxBehavior'],
    ['listbox', 'ListboxBehavior'],
    ['calendar', 'CalendarBehavior'],
    ['checkbox', 'Core.UI.Editor.Boolean'],
    ['booleantoggle', 'Core.UI.Editor.ToggleStatesForBoolean'],
    ['selectortoggle', 'Core.UI.Editor.ToggleStatesForSelectors'],

    [TcfWeekdaysStr, 'WeekdaysBehavior'],
    [TcfWeekdaysInt, 'WeekdaysBehavior'],
    [TcfDate, 'CalendarBehavior'],
    [TcfBoolean, 'Core.UI.Editor.Boolean'],
    [TcfTime, 'Core.UI.Editor.Time'],
    [TcfTimeSpan, 'Core.UI.Editor.TimeSpan'],
    [TcfBigTimeSpan, 'Core.UI.Editor.LocalizedEditor'],
    [TcfDistance, 'Core.UI.Editor.LocalizedEditor'],
    [TcfDistanceInt, 'Core.UI.Editor.LocalizedEditor'],
    [TcfSpeed, 'Core.UI.Editor.LocalizedEditor'],
    [TcfVolume, 'Core.UI.Editor.LocalizedEditor'],
    [TcfPressure, 'Core.UI.Editor.LocalizedEditor'],
    [TcfAcceleration, 'Core.UI.Editor.LocalizedEditor'],
    [TcfTemperature, 'Core.UI.Editor.LocalizedEditor'],
    [TcfFuelEconomy, 'Core.UI.Editor.LocalizedEditor'],
    [TcfDateTime, 'Core.UI.Editor.LocalizedEditor'],

    ['default', CoreInputText],
]);

/** Object used to pass all required information to the Core.UI.Editor.Controller when requesting an Editor. */
export class CoreInlineEditorContext {
    /** Sets the target Element whose contents will be edited. */
    setTarget(target) {
        this.target = target;
    }

    /** Sets the Element whose ancestor contains the local formats */
    setLocalNode(localNode) {
        this.localNode = localNode;
    }

    /** Sets the Core.Type of the value to be edited */
    setDataType(dataType) {
        let DataTypeClass;
        if (typeof dataType === 'string') DataTypeClass = getDataType(dataType);
        else DataTypeClass = dataType;

        this.dataType = new DataTypeClass();
        this.dataType.initLocale(this.localNode);
    }

    /** */
    setFieldsLayoutInfo(fieldsInfo) {
        this.fieldsInfo = fieldsInfo;
    }

    /** Sets the type of Editor to be used for editing */
    setEditorType(editorType) {
        // TODO Perform some sanity check that the editor type exists
        this.editorType = editorType;
    }

    /** Sets the raw value of the Element to be edited */
    setRawValue(value) {
        this.rawValue = value;
    }

    /** */
    setEvent(event) {
        this.event = event;
    }

    /** */
    setNodeAttributes(attributes) {
        this.nodeAttributes = attributes;
    }
}

/**
 * parentBehaviorElement - (Required) The Parent Element that will be used to insert the Editor DOM Element into.
 * commitCallback - (Optional) This callback is invoked when an element being edited is commited. This callback is only called
 *					upon success edit. The value entered must have passed any validation checks required by the Input UI widget.
 * validationFailCallback - (Optional) This callback will be invoked if an attempt is made to commit an edited value that fails the
 *					Input UI widget validation.
 */
export class CoreInlineEditor extends domEventListener(HTMLElement) {
    /** @inheritdoc */
    constructor() {
        super();

        this.inputInstances = {};
        // this.observe("mousedown", document);

        this.setCommitOnBlur(true);
    }

    /** */
    atInputInvalidValue(target, contextElement, context) {
        if (this.validationFailCallback && this.getEditor())
            this.validationFailCallback(null, undefined, context.invalidValue, this.context);
    }

    getContext() {
        return this.context;
    }

    setContext(context) {
        this.context = context;
    }

    getState() {
        if (this.inEdit()) return this.getEditor().getState();
        return undefined;
    }

    setState(state) {
        if (this.inEdit()) this.getEditor().setState(state);
    }

    //
    // Retrieves the requested Input widget from the registry. If the Input widget does not exist in the repository it will be created.
    // If the requested Input widget can not be created (if it does not exist) then an Error is thrown.
    //
    // throws - If Input widget could not be created because the Class representing the Input widget could not be found.
    //
    getEditor() {
        if (this.context) {
            let type = defaultWidgetMap.get(this.context.editorType);

            if (type === undefined && this.context.editorType) type = this.context.editorType;
            if (type === undefined) type = defaultWidgetMap.get(this.context.dataType.constructor);
            if (type === undefined) type = defaultWidgetMap.get('default');

            if (type === undefined) {
                throw new Error(
                    `Error trying to create Inline Editor. Type ${
                        this.context.editorType
                    } does not exist in defaultWidgetMap: ${JSON.stringyfy(defaultWidgetMap)}`,
                );
            }

            if (this.inputInstances[type] === undefined) {
                this.context.nodeAttributes = this.context.nodeAttributes || {};
                const InputClass = type;
                const inputNode = InputClass.generateContainer(
                    Object.assign(this.context.nodeAttributes, { drop: '1' }),
                );
                this.appendChild(inputNode);
                // eslint-disable-next-line no-multi-assign
                const inputObj = (this.inputInstances[type] = new InputClass(inputNode));
                inputObj.init(this.context);
                if (inputObj.node) {
                    this.addAtHandler('atUserChanged', 'atUserChanged', inputObj.node);
                    this.addAtHandler('atBeforeKeyDown', 'atBeforeKeyDown', inputObj.node);
                    this.addAtHandler('atAfterKeyUp', 'atAfterKeyUp', inputObj.node);
                }
            }

            return this.inputInstances[type];
        }
        return undefined;
    }

    //
    // This is the most commonly used method by external calls.
    // This is a convenience for setting up the editing of an element.
    // It envokes the commiting of the previously edited element, and then sets up the editing of the next element.
    // If there is currently an element being edited that cannot be commited then the request to edit the new element fails.
    //
    // context - Core.UI.Editor.Context containing at least editorType, dataType and targetElement to edit
    //
    // returns - true if the request was successful. Otherwise false.
    //
    editElement(context) {
        if (this.commitEdit()) {
            this.setContext(context);
            this.openEdit();
            if (context.event) context.event.stopPropagation();
            return true;
        }
        return false;
    }

    //
    // Attepmts to commit the currently active edit.
    // Commiting involves checking that there is currently an active edit, validating the current value the edit, invoking any callbacks.
    //
    // Returns - true if the commit was successful OR there was nothing to commit. false if the commit was unsuccessful.
    //
    commitEdit() {
        if (this.context) {
            const oldValue = this.context.rawValue;
            let dataType = null;
            const editor = this.getEditor();

            try {
                if (editor.update) editor.update();
                dataType = editor.getDataType();
            } catch (e) {
                /** Fires when input validation fails. Can be used to handlethe validation error (display to user, etc.)
                 * @event CoreInlineEditor#editorValidationFail
                 * @property {boolean} hasChanged
                 * @property {*} oldValue
                 * @property {*} newValue
                 * @property {CoreInlineEditorContext} context
                 */
                this.dispatchCustomEvent('editorValidationFail', {
                    oldValue,
                    newValue: editor.value,
                    context: this.context,
                });
                return false;
            }
            const newValue = dataType.getValue();
            let hasChanged = this.hasEditorChanged(newValue);
            if (oldValue === null && newValue === '' && newValue !== false && newValue !== 0) hasChanged = false;

            if (
                hasChanged &&
                /** Fires when input validation is evaluated. Prevent default to make validation fail.
                 * @event CoreInlineEditor#editorValidation
                 * @property {boolean} hasChanged
                 * @property {*} oldValue
                 * @property {*} newValue
                 * @property {CoreInlineEditorContext} context
                 */
                this.dispatchCustomEvent('editorValidation', { hasChanged, oldValue, newValue, context: this.context })
                    .defaultPrevented
            )
                return false;

            this.hide();

            /** Fires when an input value has cahnged and been commited (passed validation)
             * @event CoreInlineEditor#editorCommit
             * @property {boolean} hasChanged
             * @property {*} oldValue
             * @property {*} newValue
             * @property {CoreInlineEditorContext} context
             */
            this.dispatchCustomEvent('editorCommit', { hasChanged, oldValue, newValue, context: this.context });
        }
        this.context = null;
        return true;
    }

    //
    // If there is currently an assigned target element for editing and an assigned Input widget,
    // initializes the Input widget and positions it on the screen.
    //
    openEdit() {
        if (this.context) {
            this.hide();

            const { dataType } = this.context;

            try {
                dataType.setValue(this.context.rawValue);
            } catch (e) {
                this.cancelEdit();
                throw e;
            }

            if (dataType) {
                const editor = this.getEditor();

                if (editor.dataType && editor.dataType.getClass() !== dataType.getClass()) {
                    const DtClass = dataType.constructor;
                    editor.dataType = new DtClass();
                }

                const required = this.context.fieldsInfo.input && this.context.fieldsInfo.input.required;
                editor.setData(this.context.fieldsInfo.selector, null, required);
                editor.setValue(dataType);
                editor.setStyles(this.context.fieldsInfo.inputStyle);

                if (this.context.fieldsInfo.input) editor.setRequired(required);
                if (this.context.fieldsInfo.displayWidth) editor.setMaxLength(this.context.fieldsInfo.displayWidth);
                if (editor.selectItemFromValue)
                    editor.selectItemFromValue(this.context.event, editor.getProperty('value'));

                if (this.context.target) {
                    this.updatePosition();
                    switch (editor.init(this.context)) {
                        case EditorAdvice.COMMIT:
                            if (this.commitEdit() === true) return undefined;
                            break;
                        case EditorAdvice.CANCEL:
                            this.cancelEdit();
                            eventStop(event);
                            return false;
                        case EditorAdvice.CONTINUE:
                        default:
                            this.show();
                            break;
                    }
                }
            }
        }
        return undefined;
    }

    setValue(value) {
        if (this.inEdit()) {
            const { dataType } = this.context;

            // try{
            dataType.setValue(value);
            // }catch(e){ throw e; }
            if (dataType) {
                const editor = this.getEditor();
                if (editor.getDataType() instanceof dataType.constructor === false) {
                    const DtClass = dataType.constructor;
                    editor.dataType = new DtClass();
                }
                // editor.setFieldsLayoutInfo(this.context.fieldsInfo);
                editor.setData(this.context.fieldsInfo.selector);
                editor.setDataType(dataType);
            }
        }
    }

    //
    // Removes the Input widget from view. Makes no changes to the currently assigned element to edit.
    // Deactivates the any currently active Input widget and element to be edited.
    //
    cancelEdit() {
        this.hide();
        this.context = null;
        /** Fires when an input editor was canceled
         * @event CoreInlineEditor#editorCancel
         * @property {boolean} hasChanged
         * @property {*} oldValue
         * @property {*} newValue
         * @property {CoreInlineEditorContext} context
         */
        this.dispatchCustomEvent('editorCancel', this.context);
    }

    //
    // Updates the position of the input widget. Helpful if the editing Element has moved or has changed position in the HTML tree.
    //
    updatePosition(newElement) {
        if (this.context) {
            if (Object.isUndefined(newElement) === false) this.context.target = newElement;
            this.getEditor().placeOver(this.context.target, this);
        }
    }

    inEdit() {
        return !!this.context;
    }

    //
    // Hides the currently active Editor
    //
    hide() {
        if (this.context) {
            this.getEditor().hide();
            document.stopObservingAndCapture('mousedown', this._mousedownListener);
            this.resumeMonitors();
        }
    }

    //
    // Displays the currently active Editor
    //
    show(clip) {
        if (this.context) {
            this.getEditor().show(clip);
            document.observeAndCapture('mousedown', this._mousedownListener);
            this.suspendMonitors();
        }
    }

    nodeInEditor(node) {
        if (Element.descendantOf(node, this)) return true;

        const inputMap = this.inputInstances;
        // eslint-disable-next-line no-restricted-syntax
        for (const type in inputMap) {
            if (Object.prototype.hasOwnProperty.call(inputMap, type)) {
                const inputNode = inputMap[type].node;
                if (Element.descendantOf(node, inputNode)) return true;
                if (inputNode.dialog && Element.descendantOf(node, inputNode.dialog)) return true;
            }
        }
        return false;
    }

    setCommitOnBlur(commitOnBlur) {
        // if(commitOnBlur)
        // {
        //	this._commitOnBlurHandler = this.clickOutsideEditor.bind(this);
        //	document.observeAndCapture('mousedown', this._commitOnBlurHandler);
        // }
        // else
        // {
        //	document.stopObservingAndCapture('mousedown', this._commitOnBlurHandler);
        //	this._commitOnBlurHandler = null;
        // }
        this.commitOnBlur = commitOnBlur;
    }

    // Filter on the grid is not closing.
    clickOutsideEditor(event) {
        // const editor = this.getEditor();
        // Pick up the times when atUserChanged are not fired by the widget but we have clicked outside of the widget.
        const result =
            this.commitOnBlur &&
            event.button === 0 &&
            this.nodeInEditor(event.target) === false &&
            /*! this.hasEditorChanged() && */ this.commitEdit() === false;
        if (result) eventStop(event);
        return !result;
    }

    hasEditorChanged(newValue) {
        if (this.context) {
            // eslint-disable-next-line no-param-reassign
            if (newValue instanceof AbstractType) newValue = newValue.getValue();

            return newValue !== this.context.rawValue;
        }
        return undefined;
    }

    atUserChanged(target, contextElement, context) {
        // if(this.commitEdit() === false)
        // {
        //	this.show();
        //	return;
        // }
    }

    atAfterKeyUp(target, contextElement, context) {
        const { event } = context;
        switch (event.keyCode) {
            case Event.KEY_RETURN:
                eventStop(event);
                if (this.commitEdit() === false) {
                    this.show();
                    return;
                }
                break;
            case Event.KEY_ESC:
                this.cancelEdit();
                eventStop(event);
                break;
            default:
        }

        /** Fires when an input editor keydown event occured. Allows the caller to perform some action.
         * @event CoreInlineEditor#editorKeyDown
         * @property {boolean} hasChanged
         * @property {*} oldValue
         * @property {*} newValue
         * @property {CoreInlineEditorContext} context
         */
        this.dispatchCustomEvent('editorKeyDown', event);
    }

    atBeforeKeyDown(target, contextElement, context) {
        if (this.context) {
            const { event } = context;
            switch (this.getEditor().statics.CONTROLLER_ADVICE_KEYDOWN(event)) {
                case EditorAdvice.COMMIT:
                    if (this.commitEdit() === false) {
                        eventStop(event);
                        this.show();
                        return undefined;
                    }
                    break;
                case EditorAdvice.CANCEL:
                    this.cancelEdit();
                    eventStop(event);
                    return false;
                case EditorAdvice.STOP_PROPAGATION:
                    return undefined;
                case EditorAdvice.CONTINUE:
                default:
                    break;
            }
            switch (event.keyCode) {
                case Event.KEY_TAB:
                    event.preventDefault();
                    break;
                default:
            }
        }
        return undefined;
    }

    on_mousedown(event) {
        const editor = this.getEditor();
        if (editor && !this.clickOutsideEditor(event)) {
            switch (this.getEditor().statics.CONTROLLER_ADVICE_MOUSEDOWN()) {
                case EditorAdvice.COMMIT:
                    if (this.commitEdit() === false) {
                        eventStop(event);
                        this.show();
                    }
                    break;
                case EditorAdvice.CANCEL:
                    this.cancelEdit();
                    eventStop(event);
                    return false;
                case EditorAdvice.CONTINUE:
                default:
                    break;
            }
        }
        return undefined;
    }
}

customElements.define('core-inline-editor', CoreInlineEditor);

export const EditorAdvice = {
    COMMIT: 1,
    CANCEL: 2,
    CONTINUE: 3,
    STOP_PROPAGATION: 4,
};
