/* eslint-disable no-param-reassign */
/* eslint-disable camelcase */
/* eslint-disable require-jsdoc */
// @ts-check
import { toNumber } from '/node_modules/@trapezegroup/core-js-tcftypes/src/lib/format.js';
import { getProperty } from '/node_modules/@trapezegroup/core-js-extensions/src/lib/element.js';
import { EventKeys } from '/node_modules/@trapezegroup/core-js-extensions/src/lib/event.js';
import { CoreInputListbox } from './core-input-listbox.js';

export class CoreInputCombobox extends CoreInputListbox {
    static DIALOG_CLASS_NAMES = { drop: 'listpane dlgpane', pane: 'combobox' };
    static DEFAULT_EMPTY_DISPLAY_VALUE = '';
    static SHOW_DIALOG_ON_INPUT_FOCUS = false;
    static ENABLE_KEYBUFFER = false;
    static CREATE_INPUT_FOR_NON_DROP = true;
    static FILTER = true; // Whether to apply filtering to the dialog to filter out items that do not match the current value the user has entered.

    static _filterCallBack(hint, request) {
        if (!request.eventInfo) return;

        const elem = document.getElementById(request.eventInfo.sourceId);
        if (elem) {
            const data = JSON.parse(request.content);
            CoreInputCombobox.applyFilterData(elem, data);
        }
    }

    static applyFilterData(combobox, data) {
        if (combobox instanceof CoreInputCombobox) {
            const columnlMapping = [
                data.length && 'key' in data[0] === false && 'text' in data[0] ? 'text' : 'key',
                'value',
                data.length && 'description' in data[0] === false && 'text' in data[0] ? 'text' : 'description',
            ];

            combobox.setData(data, columnlMapping.join(','));
        }
    }

    _getInitialValue(initialItem) {
        return this.getOptionValue(initialItem) || getProperty(this, 'value', this.dataType.getValue());
    }

    getSelectedValue() {
        const value = super.getSelectedValue();
        // @ts-ignore
        return value || this.getSelectedItem() ? value : this.getInputElement().value;
    }

    getItemFromValue(aValue) {
        const ix = this.getListIndex(aValue);
        const options = this.getOptions();
        const option = ix > -1 ? options[ix] : null;
        return option;
    }

    getListIndexFromDisplay(displayValue) {
        const options = this.getOptions();

        for (let ix = 0; ix < options.length; ix++) if (displayValue === this.getDisplayValue(options[ix])) return ix;

        return -1;
    }

    // Drop
    nondropInit(initialValue, initialText) {
        super.nondropInit(initialValue, initialText);
        this.innerHTML = '';
        // this.setDisplayValue(initialText);
        const input = this.getInputElement();
        this.appendChild(input);
        if (this.style.width) input.style.width = `${toNumber(this.style.width)}px`;
    }

    initInputNode() {
        const input = document.createElement('input');
        input.setAttribute('autocomplete', 'off');
        input.setAttribute('key', '');
        input.setAttribute('type', 'text');
        input.setAttribute('value', this.getDisplayValue());
        if (this.isRequired()) input.setAttribute('required', 'true');
        this.stopObserving('mousedown', input);
        this.textInput = this.appendChild(input);
        return this.textInput;
    }

    setValue(value) {
        return super.setValue(this.parseValue(value));
    }

    on_keydown(event) {
        super.on_keydown(event);

        if (event.ctrlKey && (event.keyCode === EventKeys.KEY_SPACE || event.keyCode === 190)) return this.autocomp();

        // It is a commit when the ENTER key is pressed while the drop-down list is opened.
        // The super method will hide the drop-down list, and we don't want to show the
        // auto-complete drop-down list again in this case.
        const isCommitSelection = event.keyCode === EventKeys.KEY_RETURN && this.dropbutton.isVisible();
        const getKeyVal = event.getKey();
        if (
            (event.keyCode > 64 && event.keyCode < 90) ||
            (getKeyVal >= 0 && getKeyVal <= 9) ||
            event.keyCode === EventKeys.KEY_DELETE ||
            event.keyCode === EventKeys.KEY_BACKSPACE ||
            event.keyCode === EventKeys.KEY_SPACE
        ) {
            if (!isCommitSelection && document.activeElement === this.getInputElement() && event.key) {
                if (this._autoCompTimeout) clearTimeout(this._autoCompTimeout);

                this._autoCompTimeout = setTimeout(this.autocomp.bind(this), 50);
            }
        }
        return undefined;
    }

    autocomp() {
        this._autoCompTimeout = null;
        // @ts-ignore
        const item = this.findPartialMatch(this.getInputElement().value);
        if (item) {
            if (this.isDrop) this.dropbutton.showPopup(null, true);
            this.selectItem(item, true);
        } else {
            this.removeLastSelected();
            this.removeSelection();
        }
        // @ts-ignore
        if (CoreInputCombobox.FILTER) this.filterByMatch(this.getInputElement().value);
    }

    parseValue(value) {
        const ix = this.getListIndexFromDisplay(value);
        if (ix > -1) value = this.getOptionValue(this.getOptions()[ix]);

        return value;
    }

    dispose() {
        if (this._autoCompTimeout) clearTimeout(this._autoCompTimeout);

        this.selectItemByIndex = null;
        this.getSelectedItemIndex = null;
        this.getDisplayValue = null;
        this.getOptionValue = null;
        super.dispose();
    }
}

customElements.define('core-input-combobox', CoreInputCombobox);
