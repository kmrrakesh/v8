/* eslint-disable camelcase */
/* eslint-disable require-jsdoc */
/* eslint-disable no-param-reassign */
// @ts-check
import { TcfString, AbstractType } from '/node_modules/@trapezegroup/core-js-tcftypes/src/lib/types.js';
import { domEventListener } from '/node_modules/@trapezegroup/core-wc-mixins/src/mixins/legacy/domEventListener.js';
import {
    isDisabled,
    isReadOnly,
    isRequired,
    getProperty,
} from '/node_modules/@trapezegroup/core-js-extensions/src/lib/element.js';
import { setStyleUnsafe, setStyle } from '/node_modules/@trapezegroup/core-js-extensions/src/lib/styles.js';
import { EditorAdvice } from '../core-wc-inputs/src/components/core-inline-editor.js';

/**
 * Classes that represent UI input object for the Basic Trapeze field types.
 * @example let booleanInput = Core.UI.Editor.Boolean();
 *	booleanInput.node.observe(callback);
 *	booleanInput.placeOver(elementToEdit);
 *	booleanInput.show();
 *
 *	callback = function(event){
 *		elementToEdit = booleanValue.getValue();
 *		booleanInput.hide;
 *	}
 */
export class CoreInputBase extends domEventListener(HTMLInputElement) {
    static DEFAULT_DATATYPE = TcfString;
    static DEFAULT_EMPTY_DISPLAY_VALUE = '';
    static CONTROLLER_ADVICE_KEYDOWN = function CONTROLLER_ADVICE_KEYDOWN(event) {
        return EditorAdvice.CONTINUE;
    };
    static CONTROLLER_ADVICE_MOUSEDOWN = function CONTROLLER_ADVICE_MOUSEDOWN(event) {
        return EditorAdvice.CONTINUE;
    };
    static ALLOWED_DATATYPES = [AbstractType];
    // static inputFactory = function inputFactory(parentNode, inputProperties, data) {
    //     //TODO Used core:weekdays2 because core:weekdays has a style of 'display: inline-block !important' which stops us from hiding the widget.
    //     let node = this.generateContainer(inputProperties);
    //     parentNode.appendChild(node);
    //     let widgetBehavior = new window[getClassName Core.Class.getClassName(this)](node);
    //     if(data)
    //         widgetBehavior.setData(data);
    //     widgetBehavior.init();
    //     return widgetBehavior;
    // }

    /** @returns {number} */
    get dialogScrollTop() {
        return this.dialog.scrollTop;
    }

    /** @inheritdoc */
    constructor() {
        super();

        this.lastSelectedItem = null;
        this.dialog = null;
    }

    /**
     *
     * @param {string} name static variable name
     * @returns {*}
     */
    getStatic(name) {
        return this.constructor[name];
    }

    /** */
    createDataType() {
        // @ts-ignore
        return new this.constructor.DEFAULT_DATATYPE(null, this);
    }

    /** init */
    init(options) {
        if (this.created) return;
        this.created = false;
        // @ts-ignore
        this.dataType = this.dataType || this.createDataType();
        options = options || {};
        this.inlineInput = options.inlineInput || false;
        this.origValue = null;
        this.created = true;
        this.observe('change');
        this.observe('keydown');
        this.observe('keyup');
    }

    /** */
    dataTypeIsAllowed(dataType) {
        // @ts-ignore
        for (let i = 0, dataTypes = this.constructor.ALLOWED_DATATYPES; i < dataTypes.length; i++)
            if (dataType instanceof dataTypes[i]) return true;
        return false;
    }

    /**
     * Returns a populated implementation of Core.Type.AbstractType.
     * The current value of this Editor is populated into the data type. Errors will be thrown if the value value of this Editor is not valid for the data type.
     */
    getDataType() {
        return this.dataType;
    }

    /**
     * Set the underlying data type of that this editor represents.
     */
    setDataType(abstractDataType) {
        if (this.dataTypeIsAllowed(abstractDataType)) {
            this.dataType = abstractDataType;
            this.initDataType();
            this.setNodeValue(abstractDataType.toString());
        } else throw new Error('Core.AbstractEditor.setValue: Value must be of type Core.Type.AbstractType');
    }

    /** */
    initDataType() {}

    /** */
    isDisabled() {
        return isDisabled(this);
    }
    /** */
    isReadOnly() {
        return isReadOnly(this);
    }
    /** */
    isRequired() {
        return isRequired(this);
    }

    /** */
    setRequired(required) {
        if (required && required.toString() !== 'false') {
            let value = required.toString();
            value = value === 'required' || value === 'true' ? 'required' : value;
            this.setAttribute('required', value);
        } else this.removeAttribute('required');
    }

    /** */
    setMaxLength(length) {
        if (length == null) this.removeAttribute('maxlength');
        else this.setAttribute('maxlength', length);
    }

    /** */
    setStyles(styles) {
        setStyleUnsafe(this, styles, true);
    }

    /** */
    getValue() {
        return this.getDataType().getValue();
    }

    /** */
    setValue(value) {
        if (value instanceof AbstractType) this.setDataType(value);
        else {
            try {
                this.dataType.fromString(value);
            } catch (e) {
                const context = { widget: this, invalidValue: value, error: e, behavior: this };
                const event = this.dispatchCustomEvent('invalidValue', context);
                ({ value } = event.detail.value);
                if (value === undefined) return false;
                this.dataType.fromString(value);
            }
        }
        const displayValue = this.getDisplayValue();
        this.setNodeValue(this.dataType.getValue());
        if (displayValue !== null) this.setDisplayValue(displayValue);

        this.validate();
        return undefined;
    }

    /** */
    setNodeValue(value) {
        this.value = value;
        // TODO Temp until C# binders can access HTML attributes
        this.value = value;
    }

    /** */
    setData(data) {}

    /** */
    getDisplayValue(item) {
        // @ts-ignore
        return (
            getProperty(this, 'displayValue') ||
            getProperty(this, 'value') ||
            getProperty(this, 'emptyDisplayValue', this.getStatic('DEFAULT_EMPTY_DISPLAY_VALUE'))
        );
    }

    /** */
    setDisplayValue(displayValue) {
        this.setNodeValue(displayValue);
    }

    /** */
    parseValue(value) {
        const dt = this.createDataType().fromString(value);

        return (dt && dt.getValue()) || null;
    }

    /** */
    isValueEqual(valueA, valueB) {
        const dt = this.createDataType();
        const a = dt.fromString(valueA).getValue();
        const b = dt.fromString(valueB).getValue();
        return a === b;
    }

    /** Positions the Editor over a specific Element on the screen */
    placeOver(elementToPlaceOver, referenceElem) {
        this.setPosition(elementToPlaceOver.getOffsetPosition(referenceElem || this));
        this.setWidth(elementToPlaceOver.offsetWidth);
        this.setHeight(elementToPlaceOver.offsetHeight);
    }

    /** */
    setWidth(width) {
        this.style.width = `${parseInt(width, 10)}px`;
    }
    /** */
    setHeight(height) {
        this.style.height = `${parseInt(height, 10)}px`;
    }

    /** */
    show(clip) {
        this.show();
        this.focus();
        // TODO We overide select in common.js to select element not user selection. Review this code.
        if (this instanceof HTMLInputElement) {
            this.select();
        }
        this._applyClipping(this, clip);
    }

    /** */
    hide() {
        this.hide();
        this.blur();
    }

    /** */
    _applyClipping(node, clip) {
        let clipStr = 'rect(auto, auto, auto, auto)';
        if (clip && (clip.top || clip.right || clip.bottom || clip.left)) {
            const clipTop = clip.top == null ? 'auto' : `${clip.top}px`;
            const clipRight = clip.right == null ? 'auto' : `${node.offsetWidth - clip.right}px`;
            const clipBottom = clip.bottom == null ? 'auto' : `${node.offsetHeight - clip.bottom}px`;
            const clipLeft = clip.left == null ? 'auto' : `${clip.left}px`;
            clipStr = `rect(${clipTop},${clipRight},${clipBottom},${clipLeft})`;
        }
        node.style.clip = clipStr;
    }

    /** */
    setPosition(position) {
        setStyle(this, {
            position: 'absolute',
            left: `${position.offsetLeft}px`,
            top: `${position.offsetTop}px`,
        });
    }

    /** @returns {HTMLElement} */
    getInputElement() {
        return this;
    }

    /** */
    getSelectedValue() {
        // @ts-ignore
        return this.getInputElement().value;
    }

    /** */
    selectItem(a, b, c, d) {}

    /** */
    getSelectedItem() {}

    /** Updates from current selection if no value is passed */
    update(value, event) {
        if (value === undefined) value = this.getSelectedValue();

        if (!this.isValueEqual(value, this.dataType.toString())) {
            const rawValue = this.parseValue(value);
            if (!this.created || this.notifyChange(event, rawValue)) {
                const oldValue = this.dataType.getValue();
                if (this.setValue(value) === false) return undefined;
                if (this.created && rawValue !== oldValue) this.notifyChanged(event, rawValue);
                return true;
            }
            this.selectItem(event, this.lastSelectedItem, false, false);
        }
        return false;
    }

    /** If event is undefined then the notify is classed as programatic and atUserChange will not fire. */
    notifyChange(event, newValue, ignore) {
        // console.log("notifyChange");
        const context = this._createAtHandlerContext(event, newValue);
        const atChange = this.dispatchCustomEvent('change', context);
        if (atChange.defaultPrevented === false && !ignore && this.created) {
            if (!event) {
                const atUserChange = this.dispatchCustomEvent('userChange', context);
                if (atUserChange.defaultPrevented === false) return true;
            }
        }
        return false;
    }

    // If event is undefined then the notify is classed as programatic and atUserChange will not fire.
    notifyChanged(event, newValue) {
        // console.log("notifyChanged");
        if (event) this.dispatchCustomEvent('userChanged', this._createAtHandlerContext(event, newValue));
    }

    _createAtHandlerContext(event, newValue) {
        // @ts-ignore
        const fullMatch = !!this.getSelectedItem();
        return { widget: this, event, newValue, behavior: this, fullMatch };
    }

    setState(state) {
        if (state !== undefined && state.value) this.update(state.value);
        return state;
    }

    getState() {
        const state = {};
        state.value = getProperty(this, 'value');
        return state;
    }

    validate() {
        const input = this.getInputElement();

        if (!input || (input instanceof HTMLInputElement && !input.setCustomValidity))
            // No INPUT element to perform HTML5 validation against
            return;

        const context = {
            widget: this,
            behvaior: this,
            value: this.dataType.getValue(),
        };

        /** useAncestors=true defaultReturn="" Fires when a the value of the input changes. It does't cancel the change but does allow us to hook into HTML5 validation.
         * The atHandler should return a string. An empty string means validation passed. A string with length means validation failed and the message will be used in the display.
         * @event Core.UI.Editor.AbstractInput#atValidate
         * @property {Element} The input behavior node
         * @property {Core.UI.Editor.AbstractInput} The input behavior
         * @property {any} the new raw value
         */
        const validationMessage = this.dispatchCustomEvent('atValidate', context);

        input instanceof HTMLInputElement && input.setCustomValidity(validationMessage.detail);
        if (validationMessage) {
            if (this._oldValidationPattern === undefined) this._oldValidationPattern = input.getAttribute('pattern');
            input.setAttribute('pattern', new Date().getTime().toString());
        } else if (this._oldValidationPattern !== undefined) {
            if (this._oldValidationPattern) input.setAttribute('pattern', this._oldValidationPattern);
            else input.removeAttribute('pattern');
            this._oldValidationPattern = undefined;
        }
    }

    on_change(event) {
        try {
            this.update(undefined, event);
        } catch (e) {
            this.setNodeValue(this.dataType.getValue());
        }
    }

    on_keydown(event) {
        this.dispatchCustomEvent('beforeKeyDown', { event });
    }

    on_keyup(event) {
        this.dispatchCustomEvent('afterKeyUp', { event });
    }
}

customElements.define('core-input-base', CoreInputBase);
