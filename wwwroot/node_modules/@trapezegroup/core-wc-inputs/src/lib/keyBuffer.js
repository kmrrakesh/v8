/* eslint-disable no-bitwise */
// @ts-check
/**
 * @typedef {object} Context
 * @property {number} [timeout]
 * @property {function} [onClear]
 * @property {function} [onChange]
 */

const DEFAULT_TIMEOUT = 1000;

/**
 * @param {{ new (): HTMLInputElement; new (): HTMLInputElement; prototype: HTMLInputElement; }} baseClass
 */
export class KeyBuffer {
    /** keydown handler */
    onKeydown() {
        // @ts-ignore
        this.suspendMonitors !== undefined && this.suspendMonitors();

        if (this.timerId) clearTimeout(this.timerId);
        this.timerId = setTimeout(this.clearValue.bind(this), this.context.timeout);
    }

    /**
     * Using keypress because it has a charCode value, charCodes are set when keypress results
     * in a character, otherwise the value is 0. This is used to distinguish between keys that
     * results in a character and keys that don't such as arrow, backspace, or function keys.
     * @param {KeyboardEvent} event
     */
    onKeypress(event) {
        const { charCode } = event;
        this._setMode(event, charCode);

        if (this.mode & 16 && this.value) this.clearValue(event);

        if (charCode) {
            if (this.mode & 25) this.value += String.fromCharCode(charCode);

            if (this.mode & 29)
                if ('onChange' in this.context)
                    this.context.onChange(new KeyBufferContext({ event, mode: this.mode, value: this.value }));
                else
                    this.input.dispatchEvent(
                        new CustomEvent('keyBufferChange', {
                            bubbles: true,
                            composed: true,
                            detail: { event, mode: this.mode, value: this.value, behavior: this },
                        }),
                    );
        }
    }

    /**
     * @param {HTMLElement} input
     * @param {Context} context
     */
    constructor(input, context) {
        /** @type {Context} */
        this.context = {};
        this.setContext(context);

        this.mode = 1; // 1 = unassigned, 2 = stop callback handle, 4 = first letter match, 8 = string match, 16 = unassigned/reset
        this.timerId = null;
        this.value = '';

        input.addEventListener('keypress', this.onKeypress.bind(this));
        input.addEventListener('keydown', this.onKeydown.bind(this));

        this.input = input;
    }

    /**
     * @param {any} event
     */
    clearValue(event) {
        if ('onClear' in this.context)
            this.context.onClear(new KeyBufferContext({ event, mode: this.mode, value: this.value }));
        else
            this.input.dispatchEvent(
                new CustomEvent('keyBufferClear', {
                    bubbles: true,
                    composed: true,
                    detail: { event, mode: this.mode, value: this.value, behavior: this },
                }),
            );

        if (this.timerId) clearTimeout(this.timerId);
        // @ts-ignore
        this.resumeMonitors && this.resumeMonitors();

        this.mode = 1;
        this.value = '';
        this.timerId = null;
    }

    /**
     * @param {Context} context
     */
    setContext(context) {
        this.context = context || {};
        // @ts-ignore
        this.context.timeout = this.context.timeout || DEFAULT_TIMEOUT;
    }

    /**
     * @param {any} event
     * @param {number} charCode
     */
    _setMode(event, charCode) {
        if (this.mode & 14 && charCode === 0) this.mode = 16;
        else if (this.mode & 4 && this.value !== String.fromCharCode(charCode)) this.mode = 2;
        // eslint-disable-next-line no-useless-return
        else if (this.mode & 14 || this.value.length < 1) return;
        else if (this.value === String.fromCharCode(charCode)) this.mode = 4;
        else if (charCode !== 0) this.mode = 8;
    }
}

/** KeyBuffer Context */
class KeyBufferContext {
    /**
     * @param {{ event: any; mode: any; value: any; }} data
     */
    constructor(data) {
        this.event = data.event;
        this.mode = data.mode;
        this.value = data.value;
    }

    /** @returns {boolean} */
    isFirstCharacterMatch() {
        return !!(this.mode & 5);
    }

    /** @returns {boolean} */
    isStringMatch() {
        return !!(this.mode & 9);
    }
}
