// @ts-check

import { Excel } from '@trapezegroup/core-js-excel/src/lib/excel.js';
import { ExcelStyle } from '@trapezegroup/core-js-excel/src/lib/excelStyle.js';
import { ExcelCell } from '@trapezegroup/core-js-excel/src/lib/excelCell.js';
import { ExcelRow } from '@trapezegroup/core-js-excel/src/lib/excelRow.js';
import { ExcelWorkSheet } from '@trapezegroup/core-js-excel/src/lib/excelWorksheet.js';
import { ExcelTable } from '@trapezegroup/core-js-excel/src/lib/excelTable.js';
import { rowsetUtil } from './rowsetUtil.js';
import { TypeInfo } from './typeInfo.js';

/**
 * Class to export Rowsets to Excel
 */
export class RowsetExcel extends Excel {
    /** @inheritdoc */
    constructor() {
        super();
    }

    /**
     *
     * @param {string} name - name to give to the new worksheet
     * @param {import('./rowset.js').Rowset} rowset - the Rowset to output into the worksheet
     * @param {object} options
     * @param {HTMLElement|boolean} options.localeNode - Element used for localization of the Rowset
     * @param {boolean} options.switched - Whether the Rowset rows and cols should be switched (pivot the Rowset)
     * @returns {Excel} this instance for chaining
     */
    addWorksheetFromRowset(name, rowset, options) {
        const { localeNode } = options;
        const switched = !!options.switched;
        const styleCols = {};
        const tcfDateTimeOffset = new Date(Date.UTC(1601, 0, 1)).getTime();

        const rows = [];

        for (
            let rowIndex = switched ? 0 : -1, rowCount = rowset[switched ? 'getColCount' : 'getRowCount']();
            rowIndex < rowCount;
            rowIndex++
        ) {
            const cells = [];
            for (
                let colIndex = switched ? -1 : 0, colCount = rowset[switched ? 'getRowCount' : 'getColCount']();
                colIndex < colCount;
                colIndex++
            ) {
                const col = switched ? rowIndex : colIndex;
                const row = switched ? colIndex : rowIndex;
                let type = 'String';
                let styleId = '';
                let value;

                // TODO calculate the Type from the Rowset and use the localized value
                if (typeof localeNode === 'boolean' || row === -1)
                    if (localeNode && row > -1) value = rowsetUtil.getLocalizedValue(row, col, rowset);
                    else if (row === -1 && !localeNode) value = rowset.getHeader(col).name;
                    else value = rowset.getField(row, col);
                else value = rowsetUtil.getLocalizedValue(row, col, rowset, localeNode);

                const extType = new TypeInfo(rowset.getHeader(col).type).getExt();
                if (value && value.length && value.trim().length && !isNaN(value)) type = 'Number';
                else if (extType === 1 && !isNaN(value)) {
                    value = +rowset.getField(row, col);
                    type = 'Boolean';
                } else if (extType === 35 && localeNode !== false && new Date(value).toString() !== 'Invalid Date') {
                    styleId = `StyleCol${col}`;
                    if (!styleCols[styleId]) {
                        styleCols[styleId] = new ExcelStyle(styleId);
                        styleCols[styleId].properties.NumberFormat.Format = 'mm/dd/yyyy hh:mm:ss'; // TODO convert from tcf format to excel format
                        this.styles.push(styleCols[styleId]);
                    }
                    value = new Date(rowset.getField(row, col) + tcfDateTimeOffset).toISOString();
                    type = 'DateTime';
                }

                value = `${value}`.replace(/(<|>|"|'|&)/g, m => {
                    switch (m) {
                        case '<':
                            return '&lt;';
                        case '>':
                            return '&gt;';
                        case '"':
                            return '&quot;';
                        case "'":
                            return '&apos;';
                        case '&':
                            return '&amp;';
                        default:
                            return '';
                    }
                });

                cells.push(new ExcelCell(value, type, styleId));
            }
            rows.push(new ExcelRow(cells));
        }
        this.worksheets.push(new ExcelWorkSheet(name, [new ExcelTable(rows)]));
        return this;
    }
}
