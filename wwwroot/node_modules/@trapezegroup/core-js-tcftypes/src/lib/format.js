/* eslint-disable no-bitwise */
/* eslint-disable prefer-rest-params */
/* eslint-disable prefer-destructuring */
/* eslint-disable no-nested-ternary */
/* eslint-disable no-prototype-builtins */
/* eslint-disable no-restricted-syntax */
/* eslint-disable no-param-reassign */
/* eslint-disable no-continue */
/* eslint-disable no-plusplus */
/* eslint-disable require-jsdoc */
// @ts-check
import {
    isNameStart,
    isName,
    isWhiteSpace,
    isNumber,
    isNumeric,
} from '@trapezegroup/core-js-extensions/src/lib/char.js';
import { getAncestorProperty } from '@trapezegroup/core-js-extensions/src/lib/element.js';
import { isoDateToDate, isoDatetimeToDate } from '@trapezegroup/core-js-extensions/src/lib/date.js';

export const toNumber = function toNumber(str) {
    if (str.split) {
        let ix = 0;

        while (isNumber(str.charAt(ix)) && str.length > ix) ix++;

        return Number(str.substring(0, ix));
    }
    return Number(str);
};

/**
 *
 * @param {string} str
 */
const isDecimal = function isDecimal(str) {
    return str && /^\d*(\.(\d+))?$/.test(str);
};

/**
 *
 * @param {string} str
 * @param {boolean} includeDelimeters
 * @returns {string[]}
 */
const splitDecimal = function splitDecimal(str, includeDelimeters) {
    const strings = [];

    if (!str.length) return strings;

    let currentString = '';
    let wasNumeric = false; // the initial value doesn't matter

    for (let ix = 0; ix < str.length; ix++) {
        const charValue = str.charAt(ix);

        if (isNumeric(charValue) || (charValue === '.' && currentString.indexOf('.') === -1)) {
            if (!wasNumeric) {
                if (ix > 0) {
                    if (includeDelimeters) strings.push(currentString);

                    currentString = '';
                }
                wasNumeric = true;
            }

            currentString += charValue;
        } else {
            if (wasNumeric) {
                if (ix > 0) {
                    strings.push(currentString);
                    currentString = '';
                }

                wasNumeric = false;
            }

            currentString += charValue;
        }
    }

    if (wasNumeric) strings.push(currentString);
    else if (includeDelimeters) strings.push(currentString);

    return strings;
};

/**
 *
 * @param {string} str
 * @returns {string}
 */
const trimZerosLeft = function trimZerosLeft(str) {
    return str.replace(/^0+/, '');
};

// FormatFunctions - for conversion support
const FormatFunction = {
    func_invert(numvalue) {
        return numvalue ? 1 / numvalue : 0;
    },
};

export const Format = {
    STANDARD: 'ISO',
    MILLIS: 'MILLIS',

    formatters: {},
    generalSpecifiers: {},

    // to convert between temperature scales
    // 1) add the src offset,
    // 2) divide by the src factor,
    // 3) multiply by the target factor and
    // 4) subtract the target offset
    measurementUnits: {
        speed: ['kph', 'mph', 'mps', 'km/h', 'mi/h'],
        distance: ['m', 'km', 'mi', 'ft', 'yd', 'mm'],
        volume: ['L', 'g', 'ig'],
        pressure: ['kPa', 'atm', 'psi', 'Pa'],
        acceleration: ['mps2', 'fps2', 'G'],
        temperature: ['C', 'K', 'F'],
        fueleconomy: ['L/100km', 'km/L', 'mpig', 'mpug'],
        weight: ['kg', 'g', 't', 'lb', 'oz', 'cwt', 'ton'],
        timespan: ['w', 'd', 'h', 'm', 'min', 's'],
    },
    measurementDefaults: {
        speed: 'kph',
        distance: 'm',
        volume: 'L',
        pressure: 'Pa',
        acceleration: 'mps2',
        temperature: 'K',
        fueleconomy: 'km/L',
        weight: 'kg',
        timespan: 's',
    },
    measurementFactors: {
        speed: { kph: 1, mph: 3280.84 / 5280, mps: 1 / 3.6, 'km/h': 1, 'mi/h': 3280.84 / 5280 },
        distance: { m: 1, km: 0.001, mi: 3.28084 / 5280, ft: 3.28084, yd: 3.28084 / 3, mm: 1000.0 },
        volume: { L: 1, g: 0.2641720523, ig: 0.21997 },
        pressure: { kPa: 0.001, atm: 1 / 101325, psi: 1 / 6894, Pa: 1 },
        acceleration: { mps2: 1, fps2: 3.28084, G: 1 / 9.8 },
        temperature: { C: 1, K: 1, F: 9 / 5 },
        fueleconomy: { 'L/100km': 0.01, 'km/L': 1, mpig: 2.825, mpug: 2.352 },
        weight: {
            kg: 1,
            g: 1000.0,
            t: 0.001,
            lb: 2.204623,
            oz: 2.204623 * 16,
            cwt: 2.204623 / 100,
            ton: 2.204623 / 2000,
        },
        timespan: { w: 1 / (3600 * 168), d: 1 / (3600 * 24), h: 1 / 3600, m: 1 / 60, s: 1 },
    },

    measurementPostFunction: {
        'L/100km': FormatFunction.func_invert,
    },

    measurementOffsets: {
        C: 273.15, // Celsius offset
        K: 0,
        F: 459.67, // Farenheight offset
    },

    // method for converting measurements - call with "this" set
    convertMeasurement(measurement) {
        let working = measurement;
        const unitsSpecifier = Format.getSiblingSpecifier(
            this,
            Format.seekSiblingIndex(this, FormatSpecifier.func_units),
        );

        if (unitsSpecifier) {
            const uom = Format.callSpecifier(unitsSpecifier.args[0], measurement);
            const factor = Format.getMeasurementFactor(this.dataType, uom);
            let offset = Format.measurementOffsets[uom];

            if (!offset) offset = 0;

            working = measurement * factor - offset;

            const postFunction = Format.measurementPostFunction[uom];

            if (postFunction) working = postFunction(working);
        }

        return working;
    },

    createParameterAlias(formatSpecifier, optDataType) {
        const parameter = {};

        if (typeof formatSpecifier === 'object') parameter.specifier = formatSpecifier;

        if (typeof formatSpecifier === 'string')
            parameter.specifier = Format.createFormatter(optDataType, formatSpecifier);

        return parameter;
    },

    // formatter support

    createFormatter(dataType, formatSpec) {
        const formatter = [];
        let pattern = '';
        let verbatim = '';
        let previousPattern = null;
        let previousMatch = null;
        let isNewChar = true;
        let escapedChar = false;
        let escapedQuote = false;
        let escaping = false;
        let ix = 0;
        let currentChar;
        let matchCount;
        let functionSpecifier;
        let functionSpecifierMethod;
        let parametricName;
        let parameter;
        let partialMatches;
        let specifierMethod;

        // @ts-ignore
        formatter.formatSpec = formatSpec;
        // @ts-ignore
        formatter.format = Format.formatterMethod;

        for (; ix < formatSpec.length; ix++) {
            if (isNewChar) {
                currentChar = formatSpec.charAt(ix);

                if (escapedChar) {
                    escaping = true;
                    escapedChar = false;
                } else if (currentChar === '\\') {
                    escapedChar = true;
                    continue;
                } else if (escapedQuote) {
                    if (currentChar === '"') {
                        escaping = false;
                        escapedQuote = false;
                        continue;
                    }

                    escaping = true;
                } else if (currentChar === '"') {
                    escaping = true;
                    escapedQuote = true;
                    currentChar = '';
                } else {
                    escaping = false;
                    escapedChar = false;
                }

                pattern += currentChar;
            }

            // alert("currentChar = "+currentChar+
            //    "\nescaping = "+escaping+
            //    "\nescapedChar = "+escapedChar+
            //    "\nescapedQuote = "+escapedQuote);

            isNewChar = true;

            matchCount = 0;

            if (!escaping) {
                functionSpecifierMethod = Format.getFunctionSpecifierMethod(pattern);

                if (functionSpecifierMethod) {
                    // if(previousPattern)
                    // {
                    // todo: ? maybe not
                    // }

                    if (verbatim.length) formatter[formatter.length] = Format.createVerbatimSpecifier(verbatim);

                    functionSpecifier = Format.createFormatSpecifier(dataType, pattern, functionSpecifierMethod);

                    ix = Format.processFunction(ix + 1, dataType, formatSpec, functionSpecifier);
                    formatter[formatter.length] = functionSpecifier;

                    verbatim = '';
                    pattern = '';
                    previousPattern = null;
                    previousMatch = null;
                    continue;
                }

                parametricName = Format.getParametricName(pattern);
                parameter = Format.param_getParameter(parametricName);

                if (parameter) {
                    // if(previousPattern)
                    // {
                    // todo: ? maybe not
                    // }

                    if (verbatim.length) formatter[formatter.length] = Format.createVerbatimSpecifier(verbatim);

                    if (parameter.specifier) {
                        for (let psx = 0; psx < parameter.specifier.length; psx++)
                            formatter[formatter.length] = parameter.specifier[psx];
                    } else formatter[formatter.length] = Format.createParameterSpecifier(parametricName);

                    verbatim = '';
                    pattern = '';
                    previousPattern = null;
                    previousMatch = null;
                    continue;
                }

                partialMatches = Format.getPartialMatches(dataType, pattern);
                matchCount = partialMatches ? partialMatches.length : 0;
            }

            // alert("pattern = "+pattern+
            //    "\npreviousPattern = "+previousPattern+
            //    "\npreviousPMatch = "+previousMatch+
            //    "\nverbatim = "+verbatim+
            //    "\nmatchColunt = "+matchCount);

            if (matchCount === 1) {
                specifierMethod = Format.getMatchingSpecifierMethod(dataType, pattern);

                if (specifierMethod) {
                    if (verbatim.length) formatter[formatter.length] = Format.createVerbatimSpecifier(verbatim);

                    if (specifierMethod.specifier) {
                        for (let sx = 0; sx < specifierMethod.specifier.length; sx++)
                            formatter[formatter.length] = specifierMethod.specifier[sx];
                    } else
                        formatter[formatter.length] = Format.createFormatSpecifier(dataType, pattern, specifierMethod);

                    verbatim = '';
                    pattern = '';
                    previousPattern = null;
                    previousMatch = null;
                } else previousPattern = pattern;

                continue;
            }

            if (matchCount) {
                previousPattern = pattern;

                specifierMethod = Format.getMatchingSpecifierMethod(dataType, pattern);

                if (specifierMethod) previousMatch = pattern;

                continue;
            }

            if (previousPattern) {
                specifierMethod = Format.getMatchingSpecifierMethod(dataType, previousPattern);

                if (specifierMethod) {
                    if (verbatim.length) formatter[formatter.length] = Format.createVerbatimSpecifier(verbatim);

                    if (specifierMethod.specifier) {
                        for (let sx = 0; sx < specifierMethod.specifier.length; sx++)
                            formatter[formatter.length] = specifierMethod.specifier[sx];
                    } else
                        formatter[formatter.length] = Format.createFormatSpecifier(
                            dataType,
                            previousPattern,
                            specifierMethod,
                        );

                    pattern = pattern.slice(previousPattern.length);
                    verbatim = '';
                } else if (previousMatch) {
                    specifierMethod = Format.getMatchingSpecifierMethod(dataType, previousMatch);

                    if (verbatim.length) formatter[formatter.length] = Format.createVerbatimSpecifier(verbatim);

                    if (specifierMethod.specifier) {
                        for (let sx = 0; sx < specifierMethod.specifier.length; sx++)
                            formatter[formatter.length] = specifierMethod.specifier[sx];
                    } else
                        formatter[formatter.length] = Format.createFormatSpecifier(
                            dataType,
                            previousMatch,
                            specifierMethod,
                        );

                    pattern = pattern.slice(previousMatch.length);
                    verbatim = '';
                } else {
                    pattern = pattern.slice(previousPattern.length);
                    verbatim += previousPattern;
                }

                isNewChar = false;
                ix--;
                previousPattern = null;
                previousMatch = null;
                continue;
            }

            verbatim += pattern.charAt(0);
            pattern = pattern.slice(1);
            previousPattern = null;
        }

        //	alert("pattern = "+pattern+
        //	    "\npreviousPattern = "+previousPattern+
        //	    "\nverbatim = "+verbatim);

        if (previousPattern) {
            const innerSpecifierMethod = Format.getMatchingSpecifierMethod(dataType, previousPattern);

            if (innerSpecifierMethod) {
                if (verbatim.length) formatter[formatter.length] = Format.createVerbatimSpecifier(verbatim);

                if (innerSpecifierMethod.specifier) {
                    for (let sx = 0; sx < innerSpecifierMethod.specifier.length; sx++)
                        formatter[formatter.length] = innerSpecifierMethod.specifier[sx];
                } else
                    formatter[formatter.length] = Format.createFormatSpecifier(
                        dataType,
                        previousPattern,
                        innerSpecifierMethod,
                    );

                return formatter;
            }
        }

        verbatim += pattern;

        if (verbatim.length) formatter[formatter.length] = Format.createVerbatimSpecifier(verbatim);

        return formatter;
    },

    processFunction(ix, dataType, formatSpec, functionSpecifier) {
        let accum = '';
        let escapedChar = false;
        let escapedQuote = false;
        let hasQuote = false;
        let escaping = false;
        let isParameter = false;
        functionSpecifier.args = [];
        let argumentSpecifier = Format.createArgumentSpecifier();

        for (; ix < formatSpec.length; ix++) {
            const currentChar = formatSpec.charAt(ix);
            functionSpecifier.formatSpec += currentChar;

            const isNameChar = accum === '@' ? isNameStart(currentChar) : isName(currentChar);

            if (isParameter && currentChar !== '(' && !isNameChar) {
                const parametricName = Format.getParametricName(accum);

                if (parametricName)
                    argumentSpecifier[argumentSpecifier.length] = Format.createParameterSpecifier(parametricName);

                accum = '';
                isParameter = false;
            }

            if (escapedChar) {
                escapedChar = false;
            } else if (currentChar === '\\') {
                escapedChar = true;
                escaping = true;
                continue;
            } else if (escapedQuote) {
                if (currentChar === '"') {
                    escapedQuote = false;
                    escaping = false;
                    continue;
                }
            } else if (currentChar === '"') {
                hasQuote = true;
                escapedQuote = true;
                escaping = true;
                continue;
            } else if (escaping) {
                escaping = false;
            } else if (currentChar === ',') {
                const parametricName = isParameter ? Format.getParametricName(accum) : null;

                if (parametricName)
                    argumentSpecifier[argumentSpecifier.length] = Format.createParameterSpecifier(parametricName);
                else if (hasQuote || accum.length > 0)
                    argumentSpecifier[argumentSpecifier.length] = Format.createVerbatimSpecifier(accum);

                functionSpecifier.args[functionSpecifier.args.length] = argumentSpecifier;

                argumentSpecifier = Format.createArgumentSpecifier();

                accum = '';
                isParameter = false;
                hasQuote = false;
                continue;
            } else if (currentChar === '(') {
                const functionSpecifierMethod = Format.getFunctionSpecifierMethod(`${accum}(`);

                const nestedSpecifier = Format.createFormatSpecifier(dataType, `${accum}(`, functionSpecifierMethod);

                ix = Format.processFunction(ix + 1, dataType, formatSpec, nestedSpecifier);

                argumentSpecifier[argumentSpecifier.length] = nestedSpecifier;
                accum = '';
                isParameter = false;
                hasQuote = false;
                continue;
            } else if (currentChar === ')') {
                const parametricName = isParameter ? Format.getParametricName(accum) : null;

                if (parametricName)
                    argumentSpecifier[argumentSpecifier.length] = Format.createParameterSpecifier(parametricName);
                else if (hasQuote || accum.length > 0)
                    argumentSpecifier[argumentSpecifier.length] = Format.createVerbatimSpecifier(accum);

                functionSpecifier.args[functionSpecifier.args.length] = argumentSpecifier;

                return ix;
            } else if (currentChar === '@') {
                const parametricName = isParameter ? Format.getParametricName(accum) : null;

                if (parametricName)
                    argumentSpecifier[argumentSpecifier.length] = Format.createParameterSpecifier(parametricName);
                else if (hasQuote || accum.length > 0)
                    argumentSpecifier[argumentSpecifier.length] = Format.createVerbatimSpecifier(accum);

                accum = '';
                isParameter = true;
            } else if (isWhiteSpace(currentChar)) {
                continue;
            }

            // @ts-ignore
            argumentSpecifier.formatSpec += currentChar;
            accum += currentChar;
        }

        return formatSpec.length - 1;
    },

    getSpecifierMaps(dataType) {
        let specifierMaps = [];

        switch (dataType) {
            case 'datetime':
            case 'date':
                specifierMaps[specifierMaps.length] = Format.dateSpecifiers;
                break;
            case 'weekdays':
                specifierMaps[specifierMaps.length] = Format.weekdaySpecifiers;
                break;
            case 'time':
                specifierMaps[specifierMaps.length] = Format.timeSpecifiers;
                break;
            case 'timespan':
                specifierMaps[specifierMaps.length] = Format.timeSpanSpecifiers;
                break;
            case 'boolean':
                specifierMaps[specifierMaps.length] = Format.booleanSpecifiers;
                break;
            case 'number':
                specifierMaps[specifierMaps.length] = Format.numberSpecifiers;
                break;
            case 'percentage':
                specifierMaps[specifierMaps.length] = Format.percentageSpecifiers;
                specifierMaps[specifierMaps.length] = Format.numberSpecifiers;
                break;
            case 'currency':
                specifierMaps[specifierMaps.length] = Format.currencySpecifiers;
                specifierMaps[specifierMaps.length] = Format.numberSpecifiers;
                break;
            case 'speed':
                specifierMaps[specifierMaps.length] = Format.speedSpecifiers;
                specifierMaps = specifierMaps.concat(Format.getSpecifierMaps('measurement'));
                return specifierMaps;
            case 'distance':
                specifierMaps[specifierMaps.length] = Format.distanceSpecifiers;
                specifierMaps = specifierMaps.concat(Format.getSpecifierMaps('measurement'));
                return specifierMaps;
            case 'volume':
                specifierMaps[specifierMaps.length] = Format.volumeSpecifiers;
                specifierMaps = specifierMaps.concat(Format.getSpecifierMaps('measurement'));
                return specifierMaps;
            case 'pressure':
                specifierMaps[specifierMaps.length] = Format.pressureSpecifiers;
                specifierMaps = specifierMaps.concat(Format.getSpecifierMaps('measurement'));
                return specifierMaps;
            case 'acceleration':
                specifierMaps[specifierMaps.length] = Format.accelerationSpecifiers;
                specifierMaps = specifierMaps.concat(Format.getSpecifierMaps('measurement'));
                return specifierMaps;
            case 'temperature':
                specifierMaps[specifierMaps.length] = Format.temperatureSpecifiers;
                specifierMaps = specifierMaps.concat(Format.getSpecifierMaps('measurement'));
                return specifierMaps;
            case 'fueleconomy':
                specifierMaps[specifierMaps.length] = Format.fuelEconomySpecifiers;
                specifierMaps = specifierMaps.concat(Format.getSpecifierMaps('measurement'));
                return specifierMaps;
            case 'weight':
                specifierMaps[specifierMaps.length] = Format.weightSpecifiers;
                specifierMaps = specifierMaps.concat(Format.getSpecifierMaps('measurement'));
                return specifierMaps;
            case 'measurement':
                specifierMaps[specifierMaps.length] = Format.measurementSpecifiers;
                specifierMaps[specifierMaps.length] = Format.numberSpecifiers;
                break;
            case 'string':
                specifierMaps[specifierMaps.length] = Format.stringSpecifiers;
                break;
            default:
        }

        specifierMaps[specifierMaps.length] = Format.generalSpecifiers;

        return specifierMaps;
    },

    getMatchingSpecifierMethod(dataType, pattern) {
        const specifierMaps = Format.getSpecifierMaps(dataType);

        for (let ix = 0; ix < specifierMaps.length; ix++) {
            const specifiers = specifierMaps[ix];
            if (
                !specifiers[pattern] &&
                specifiers.lazyLoad_createParameterAlias &&
                specifiers.lazyLoad_createParameterAlias[pattern]
            )
                specifiers[pattern] = Format.createParameterAlias.apply(
                    window,
                    specifiers.lazyLoad_createParameterAlias[pattern],
                );

            const method = specifiers ? specifiers[pattern] : null;

            if (method) return method;
        }

        return null;
    },

    getPartialMatches(dataType, pattern) {
        const matches = [];

        const parametricName = Format.getParametricName(pattern);

        if (parametricName !== null) {
            // do not simplify this inequality
            for (const parameterSpecifier in Format.parameterSpecifiers)
                if (
                    Format.parameterSpecifiers.hasOwnProperty(parameterSpecifier) &&
                    parameterSpecifier.substr(0, parametricName.length) === parametricName
                )
                    matches[matches.length] = parameterSpecifier;

            for (const functionSpecifier in Format.functionSpecifiers)
                if (
                    Format.functionSpecifiers.hasOwnProperty(functionSpecifier) &&
                    functionSpecifier.substr(0, parametricName.length) === parametricName
                )
                    matches[matches.length] = functionSpecifier;

            return matches;
        }

        const specifierMaps = Format.getSpecifierMaps(dataType);

        for (let ix = 0, specifiers; ix < specifierMaps.length; ix++) {
            specifiers = specifierMaps[ix];

            for (const specifier in specifiers) {
                if (specifiers.hasOwnProperty(specifier) && specifier.substr(0, pattern.length) === pattern)
                    matches[matches.length] = specifier;
            }

            specifiers = specifierMaps[ix].lazyLoad_createParameterAlias;
            if (specifiers) {
                for (const specifier in specifiers) {
                    if (specifier.substr(0, pattern.length) === pattern) {
                        specifierMaps[ix][specifier] = Format.createParameterAlias.apply(window, specifiers[specifier]);
                        delete specifierMaps[ix].lazyLoad_createParameterAlias[specifier];
                        matches[matches.length] = specifier;
                    }
                }
            }
        }

        return matches;
    },

    getParametricName(pattern) {
        if (pattern.charAt(0) !== '@') return null;

        return pattern.slice(1);
    },

    getFunctionName(pattern) {
        if (pattern.charAt(0) !== '@') return null;

        if (pattern.charAt(pattern.length - 1) !== '(') return null;

        return pattern.substring(1, pattern.length - 1);
    },

    getFunctionSpecifierMethod(pattern) {
        const functionName = Format.getFunctionName(pattern);

        if (!functionName) return null;

        return Format.functionSpecifiers[functionName];
    },

    formatterMethod(value) {
        let out = '';

        if (value == null) return out;

        this.context = [];

        for (this.ix = 0; this.ix < this.specifier.length; this.ix++) {
            const context = {};
            context.parent = this;
            this.context[this.ix] = context;
            context.dataType = this.dataType;
            context.localeContext = this.localeContext;
            context.getLocaleArray = this.getLocaleArray;
            context.getLocaleValue = this.getLocaleValue;
            context.specifier = this.specifier[this.ix];
            context.output = context.specifier.format.call(context, value);
            out += context.output;
        }
        // TODO ideally this should be moved out to a format function like measurement but it does seem more like a global requirement so here seems like a good fit. Move if we ever need to not apply this.
        return out === '-0' ? '0' : out;
    },

    specifierMethod(value) {
        if (this.specifier.args && this.specifier.method) {
            let args = [value];

            for (this.ix = 0; this.ix < this.specifier.args.length; this.ix++) {
                const argSpec = this.specifier.args[this.ix];
                const context = {};
                context.parent = this;
                context.dataType = this.dataType;
                context.localeContext = this.localeContext;
                context.getLocaleArray = this.getLocaleArray;
                context.getLocaleValue = this.getLocaleValue;
                context.specifier = argSpec;

                const argValue = argSpec.format.call(context, value);

                args = args.concat(argValue);
            }

            return this.specifier.method.apply(this, args);
        } else if (this.specifier.method) {
            return this.specifier.method.call(this, value);
        } else if (this.specifier.parameter) {
            return Format.param_getParameterValue.call(this, value, this.specifier.parameter);
        } else if (this.specifier.specifier) {
            return this.specifier.specifier.format.call(this, value);
        } else if (this.specifier.value) {
            return this.specifier.value;
        }

        return '';
    },

    getMeasurementFactor(dataType, uom) {
        return Format.measurementFactors[dataType][uom];
    },

    // the localeContext can either be an element (to lookup locale attributes),
    // or a map of locale attribute names vs locale attribute values
    getFormatter(localeContext, dataType, formatSpec) {
        let dataFormatters = Format.formatters[dataType];

        if (!dataFormatters) {
            Format.formatters[dataType] = [];
            dataFormatters = Format.formatters[dataType];
        }

        let dataFormatter = dataFormatters[formatSpec];

        if (!dataFormatter) {
            dataFormatter = Format.createFormatter(dataType, formatSpec);
            dataFormatters[formatSpec] = dataFormatter;
        }

        const context = {};
        context.format = Format.context_callFormatter;
        context.specifier = dataFormatter;
        context.dataType = dataType;
        context.localeContext = localeContext;
        context.getLocaleArray = Parse.getLocaleArray;
        context.getLocaleValue = Parse.getLocaleValue;

        return context;
    },

    context_callFormatter(value) {
        return this.specifier.format.call(this, value);
    },

    // specifiers

    createArgumentSpecifier() {
        const argumentSpecifier = [];
        // @ts-ignore
        argumentSpecifier.formatSpec = '';
        // @ts-ignore
        argumentSpecifier.format = Format.formatterMethod;
        return argumentSpecifier;
    },

    createVerbatimSpecifier(text) {
        const formatSpecifier = {};
        formatSpecifier.format = Format.specifierMethod;
        formatSpecifier.value = text;

        return formatSpecifier;
    },

    createParameterSpecifier(parameterName) {
        const formatSpecifier = {};
        formatSpecifier.format = Format.specifierMethod;
        formatSpecifier.parameter = parameterName;

        return formatSpecifier;
    },

    createFormatSpecifier(dataType, formatSpec, basis) {
        const formatSpecifier = {};
        formatSpecifier.format = Format.specifierMethod;
        formatSpecifier.formatSpec = formatSpec;

        if (basis == null) basis = formatSpec;

        if (typeof basis === 'function') {
            formatSpecifier.method = basis;
        } else if (typeof basis === 'object') {
            if (basis.specifier) formatSpecifier.specifier = basis.specifier;
            else formatSpecifier.specifier = basis;
        } else if (typeof basis === 'string') {
            formatSpecifier.specifier = Format.createFormatter(dataType, basis);
        }

        return formatSpecifier;
    },

    callSpecifier(specifier, value) {
        const context = {};
        context.specifier = specifier;
        return context.specifier.format.call(context, value);
    },

    // in function context helpers

    // get the current rendering context node's sibling index within it's parent context node
    getSiblingIndex(context) {
        return context.parent.ix;
    },

    // get the current rendering context node's sibling count within it's parent context node
    getSiblingCount(context) {
        return context.parent.specifier.length;
    },

    // test if the given rendering context node is the last repetition within its group
    isLastSpecifierRepetition(context) {
        const contextMethod = context.specifier.method;
        const nextSpecifier = Format.getSiblingSpecifier(context, Format.getSiblingIndex(context) + 1);

        return !nextSpecifier || nextSpecifier.method !== contextMethod;
    },

    // gets the repetition count for the given rendering context node
    // if the node is the last one within a group - it will be the group count
    getSpecifierRepetitionCount(context) {
        const contextMethod = context.specifier.method;
        let count = 1;

        for (let ix = Format.getSiblingIndex(context) - 1; ix > -1; ix--) {
            if (Format.getSiblingSpecifier(context, ix).method === contextMethod) count++;
            else break;
        }

        return count;
    },

    getSpecifierRepetitionCountFromStartIndex(context, startIndex, reverse) {
        const contextMethod = Format.getSiblingSpecifier(context, startIndex).method;
        const siblingCount = Format.getSiblingCount(context);
        const increment = reverse ? -1 : 1;
        let count = 1;

        for (let ix = startIndex + increment; ix > -1 && ix < siblingCount; ix += increment) {
            if (Format.getSiblingSpecifier(context, ix).method === contextMethod) count++;
            else break;
        }

        return count;
    },

    // get the specifier of the sibling at the given index
    // if the given index is the same as the current one, it will return the current specifier
    getSiblingSpecifier(context, index) {
        return context.parent.specifier[index];
    },

    // get the context of the sibling at the specified index (if the context has already been created)
    getSiblingContext(context, index) {
        return context.parent.context[index];
    },

    // get the index of the next sibling with the specified method, starting from the index of the given node
    // optionally, from a specified starting index
    // optionally, seeking in reverse
    seekSiblingIndex(context, method, startIndex, reverse) {
        startIndex = startIndex == null ? Format.getSiblingIndex(context) : startIndex;
        const siblingCount = Format.getSiblingCount(context);
        const increment = reverse ? -1 : 1;

        for (let ix = startIndex + increment; ix > -1 && ix < siblingCount; ix += increment) {
            if (Format.getSiblingSpecifier(context, ix).method === method) return ix;
        }
        return undefined;
    },

    // gets the repetition position of the given specifier within its siblings
    getSiblingPosition(context) {
        const contextMethod = context.specifier.method;
        const endIndex = Format.getSiblingIndex(context);
        const siblingCount = Format.getSiblingCount(context);
        let position = 0;

        for (let ix = 0; ix < siblingCount && ix < endIndex; ix++) {
            if (Format.getSiblingSpecifier(context, ix).method === contextMethod) position++;
        }

        return position;
    },

    param_getParameter(parameterName) {
        return parameterName ? Format.parameterSpecifiers[parameterName] : null;
    },

    param_getParameterValue(value, parameterName) {
        const parameter = Format.param_getParameter(parameterName);

        if (parameter && typeof parameter === 'object') {
            if (parameter.args && parameter.method) {
                let args = [value];

                for (let ix = 0; ix < parameter.args.length; ix++) {
                    const argSpec = parameter.args[ix];
                    const argValue = argSpec.format(value);
                    args = args.concat(argValue);
                }

                return parameter.method(...args);
            } else if (parameter.method) {
                return parameter.method(value);
            } else if (parameter.value) {
                return parameter.value;
            } else if (parameter.path) {
                // todo: get an arbitrary attribute from the DOM
            } else if (parameter.specifier) {
                return parameter.specifier.format(value);
            }
        } else if (parameter && typeof parameter === 'function') {
            return parameter.call(this, value);
        } else if (parameter) {
            return parameter;
        }

        return '';
    },
};

// Format Specifiers

export const FormatSpecifier = {
    date_getShortYearText(date) {
        return FormatSpecifier.date_getISOYearText(date).slice(2);
    },

    date_getISOYearText(date) {
        return date.getFullYear().toString().padStart(4, '0');
    },

    date_getMonthText(date) {
        return String(date.getMonth() + 1);
    },

    date_getISOMonthText(date) {
        return (date.getMonth() + 1).toString().padStart(2, '0');
    },

    date_getMediumMonthText(date) {
        const months = this.getLocaleArray('localeMonthsMedium');
        return months[date.getMonth()];
    },

    date_getLongMonthText(date) {
        const months = this.getLocaleArray('localeMonthsLong');
        return months[date.getMonth()];
    },

    date_getShortMonthText(date) {
        const months = this.getLocaleArray('localeMonthsShort');
        return months[date.getMonth()];
    },

    date_getDayText(date) {
        return String(date.getDate());
    },

    date_getISODayText(date) {
        return date.getDate().toString().padStart(2, '0');
    },

    date_getShortWeekdayText(date) {
        const weekdays = this.getLocaleArray('localeWeekdaysShort');
        return weekdays[date.getDay()];
    },

    date_getMediumWeekdayText(date) {
        const weekdays = this.getLocaleArray('localeWeekdaysMedium');
        return weekdays[date.getDay()];
    },

    date_getLongWeekdayText(date) {
        const weekdays = this.getLocaleArray('localeWeekdaysLong');
        return weekdays[date.getDay()];
    },

    date_getHoursText(date) {
        let hours = date.getHours();

        if (hours > 12) hours -= 12;
        else if (hours === 0) hours = 12;

        return String(hours);
    },

    date_getPaddedHoursText(date) {
        let hours = date.getHours();

        if (hours > 12) hours -= 12;
        else if (hours === 0) hours = 12;

        return hours.toString().padStart(2, '0');
    },

    date_getMilitaryHoursText(date) {
        return String(date.getHours());
    },

    date_getISOHoursText(date) {
        return date.getHours().toString().padStart(2, '0');
    },

    date_getMinutesText(date) {
        return String(date.getMinutes());
    },

    date_getISOMinutesText(date) {
        return `${date.getMinutes()}`.padStart(2, '0');
    },

    date_getSecondsText(date) {
        return String(date.getSeconds());
    },

    date_getISOSecondsText(date) {
        return `${date.getSeconds()}`.padStart(2, '0');
    },

    date_getCentiSecondsText(date) {
        const centiSeconds = date.getMilliseconds() / 10;
        return `${Math.round(centiSeconds)}`.padStart(2, '0');
    },

    date_getMilliSecondsText(date) {
        return `${date.getMilliseconds()}`.padStart(3, '0');
    },

    date_getAMPMText(date) {
        return date.getHours() > 11 ? 'PM' : 'AM';
    },

    date_getAPText(date) {
        return date.getHours() > 11 ? 'P' : 'A';
    },

    date_getDayOrdinalText(date) {
        const day = date.getDate();
        const dayOrdinals = this.getLocaleArray('localeDayOrdinals');
        let ordinal = '';

        for (let ix = 0; ix < dayOrdinals.length; ix += 2) {
            if (dayOrdinals[ix] > day) break;

            ordinal = dayOrdinals[ix + 1];
        }

        return ordinal;
    },

    date_getMonthOrdinalText(date) {
        const month = date.getMonth() + 1;
        const monthOrdinals = this.getLocaleArray('localeMonthOrdinals');
        let ordinal = '';

        for (let ix = 0; ix < monthOrdinals.length; ix += 2) {
            if (monthOrdinals[ix] > month) break;

            ordinal = monthOrdinals[ix + 1];
        }

        return ordinal;
    },

    date_getMillis(date) {
        return `${date.getTime()}`;
    },

    time_getElapsedDaysText(offsetSeconds) {
        const offsetDays = (offsetSeconds - offsetSeconds % 86400) / 86400;
        return String(Math.abs(offsetDays));
    },

    time_getElapsedHours(offsetSeconds) {
        const offsetHours = (offsetSeconds - offsetSeconds % 3600) / 3600;
        return Math.abs(offsetHours);
    },

    time_getElapsedMinutesText(offsetSeconds) {
        const offsetMinutes = (offsetSeconds - offsetSeconds % 60) / 60;
        return String(Math.abs(offsetMinutes));
    },

    time_getElapsedSecondsText(offsetSeconds) {
        return String(Math.abs(offsetSeconds));
    },

    time_getDays(offsetSeconds) {
        const absSeconds = Math.abs(offsetSeconds);
        const offsetDays = (absSeconds - absSeconds % 86400) / 86400;

        return absSeconds < 0 ? offsetDays - 1 : offsetDays;
    },

    time_getMilitaryHours(offsetSeconds) {
        const absSeconds = Math.abs(offsetSeconds);
        const offsetHours = (absSeconds - absSeconds % 3600) / 3600;

        return absSeconds < 0 ? 24 + offsetHours % 24 : offsetHours % 24;
    },

    time_getHours(offsetSeconds) {
        const hours = FormatSpecifier.time_getMilitaryHours(offsetSeconds);

        if (hours > 12) return hours - 12;

        if (hours === 0) return 12;

        return hours;
    },

    time_getMinutes(offsetSeconds) {
        const absSeconds = Math.abs(offsetSeconds);
        const offsetMinutes = (absSeconds - absSeconds % 60) / 60;

        return absSeconds < 0 ? 60 + offsetMinutes % 60 : offsetMinutes % 60;
    },

    time_getSeconds(offsetSeconds) {
        const absSeconds = Math.abs(offsetSeconds);
        return absSeconds < 0 ? 60 + absSeconds % 60 : absSeconds % 60;
    },

    time_getDaysText(offsetSeconds) {
        return String(FormatSpecifier.time_getDays(offsetSeconds));
    },

    time_getHoursText(offsetSeconds) {
        return String(FormatSpecifier.time_getHours(offsetSeconds));
    },

    time_getMilitaryHoursText(offsetSeconds) {
        return String(FormatSpecifier.time_getMilitaryHours(offsetSeconds));
    },

    time_getElapsedHoursText(offsetSeconds) {
        const padding = this.specifier.formatSpec.length - 2;
        return `${FormatSpecifier.time_getElapsedHours(offsetSeconds)}`.padStart(padding, '0');
    },

    time_getElapsedHoursAsDouble(offsetSeconds) {
        if (!offsetSeconds) return '0.00';
        let result = `${Math.round(offsetSeconds / 3600 * 100) / 100}`;
        if (result.indexOf('.') === -1) result += '.';
        while (result.charAt(result.length - 3) !== '.') result += '0';
        return result;
    },

    time_getPaddedHoursText(offsetSeconds) {
        return `${FormatSpecifier.time_getHours(offsetSeconds)}`.padStart(2, '0');
    },

    time_getISOHoursText(offsetSeconds) {
        return `${FormatSpecifier.time_getMilitaryHours(offsetSeconds)}`.padStart(2, '0');
    },

    time_getMinutesText(offsetSeconds) {
        return String(FormatSpecifier.time_getMinutes(offsetSeconds));
    },

    time_getISOMinutesText(offsetSeconds) {
        return `${FormatSpecifier.time_getMinutes(offsetSeconds)}`.padStart(2, '0');
    },

    time_getAsMinutesText(offsetSeconds) {
        const absSeconds = Math.abs(offsetSeconds);
        return (absSeconds - absSeconds % 60) / 60;
    },

    time_getSecondsText(offsetSeconds) {
        return String(FormatSpecifier.time_getSeconds(offsetSeconds));
    },

    time_getISOSecondsText(offsetSeconds) {
        return `${FormatSpecifier.time_getSeconds(Math.floor(offsetSeconds))}`.padStart(2, '0');
    },

    time_getCentiSecondsText(offsetSeconds) {
        const millis = offsetSeconds % 1;
        const centiSeconds = millis * 1000 / 10;
        return `${Math.round(centiSeconds)}`.padStart(2, '0');
    },

    time_getMilliSecondsText(offsetSeconds) {
        const millis = offsetSeconds % 1;
        return `${Math.round(millis * 1000)}`.padStart(3, '0');
    },

    time_getHourRemainderText(offsetSeconds) {
        const remainder = offsetSeconds % 3600;
        return remainder ? '+' : '';
    },

    time_getMinuteRemainderText(offsetSeconds) {
        const remainder = offsetSeconds % 60;
        return remainder ? '+' : '';
    },

    time_getAMPMText(offsetSeconds) {
        const hours = FormatSpecifier.time_getMilitaryHours(offsetSeconds);

        if (hours > 11) return 'PM';

        return 'AM';
    },

    time_getAMPMXText(offsetSeconds) {
        const hours = FormatSpecifier.time_getElapsedHours(offsetSeconds);

        if (hours > 23) return 'X';

        return FormatSpecifier.time_getAMPMText(offsetSeconds);
    },

    time_getAPText(offsetSeconds) {
        const hours = FormatSpecifier.time_getMilitaryHours(offsetSeconds);

        if (hours > 11) return 'P';

        return 'A';
    },

    time_getAPXText(offsetSeconds) {
        const hours = FormatSpecifier.time_getElapsedHours(offsetSeconds);

        if (hours > 23) return 'X';

        return FormatSpecifier.time_getAPText(offsetSeconds);
    },

    number_getConditionalSignText(number) {
        return number < 0 ? '-' : '';
    },

    number_getSignText(number) {
        return number < 0 ? '-' : '+';
    },

    number_getConditionalSignBracket(number) {
        return number < 0 ? this.specifier.formatSpec : '';
    },

    number_getIntegerText(number) {
        if (!Format.isLastSpecifierRepetition(this)) return '';

        const repetition = Format.getSpecifierRepetitionCount(this);
        const currentSpecifierIndex = Format.getSiblingIndex(this);
        const separator = Format.getSiblingSpecifier(this, currentSpecifierIndex - repetition);
        const isDecimalPart = !!separator && separator.method === FormatSpecifier.func_separator;
        let decimalPlaces = isDecimalPart ? repetition : 0;

        // currently not dealing with the fractional portion of the number,
        // so the number of decimal places is retrieved to correctly round the number
        if (!isDecimalPart) {
            const separatorIndex = Format.seekSiblingIndex(this, FormatSpecifier.func_separator, currentSpecifierIndex);
            if (separatorIndex !== undefined && separatorIndex + 1 < Format.getSiblingCount(this))
                decimalPlaces = Format.getSpecifierRepetitionCountFromStartIndex(this, separatorIndex + 1);
        }

        // scale up number to round it to the number of decimal places specified in the format,
        // then turned into an absolute number because the sign is handled by a previous formatter,
        // then turn it into a string to extract parts of the number without concern for rounding errors,
        // if the extracted whole number results in an empty string, it becomes a 0
        // note that the number is turned into an absolute number after rounding, so that it is rounded correctly
        // @ts-ignore
        const result = Math.abs(Math.round(`${number}e${decimalPlaces}`)).toString();
        const startIndex = result.length - decimalPlaces;
        return isDecimalPart
            ? startIndex < 0
                ? '0'.padEnd(Math.abs(startIndex), '0') + result
                : result.substring(startIndex)
            : result.substring(0, startIndex) || '0';
    },

    number_getZeroPaddedText(number) {
        if (!Format.isLastSpecifierRepetition(this)) return '';

        const repetitions = Format.getSpecifierRepetitionCount(this);
        return `${Math.floor(Math.abs(number))}`.padStart(repetitions, '0');
    },

    number_getNoneZeroPaddedText(number) {
        if (!Format.isLastSpecifierRepetition(this)) return '';

        const repetitions = Format.getSpecifierRepetitionCount(this);
        return `${Math.floor(Math.abs(number))}`.padStart(repetitions, '0').toString();
    },

    number_getSpacePaddedText(number) {
        if (!Format.isLastSpecifierRepetition(this)) return '';

        const repetitions = Format.getSpecifierRepetitionCount(this);

        return `${Math.floor(Math.abs(number))}`.padStart(repetitions, ' ');
    },

    number_getText(number) {
        return `${number}`;
    },

    percentage_getIntegerText(percentage) {
        return FormatSpecifier.number_getIntegerText.call(this, percentage * 100);
    },

    percentage_getZeroPaddedText(percentage) {
        return FormatSpecifier.number_getZeroPaddedText.call(this, percentage * 100);
    },

    percentage_getNoneZeroPaddedText(percentage) {
        return FormatSpecifier.number_getNoneZeroPaddedText.call(this, percentage * 100);
    },

    percentage_getSpacePaddedText(percentage) {
        return FormatSpecifier.number_getSpacePaddedText.call(this, percentage * 100);
    },

    measurement_getIntegerText(measurement) {
        const converted = Format.convertMeasurement.call(this, measurement);

        return FormatSpecifier.number_getIntegerText.call(this, converted);
    },

    measurement_getConditionalSignText(measurement) {
        const converted = Format.convertMeasurement.call(this, measurement);

        return FormatSpecifier.number_getConditionalSignText.call(this, converted);
    },

    measurement_getSignText(measurement) {
        const converted = Format.convertMeasurement.call(this, measurement);

        return FormatSpecifier.number_getSignText.call(this, converted);
    },

    measurement_getConditionalSignBracket(measurement) {
        const converted = Format.convertMeasurement.call(this, measurement);

        return FormatSpecifier.number_getConditionalSignBracket.call(this, converted);
    },

    measurement_getZeroPaddedText(
        measurement, // todo: add units support
    ) {
        const factor = 1;

        return FormatSpecifier.number_getZeroPaddedText.call(this, measurement * factor); // todo: add units support
    },

    measurement_getNoneZeroPaddedText(measurement) {
        const factor = 1;
        // @ts-ignore
        return FormatSpecifier.number_getNoneZeroPaddedText.call(this, measurement * factor);
    },

    measurement_getSpacePaddedText(measurement) {
        const factor = 1;

        return FormatSpecifier.number_getSpacePaddedText.call(this, measurement * factor);
    },

    string_getUpperCase(text) {
        return text && text.toUpperCase ? text.toUpperCase() : text;
    },

    string_getLowerCase(text) {
        return text && text.toLowerCase ? text.toLowerCase() : text;
    },

    string_getFirstCapitalized(text) {
        const output = text.toLowerCase();

        return output.substr(0, 1).toUpperCase() + output.substr(1);
    },

    string_getAllCapitalized(text) {
        const words = text.split(' ');

        for (let ix = 0; ix < words.length; ix++) words[ix] = FormatSpecifier.string_getFirstCapitalized(words[ix]);

        return words.join(' ');
    },

    string_getLowerCamelCase(text) {
        const words = text.split(' ');

        words[0] = words[0] ? words[0].toLowerCase() : words[0];

        for (let ix = 1; ix < words.length; ix++) words[ix] = FormatSpecifier.string_getFirstCapitalized(words[ix]);

        return words.join('');
    },

    string_getUpperCamelCase(text) {
        const words = text.split(' ');

        for (let ix = 0; ix < words.length; ix++) words[ix] = FormatSpecifier.string_getFirstCapitalized(words[ix]);

        return words.join('');
    },

    string_getVerbatimText(text) {
        return text;
    },

    boolean_getYNText(bit) {
        const booleans = this.getLocaleArray('localeBooleanYesNoShort');
        return booleans[bit ? 0 : 1];
    },

    boolean_getYesNoText(bit) {
        const booleans = this.getLocaleArray('localeBooleanYesNoLong');
        return booleans[bit ? 0 : 1];
    },

    boolean_getTFText(bit) {
        const booleans = this.getLocaleArray('localeBooleanTrueFalseShort');
        return booleans[bit ? 0 : 1];
    },

    boolean_getTrueFalseText(bit) {
        const booleans = this.getLocaleArray('localeBooleanTrueFalseLong');
        return booleans[bit ? 0 : 1];
    },

    boolean_gettruefalseText(bit) {
        const booleans = this.getLocaleArray('localeBooleanTrueFalseLong');
        return booleans[bit ? 0 : 1].toLowerCase();
    },

    boolean_getOXText(bit) {
        const booleans = this.getLocaleArray('localeBooleanOnOffShort');
        return booleans[bit ? 0 : 1];
    },

    boolean_getOnOffText(bit) {
        const booleans = this.getLocaleArray('localeBooleanOnOffLong');
        return booleans[bit ? 0 : 1];
    },

    boolean_getonoffText(bit) {
        const booleans = this.getLocaleArray('localeBooleanOnOffLong');
        return booleans[bit ? 0 : 1].toLowerCase();
    },

    boolean_getMarkText(bit) {
        const booleans = this.getLocaleArray('localeBooleanMark');
        return booleans[bit ? 0 : 1];
    },

    boolean_getRawText(bit) {
        return String(bit ? 1 : 0);
    },

    func_render(value, formatSpecifier) {
        const formatter = Format.getFormatter(this.localeContext, this.dataType, formatSpecifier);
        return formatter.format(value);
    },

    // func_each is used where a spec is made up of repeating single characters
    // func_each operates on a string and takes a dataType and a formatSpecifier
    // the dataType and formatSpecifier are applied to the character offset in the text that matched the offset

    func_each(value, dataType, formatSpecifier) {
        const text = String(value);
        const pos = Format.getSiblingPosition(this);
        const inputText = text.charAt(pos);

        const standardParser = Parse.getParser(this.localeContext, dataType, Parse.STANDARD);
        value = standardParser.parse(inputText);

        const formatter = Format.getFormatter(this.localeContext, dataType, formatSpecifier);
        formatter.pos = pos;
        return formatter.format(value);
    },

    // similar to each, except it works on weekdays and takes a firstDOW argument,
    // the inside format assumes a boolean datatype

    func_eachDOW(text, firstDOW, formatSpecifier, pos) {
        pos = pos !== undefined ? pos : Format.getSiblingPosition(this);

        if (pos > 6) return '';

        const dow = (pos + Number(firstDOW)) % 7;
        const dayValue = text.charAt(dow);

        const formatter = Format.getFormatter(this.localeContext, 'boolean', formatSpecifier);
        formatter.pos = pos;
        formatter.dow = dow;
        return formatter.format(dayValue !== '0');
    },

    func_weekdays(text, firstDOW, formatSpecifier) {
        if (this.specifier.formatSpec === Format.STANDARD) this.specifier.formatSpec = '@weekdays(0,0)';
        const formatSpec = Format.getFormatter(this.localeContext, 'weekdays', formatSpecifier).specifier[0].formatSpec;
        let result = '';
        for (let pos = 0; pos < text.length; pos++)
            result += FormatSpecifier.func_eachDOW.call(this, text, firstDOW, formatSpec, pos);

        return result;
    },

    // gets the position index of the containing specifier within its parent
    // not fully utilized - I think it was meant to be used to help define some of the more complicated functions
    // that have to vary behavior by position
    func_parentSiblingIndex(value, depth) {
        const targetDepth = depth != null && depth !== '' ? Number(depth) : -1;
        let currentDepth = 0;

        let currentContext = this;
        let siblingIndex = Format.getSiblingIndex(currentContext);

        while (currentDepth !== targetDepth) {
            if (currentContext.parent && currentContext.parent.parent) {
                currentContext = currentContext.parent.parent;
                siblingIndex = Format.getSiblingIndex(currentContext);
                currentDepth++;
            } else if (targetDepth < 0) {
                return siblingIndex;
            } else {
                return -1;
            }
        }

        return siblingIndex;
    },

    // func_booleanText operates on a boolean and takes a pair of arguments
    // if the boolean is true, it returns the first argument, otherwise the second
    func_booleanText(bit, onValue, offValue) {
        return String(bit ? onValue : offValue);
    },

    // func_enumText operates on a number and takes a list of arguments
    // the number it operates on selects the argument from the list
    func_enumText(number) {
        number = typeof number === 'string' ? toNumber(number) : Number(number);
        let index = Math.max(number.toFixed(), 0) + 1;
        index = Math.min(index, arguments.length - 1);
        return arguments[index];
    },

    func_measurement(
        value,
        displayText,
        unitSpecifier,
        visibility,
        alternateText, // todo: check that the unitSpecifier is correct for the this.dataType
    ) {
        visibility = visibility || 0;
        const hide = 1;
        const segmented = 2;
        const nonzero = 4;
        const singlezero = 8;
        const zeronotblank = 16;
        const noLeadingZeroIfNoPrev = 32;
        const blankIfZeroAndHasPrevContext = 64;
        if (visibility & hide || this.getLocaleValue('localeFormatHideUnits') === 'true') return '';

        if (!Format.measurementUnits[this.dataType].includes(unitSpecifier)) return '';

        if (visibility & blankIfZeroAndHasPrevContext) {
            if (displayText.match(/^[0:]+$/)) {
                const prevContext = Format.getSiblingContext(
                    this,
                    Format.seekSiblingIndex(this, FormatSpecifier.func_measurement, null, true),
                );
                if (prevContext && prevContext.output.length) return '';
            }
        }

        if (visibility & segmented) {
            const prevContext = Format.getSiblingContext(
                this,
                Format.seekSiblingIndex(this, FormatSpecifier.func_measurement, null, true),
            );

            const factor = Format.getMeasurementFactor(this.dataType, unitSpecifier);
            let offset = Format.measurementOffsets[unitSpecifier];

            if (!offset) offset = 0;

            let working = value * factor - offset;

            const postFunction = Format.measurementPostFunction[unitSpecifier];

            if (postFunction) working = postFunction(working);

            if ((!prevContext || prevContext.output.length) && Math.floor(Math.abs(working)) < 1) return '';

            return prevContext && prevContext.output.length ? displayText : alternateText || '';
        }

        if (visibility & nonzero) {
            const factor = Format.getMeasurementFactor(this.dataType, unitSpecifier);
            let offset = Format.measurementOffsets[unitSpecifier];

            if (!offset) offset = 0;

            if (Math.floor(Math.abs(value * factor - offset)) < 1) return alternateText || '';
        }

        if (visibility & singlezero && displayText.match(/^0+$/)) return '0';

        if (visibility & zeronotblank && value === 0) return '0';

        if (visibility & noLeadingZeroIfNoPrev) {
            const prevContext = Format.getSiblingContext(
                this,
                Format.seekSiblingIndex(this, FormatSpecifier.func_measurement, null, true),
            );
            if ((!prevContext || !prevContext.output.length) && displayText) return displayText.replace(/^0+/g, '');
        }

        return displayText;
    },

    // just returns the verbatim unitSpecifier (or null)
    // it is used to add units to the output text
    // and to modify (multiply) the numeric values in measurement specifiers
    // by the unit's corresponding measuremnt factor
    func_units(
        value,
        unitSpecifier,
        visibility, // todo: check that the unitSpecifier is correct for the this.dataType
    ) {
        if ((visibility && visibility === 'hide') || this.getLocaleValue('localeFormatHideUnits') === 'true') return '';

        if (!Format.measurementUnits[this.dataType].includes(unitSpecifier)) return '';

        return unitSpecifier;
    },

    // func_separator is a sibling method pulled in as needed by another function such as number_getIntegerText
    // it modifies how its contained method operates
    func_separator(value, separatorSpecifier) {
        return separatorSpecifier == null ? '' : separatorSpecifier;
    },

    // func_format operates on a value and takes two formatSpecifiers and a dataType as arguments
    // the first specifier applies to the value being operated on (whatever type it is)
    // the dataType will be used to parse the text output of the first specifier to an intermediate value
    // which will then be formatted by the second specifier
    func_format(value, valueFormatSpecifier, dataType, dataFormatSpecifier) {
        let formatter = Format.getFormatter(this.localeContext, this.dataType, valueFormatSpecifier);
        const inputText = formatter.format(value);

        const standardParser = Parse.getParser(this.localeContext, dataType, Parse.STANDARD);
        const intermediateValue = standardParser.parse(inputText);

        formatter = Format.getFormatter(this.localeContext, dataType, dataFormatSpecifier);
        return formatter.format(intermediateValue);
    },

    func_fdow(value) {
        return this.getLocaleValue('localeFirstDOW');
    },

    func_pos(value) {
        let workingContext = this;

        while (workingContext) {
            if (workingContext.pos == null) {
                workingContext = workingContext.parent;
                continue;
            }

            return workingContext.pos + 1;
        }

        return '';
    },

    func_dowAbstract(value, weekdayPatterName) {
        const weekdays = this.getLocaleArray(weekdayPatterName);

        let workingContext = this;

        while (workingContext) {
            if (workingContext.dow == null) {
                workingContext = workingContext.parent;
                continue;
            }

            return weekdays[workingContext.dow];
        }

        return '';
    },

    func_dow(value) {
        return FormatSpecifier.func_dowAbstract.call(this, value, 'localeWeekdaysShort');
    },

    func_dowu(value) {
        return FormatSpecifier.func_dowAbstract.call(this, value, 'localeWeekdaysShortUnique');
    },

    // --- functions for testing the formatting framework
    func_funcText(value, param1, param2) {
        return `<func param1=${param1} param2=${param2}>`;
    },

    func_testText(value, param1) {
        return `<test param1=${param1}>`;
    },
};

// ---

Format.functionSpecifiers = {
    func: FormatSpecifier.func_funcText,
    test: FormatSpecifier.func_testText,
    separator: FormatSpecifier.func_separator,
    units: FormatSpecifier.func_units,
    render: FormatSpecifier.func_render,
    measurement: FormatSpecifier.func_measurement,
    boolean: FormatSpecifier.func_booleanText,
    enum: FormatSpecifier.func_enumText,
    each: FormatSpecifier.func_each,
    eachdow: FormatSpecifier.func_eachDOW,
    weekdays: FormatSpecifier.func_weekdays,
    psi: FormatSpecifier.func_parentSiblingIndex,
    format: FormatSpecifier.func_format,
};

Format.parameterSpecifiers = {
    user: 'Bert',
    par: 'param content',
    decimal: '.',
    euro: '\u20AC',
    space: ' ',
    symbol: '\u20AC',
    subsymbol: '\u00A2',
    percent: '%',
    fdow: FormatSpecifier.func_fdow, // first day of week
    dow: FormatSpecifier.func_dow, // day of week in weekday template
    dowu: FormatSpecifier.func_dowu, // day of week in unique weekday template
    pos: FormatSpecifier.func_pos, // position in a @each call
    // bar:		Format.createParameterAlias("@test(@par)")
};

// internal format is a Date object
Format.dateSpecifiers = {
    yy: FormatSpecifier.date_getShortYearText,
    yyyy: FormatSpecifier.date_getISOYearText,
    M: FormatSpecifier.date_getMonthText,
    MM: FormatSpecifier.date_getISOMonthText,
    MMM: FormatSpecifier.date_getMediumMonthText,
    MMMM: FormatSpecifier.date_getLongMonthText,
    MMMMM: FormatSpecifier.date_getShortMonthText,
    d: FormatSpecifier.date_getDayText,
    dd: FormatSpecifier.date_getISODayText,
    ddd: FormatSpecifier.date_getMediumWeekdayText,
    dddd: FormatSpecifier.date_getLongWeekdayText,
    ddddd: FormatSpecifier.date_getShortWeekdayText,
    h: FormatSpecifier.date_getHoursText,
    hh: FormatSpecifier.date_getPaddedHoursText,
    H: FormatSpecifier.date_getMilitaryHoursText,
    HH: FormatSpecifier.date_getISOHoursText,
    m: FormatSpecifier.date_getMinutesText,
    mm: FormatSpecifier.date_getISOMinutesText,
    s: FormatSpecifier.date_getSecondsText,
    ss: FormatSpecifier.date_getISOSecondsText,
    '00': FormatSpecifier.date_getCentiSecondsText,
    '000': FormatSpecifier.date_getMilliSecondsText,
    APM: FormatSpecifier.date_getAMPMText,
    AP: FormatSpecifier.date_getAPText,
    dth: FormatSpecifier.date_getDayOrdinalText,
    mth: FormatSpecifier.date_getMonthOrdinalText,
    MILLIS: FormatSpecifier.date_getMillis,

    lazyLoad_createParameterAlias: {
        apm: ['@format("APM",string, "L" )', 'datetime'],
        ap: ['@format("AP",string, "L" )', 'datetime'],
        ISO: ['yyyyMMdd', 'date'],
        RFC1123: ['ddd, dd MMM yyyy hh:mm:ss G\\MT', 'datetime'],
    },
};

Format.weekdaySpecifiers = {
    lazyLoad_createParameterAlias: {
        '#': ['@boolean(@pos,-)'],
        x: ['@boolean(@dow,-)'],
        '0': ['@boolean(1,0)'],
        u: ['@boolean(@dowu,-)'],
    },
};

// internal format is a Date object
Format.timeSpecifiers = {
    '[d]': FormatSpecifier.time_getElapsedDaysText,
    '[h]': FormatSpecifier.time_getElapsedHoursText,
    '[hh]': FormatSpecifier.time_getElapsedHoursText,
    '[m]': FormatSpecifier.time_getElapsedMinutesText,
    '[s]': FormatSpecifier.time_getElapsedSecondsText,
    d: FormatSpecifier.time_getDaysText,
    H: FormatSpecifier.time_getMilitaryHoursText,
    HH: FormatSpecifier.time_getISOHoursText,
    h: FormatSpecifier.time_getHoursText,
    hh: FormatSpecifier.time_getPaddedHoursText,
    m: FormatSpecifier.time_getMinutesText,
    mm: FormatSpecifier.time_getISOMinutesText,
    mmm: FormatSpecifier.time_getAsMinutesText,
    s: FormatSpecifier.time_getSecondsText,
    ss: FormatSpecifier.time_getISOSecondsText,
    '+': FormatSpecifier.number_getSignText,
    '-': FormatSpecifier.number_getConditionalSignText,
    '%': FormatSpecifier.time_getMinuteRemainderText,
    '%%': FormatSpecifier.time_getHourRemainderText,
    // "00":
    // "000":
    // "OD":
    APM: FormatSpecifier.time_getAMPMText,
    AP: FormatSpecifier.time_getAPText,
    APMX: FormatSpecifier.time_getAMPMXText,
    APX: FormatSpecifier.time_getAPXText,

    lazyLoad_createParameterAlias: {
        apm: ['@format("APM",string, "L" )', 'time'],
        ap: ['@format("AP",string, "L" )', 'time'],
        apmx: ['@format("APMX",string, "L" )', 'time'],
        apx: ['@format("APX",string, "L" )', 'time'],
        ISO: ['THHmmss', 'time'],
    },
};

Format.timeSpanSpecifiers = {
    '[d]': FormatSpecifier.time_getElapsedDaysText,
    '[h]': FormatSpecifier.time_getElapsedHoursText,
    '[m]': FormatSpecifier.time_getElapsedMinutesText,
    '[s]': FormatSpecifier.time_getElapsedSecondsText,
    '[hf]': FormatSpecifier.time_getElapsedHoursAsDouble,
    h: FormatSpecifier.time_getMilitaryHoursText,
    hh: FormatSpecifier.time_getISOHoursText,
    m: FormatSpecifier.time_getMinutesText,
    mm: FormatSpecifier.time_getISOMinutesText,
    mmm: FormatSpecifier.time_getAsMinutesText,
    s: FormatSpecifier.time_getSecondsText,
    ss: FormatSpecifier.time_getISOSecondsText,
    '+': FormatSpecifier.number_getSignText,
    '-': FormatSpecifier.number_getConditionalSignText,
    '%': FormatSpecifier.time_getMinuteRemainderText,
    '%%': FormatSpecifier.time_getHourRemainderText,
    '00': FormatSpecifier.time_getCentiSecondsText,
    '000': FormatSpecifier.time_getMilliSecondsText,
    lazyLoad_createParameterAlias: {
        ISO: ['-[s]', 'timespan'],
    },
};

Format.booleanSpecifiers = {
    'Y,N': FormatSpecifier.boolean_getYNText,
    'Yes,No': FormatSpecifier.boolean_getYesNoText,
    'T,F': FormatSpecifier.boolean_getTFText,
    'true,false': FormatSpecifier.boolean_gettruefalseText,
    'True,False': FormatSpecifier.boolean_getTrueFalseText,
    'On,Off': FormatSpecifier.boolean_getOnOffText,
    'X,': FormatSpecifier.boolean_getMarkText,
    '#': FormatSpecifier.boolean_getRawText,
    lazyLoad_createParameterAlias: {
        ISO: ['#', 'boolean'],
    },
};

Format.stringSpecifiers = {
    U: FormatSpecifier.string_getUpperCase,
    L: FormatSpecifier.string_getLowerCase,
    F: FormatSpecifier.string_getFirstCapitalized,
    C: FormatSpecifier.string_getAllCapitalized,
    LCC: FormatSpecifier.string_getLowerCamelCase,
    UCC: FormatSpecifier.string_getUpperCamelCase,
    T: FormatSpecifier.string_getVerbatimText,

    lazyLoad_createParameterAlias: {
        A: ['@each(string,"T")'],
        X: ['@each(string,"T")'],
        '9': ['@each(string,"T")'],
        ISO: ['T', 'string'],
    },
};

Format.numberSpecifiers = {
    '#': FormatSpecifier.number_getIntegerText,
    '0': FormatSpecifier.number_getZeroPaddedText,
    '1': FormatSpecifier.number_getNoneZeroPaddedText,
    '?': FormatSpecifier.number_getSpacePaddedText,
    //	"E-"]
    //	"e-"]
    //	"E+"]
    //	"e+"]
    '+': FormatSpecifier.number_getSignText,
    '-': FormatSpecifier.number_getConditionalSignText,
    '(': FormatSpecifier.number_getConditionalSignBracket,
    ')': FormatSpecifier.number_getConditionalSignBracket,
    ISO: FormatSpecifier.number_getText,

    lazyLoad_createParameterAlias: {
        '.': ['@separator(@decimal)'],
        '/': ['@bar'],
        //		"g3": ["@grouping(3)"],
        //		"g4": ["@grouping(3)"],
    },
};

Format.percentageSpecifiers = {
    '#': FormatSpecifier.percentage_getIntegerText,
    '0': FormatSpecifier.percentage_getZeroPaddedText,
    '1': FormatSpecifier.percentage_getNoneZeroPaddedText,
    '?': FormatSpecifier.percentage_getSpacePaddedText,
    N: FormatSpecifier.number_getIntegerText,

    lazyLoad_createParameterAlias: {
        '%': ['@percent'],
        ISO: ['-N.NN', 'percentage'],
    },
};

Format.currencySpecifiers = {
    lazyLoad_createParameterAlias: {
        $: ['@symbol'],
    },
};

Format.measurementSpecifiers = {
    '#': FormatSpecifier.measurement_getIntegerText,
    '0': FormatSpecifier.measurement_getZeroPaddedText,
    '1': FormatSpecifier.measurement_getNoneZeroPaddedText,
    '?': FormatSpecifier.measurement_getSpacePaddedText,
    '+': FormatSpecifier.measurement_getSignText,
    '-': FormatSpecifier.measurement_getConditionalSignText,
    '(': FormatSpecifier.measurement_getConditionalSignBracket,
    ')': FormatSpecifier.measurement_getConditionalSignBracket,
};

Format.speedSpecifiers = {
    lazyLoad_createParameterAlias: {
        'km/h': ['@units(km/h)'],
        kph: ['@units(kph)'],
        'mi/h': ['@units(mi/h)'],
        mph: ['@units(mph)'],
        mps: ['@units(mps)'],
        ISO: ['#.# kph', 'speed'],
    },
};

Format.distanceSpecifiers = {
    lazyLoad_createParameterAlias: {
        km: ['@units(km)'],
        mi: ['@units(mi)'],
        ft: ['@units(ft)'],
        yd: ['@units(yd)'],
        m: ['@units(m)'],
        mm: ['@units(mm)'],
        ISO: ['-#.# m', 'distance'],
    },
};

Format.volumeSpecifiers = {
    lazyLoad_createParameterAlias: {
        L: ['@units(L)'],
        g: ['@units(g)'],
        ig: ['@units(ig)'],
        ISO: ['-#.# L', 'volume'],
    },
};

Format.pressureSpecifiers = {
    lazyLoad_createParameterAlias: {
        kPa: ['@units(kPa)'],
        atm: ['@units(atm)'],
        psi: ['@units(psi)'],
        Pa: ['@units(Pa)'],
        ISO: ['-#.# Pa', 'pressure'],
    },
};

Format.accelerationSpecifiers = {
    lazyLoad_createParameterAlias: {
        mps2: ['@units(mps2)'],
        fps2: ['@units(fps2)'],
        G: ['@units(G)'],
        ISO: ['-#.# mps2', 'acceleration'],
    },
};

Format.temperatureSpecifiers = {
    lazyLoad_createParameterAlias: {
        C: ['@units(C)'],
        K: ['@units(K)'],
        F: ['@units(F)'],
        ISO: ['-#.# K', 'temperature'],
    },
};

Format.fuelEconomySpecifiers = {
    lazyLoad_createParameterAlias: {
        'L/100km': ['@units(L/100km)'],
        'km/L': ['@units(km/L)'],
        mpig: ['@units(mpig)'],
        mpug: ['@units(mpug)'],
        ISO: ['-#.# km/L', 'fueleconomy'],
    },
};

Format.weightSpecifiers = {
    lazyLoad_createParameterAlias: {
        kg: ['@units(kg)'],
        g: ['@units(g)'],
        t: ['@units(t)'],
        lb: ['@units(lb)'],
        oz: ['@units(oz)'],
        cwt: ['@units(cwt)'],
        ton: ['@units(ton)'],
        ISO: ['-#.# kg', 'weight'],
    },
};

// Parsing logic

export const Parse = {
    STANDARD: 'ISO',
    LOCAL: 'LOCAL',
    MILLIS: 'MILLIS',
    REGEX_NUMERIC: /\d+/,
    REGEX_NONNUMERIC: /\D+/,

    splitAlphanumeric(text, regex) {
        if (text == null) return [];

        const strings = text.split(regex);

        for (let i = 0; i < strings.length; i++) {
            if (strings[i] === '') {
                strings.splice(i, 1);
                i--;
            }
        }

        return strings;
    },

    parsers: [],

    // the localeContext can either be an element (to lookup locale attributes),
    // or a map of locale attribute names vs locale attribute values
    getParser(localeContext, dataType, parseSpec) {
        let dataParsers = Parse.parsers[dataType];

        if (!dataParsers) {
            Parse.parsers[dataType] = [];
            dataParsers = Parse.parsers[dataType];
        }

        let dataParser = dataParsers[parseSpec];

        if (!dataParser) {
            dataParser = Parse.createParser(dataType, parseSpec);
            dataParsers[parseSpec] = dataParser;
        }

        const context = {};
        context.parse = Parse.context_callParser;
        context.specifier = dataParser;
        context.dataType = dataType;
        context.localeContext = localeContext;
        context.getLocaleArray = Parse.getLocaleArray;
        context.getLocaleValue = Parse.getLocaleValue;

        return context;
    },

    context_callParser(value) {
        return this.specifier.parse.call(this, value);
    },

    getLocaleArray(name) {
        const value = this.getLocaleValue(name);
        return value ? value.split(',') : [];
    },

    getLocaleValue(name) {
        if (!this.localeContext) return null;

        if (this.localeContext.tagName) return getAncestorProperty(this.localeContext, name);

        return this.localeContext[name];
    },

    createParser(dataType, parseSpec) {
        const parser = {};

        parser.parseSpec = parseSpec;
        parser.parse = ParseSpecifier.parseText; // default

        switch (dataType) {
            case 'date':
                parser.parse = Parse.getDateParseMethod(parseSpec);
                break;
            case 'datetime':
                parser.parse = Parse.getDateTimeParseMethod(parseSpec);
                break;
            case 'weekdays':
                parser.parse = Parse.getWeekdaysParseMethod();
                break;
            case 'time':
                parser.parse = Parse.getTimeParseMethod(parseSpec);
                break;
            case 'timespan':
                parser.parse = Parse.getTimeSpanParseMethod(parseSpec);
                break;
            case 'boolean':
                parser.parse = Parse.getBooleanParseMethod(parseSpec);
                break;
            case 'percentage':
                parser.parse = Parse.getPercentageParseMethod(parseSpec);
                break;
            case 'speed':
            case 'distance':
            case 'volume':
            case 'pressure':
            case 'acceleration':
            case 'temperature':
            case 'fueleconomy':
            case 'weight':
                parser.parse = Parse.getMeasurementParseMethod(parseSpec);
                break;
            case 'currency':
            case 'measurement':
            case 'number':
                parser.parse = Parse.getNumberParseMethod(parseSpec);
                break;
            default:
        }

        return parser;
    },

    getBooleanParseMethod(parseSpec) {
        let method = null;

        switch (parseSpec) {
            case Parse.STANDARD:
                method = ParseSpecifier.parseBoolean; // for now
                break;
            default:
        }

        return method;
    },

    getNumberParseMethod(parseSpec) {
        let method = null;

        switch (parseSpec) {
            case Parse.STANDARD:
                method = ParseSpecifier.parseNumber; // for now
                break;
            default:
        }

        return method;
    },

    getPercentageParseMethod(parseSpec) {
        let method = null;

        switch (parseSpec) {
            case Parse.STANDARD:
                method = ParseSpecifier.parsePercentage; // for now
                break;
            default:
                method = ParseSpecifier.parsePercentage; // for now
                break;
        }

        return method;
    },

    getMeasurementParseMethod(parseSpec) {
        let method = null;

        switch (parseSpec) {
            case Parse.STANDARD:
                method = ParseSpecifier.parseMeasurement;
                break;
            default:
                method = ParseSpecifier.parseMeasurement;
                break;
        }

        return method;
    },

    getTimeParseMethod(parseSpec) {
        let method;
        switch (parseSpec) {
            case Parse.STANDARD:
                // @ts-ignore
                method = ParseSpecifier.parseTime;
                break;
            default:
                // @ts-ignore
                method = ParseSpecifier.parseTime;
                break;
        }

        // @ts-ignore
        return method;
    },

    getTimeSpanParseMethod(parseSpec) {
        let method = null;

        switch (parseSpec) {
            case Parse.STANDARD:
                method = ParseSpecifier.parseTimeSpan;
                break;
            default:
                method = ParseSpecifier.parseTimeSpan;
                break;
        }

        return method;
    },

    getDateParseMethod(parseSpec) {
        let method = null;

        switch (parseSpec) {
            case Parse.STANDARD:
                method = ParseSpecifier.parseDate;
                break;
            case Parse.MILLIS:
                method = ParseSpecifier.parseDateFromMillis;
                break;
            default:
                method = ParseSpecifier.parseDate;
                break;
        }

        return method;
    },

    getDateTimeParseMethod(parseSpec) {
        let method = null;

        switch (parseSpec) {
            case Parse.STANDARD:
                method = ParseSpecifier.parseDateTime;
                break;
            case Parse.MILLIS:
                method = ParseSpecifier.parseDateTimeFromMillis;
                break;
            default:
                method = ParseSpecifier.parseDateTime;
                break;
        }

        return method;
    },

    getWeekdaysParseMethod() {
        return ParseSpecifier.parseWeekdays;
    },
};

// parsing methods
const ParseSpecifier = {
    parseText(text) {
        return text;
    },

    parseDateFromMillis(text) {
        if (text == null || isNaN(text)) return null;

        const millis = text.toString ? parseInt(text, 10) : text;

        return new Date(millis - millis % 86400000);
    },

    parseDate(text) {
        if (text == null) return null;

        if (typeof text !== 'string') {
            if (text.toString) text = text.toString();
            else return null;
        }

        text = text.trim();

        if (text.length === 0) return null;

        const lowerString = text.toLowerCase();

        if (lowerString === '?') return new Date(); // todo: strip off time

        const localeToday = this.getLocaleValue('localeToday');

        if (localeToday && lowerString === localeToday.toLowerCase()) return new Date(); // todo: strip off time

        const localeNow = this.getLocaleValue('localeNow');

        if (localeNow && lowerString === localeNow.toLowerCase()) return new Date(); // todo: strip off time

        const firstChar = text.charAt(0);

        if (firstChar === '+' || firstChar === '-') {
            const numValue = Number(text);
            let millis = new Date().getTime();
            millis += numValue * 86400000;
            return new Date(millis);
        }

        const localeDatePattern = this.specifier.parseSpec; // MdY

        // split around all non-numerics to get array of numeric strings
        let numerics = text.split(Parse.REGEX_NONNUMERIC);
        if (numerics.length === 1) {
            if (localeDatePattern === Parse.STANDARD && text.length === 8) return isoDateToDate(text);

            const textLen = text.length;
            if (localeDatePattern === 'yMd')
                numerics = [text.substr(0, textLen - 4), text.substr(textLen - 4, 2), text.substr(textLen - 2)];
            else if (localeDatePattern === 'Mdy' || localeDatePattern === 'dMy')
                numerics = [text.substr(0, 2), text.substr(2, 2), text.substr(4)];
        }

        // if the parser was meant to be ISO - fail the input
        if (this.specifier.parseSpec === Parse.STANDARD) return null;

        const pivotYear = this.getLocaleValue('localeFormatDateYYPivotYear');

        if (numerics.length > 2 && !(numerics.length === 3 && numerics[0] === '')) {
            // TODO fit 20150430 into this block

            const numbers = [0, 0, 0];

            for (let ix = 0; ix < localeDatePattern.length; ix++) {
                const dateChar = localeDatePattern.charAt(ix);
                const numberValue = Number(numerics[ix]);
                // @ts-ignore
                let numericValue = isNaN(numberValue) ? null : numberValue.valueOf();

                if (numericValue == null) continue;

                switch (dateChar) {
                    case 'y':
                        if (pivotYear && numerics[ix].length < 3) {
                            const pivotDigits = pivotYear % 100;
                            const pivotCenturyBase = pivotYear - pivotDigits;
                            numericValue = numericValue + pivotCenturyBase + (numericValue < pivotDigits ? 100 : 0);
                        }

                        numbers[0] = numericValue;
                        break;
                    case 'M':
                        numbers[1] = numericValue;
                        break;
                    case 'd':
                        numbers[2] = numericValue;
                        break;
                    default:
                }
            }

            return new Date(numbers[0], numbers[1] - 1, numbers[2]);
        }

        const date = new Date(text); // otherwise, just let the javascript date parser have a go

        // @ts-ignore
        return isNaN(date) ? null : date;
    },

    parseWeekdays(text) {
        if (text == null) return null;

        if (typeof text !== 'string') {
            if (text.toString) text = text.toString();
            else return null;
        }

        let result = '';
        const skipValues = { '-': 1, ' ': 1, '0': 1, '': 1 };
        let pattern = this.specifier.parseSpec;
        if (pattern === Parse.STANDARD) pattern = '0xxxxxxx';

        const dowOffset = parseInt(pattern.charAt(0), 10);
        let dow = 0;
        // @ts-ignore
        for (let i = 0; i < 7; i++, dow++) {
            dow = i - dowOffset;
            if (dow < 0) dow = 7 + dow;
            const dayChar = text.charAt(dow);
            result += dayChar in skipValues ? '0' : '1';
        }
        return result.padStart(7, '0');
    },

    parseDateTimeFromMillis(text) {
        if (text == null || isNaN(text)) return null;

        const millis = text.toString ? parseInt(text, 10) : text;

        return new Date(millis);
    },

    parseDateTime(text) {
        if (text == null) return null;

        if (typeof text !== 'string') {
            if (text.toString) text = text.toString();
            else return null;
        }

        text = text.trim();

        if (text.length === 0) return null;

        const lowerString = text.toLowerCase();

        if (lowerString === '?') return new Date();

        const localeToday = this.getLocaleValue('localeToday');

        if (localeToday && lowerString === localeToday.toLowerCase()) return new Date(); // todo: strip off time

        const localeNow = this.getLocaleValue('localeNow');

        if (localeNow && lowerString === localeNow.toLowerCase()) return new Date();

        // if the parser was meant to be ISO
        if (this.specifier.parseSpec === Parse.STANDARD) return isoDatetimeToDate(text);

        // otherwise assume locale specific according to the parse spec

        // split around all non-numerics to get array of numeric strings
        const numerics = text.split(Parse.REGEX_NONNUMERIC);

        const pivotYear = this.getLocaleValue('localeFormatDateYYPivotYear');

        if (numerics.length > 2) {
            const localeDatePattern = this.specifier.parseSpec;
            const numbers = [0, 0, 0, 0, 0, 0, 0];

            for (let ix = 0; ix < localeDatePattern.length; ix++) {
                const dateChar = localeDatePattern.charAt(ix);
                const numberValue = Number(numerics[ix]);
                let numericValue = isNaN(numberValue) ? null : numberValue.valueOf();

                if (numericValue == null) continue;

                switch (dateChar) {
                    case 'y':
                        if (pivotYear && numerics[ix].length < 3) {
                            const pivotDigits = pivotYear % 100;
                            const pivotCenturyBase = pivotYear - pivotDigits;
                            numericValue = numericValue + pivotCenturyBase + (numericValue < pivotDigits ? 100 : 0);
                        }

                        numbers[0] = numericValue;
                        break;
                    case 'M':
                        numbers[1] = numericValue;
                        break;
                    case 'd':
                        numbers[2] = numericValue;
                        break;
                    case 'H':
                        numbers[3] = numericValue;
                        break;
                    case 'm':
                        numbers[4] = numericValue;
                        break;
                    case 's':
                        numbers[5] = numericValue;
                        break;
                    case '0':
                        // If value is greater than 999 then it is something more detailed than milli seconds.
                        // Without knowing what the unit it, we can't convert to milli seconds.
                        // In most cases we don't need millisecond acuracy.
                        if (numberValue < 1000) numbers[6] = numericValue;
                        break;
                    default:
                }
            }

            return new Date(numbers[0], numbers[1] - 1, numbers[2], numbers[3], numbers[4], numbers[5], numbers[6]);
        }

        const date = new Date(text); // otherwise, just let the javascript date parser have a go

        // @ts-ignore
        return isNaN(date) ? null : date;
    },

    parseNumber(text) {
        return parseFloat(text); // to do: handle mixed in text
    },

    /**
     *
     * @param {string} text
     */
    parseMeasurement(
        text, // distance of travel
    ) {
        if (!text) return null;

        const workingText = text.trim(); // do not lowercase
        let tokens = splitDecimal(workingText, true);

        tokens[0] = tokens[0].replace(/\.+$/, ''); // trim periods right

        const isNegative = tokens[0].indexOf('-') > -1;

        if (!isDecimal(tokens[0])) tokens = tokens.slice(1);

        if (tokens[0] == null) return null;

        const unsignedNumberValue = toNumber(trimZerosLeft(tokens[0]));
        let numbervalue = isNegative ? 0 - unsignedNumberValue : unsignedNumberValue;
        let defaultUnits = Format.measurementDefaults[this.dataType];

        if (this.specifier.parseSpec !== Parse.STANDARD)
            if (Format.measurementUnits[this.dataType].includes(this.specifier.parseSpec))
                defaultUnits = this.specifier.parseSpec;

        for (
            let ix = 2;
            ix < tokens.length;
            ix++ // Fix for unitValues with contained numbers
        ) {
            if (Format.measurementUnits[this.dataType].includes(tokens[1].trim())) break;

            tokens[1] += tokens[ix];
        }

        const unitValue = tokens[1] ? tokens[1].trim() : defaultUnits;

        if (!Format.measurementUnits[this.dataType].includes(unitValue)) return null;

        const postFunction = Format.measurementPostFunction[unitValue];

        if (postFunction) numbervalue = postFunction(numbervalue);

        const offset = Format.measurementOffsets[unitValue];

        if (offset !== undefined) numbervalue += offset;

        return numbervalue / Format.getMeasurementFactor(this.dataType, unitValue);
    },

    parseTime(
        text, // time of day in seconds
    ) {
        if (!text || !text.length) return null;

        let now = this.getLocaleValue('localeNow') || 'now';
        now = now.toLowerCase();

        const workingText = text.trim().toLowerCase();

        if ((now && workingText === now) || workingText === '?') {
            const nowTime = new Date();
            let time = nowTime.getHours() * 3600;
            time += nowTime.getMinutes() * 60;
            time += nowTime.getSeconds();
            // time += nowTime.getMilliseconds() / 1000;
            return time;
        }

        // split around all non-numerics to get array of numeric strings
        const numerics = Parse.splitAlphanumeric(workingText, Parse.REGEX_NONNUMERIC);

        if (numerics.length < 1) return null;

        const alphabetics = Parse.splitAlphanumeric(workingText, Parse.REGEX_NUMERIC);

        const suffix =
            workingText.startsWith(numerics[0]) && alphabetics.length
                ? alphabetics[alphabetics.length - 1].trim()
                : null;
        let apx = null;

        switch (suffix) {
            case 'a':
            case 'am':
                apx = 'am';
                break;
            case 'p':
            case 'pm':
                apx = 'pm';
                break;
            case 'x':
                apx = 'x';
                break;
            default:
        }

        const localeTimePattern = this.specifier.parseSpec;

        if (numerics.length === 1) {
            const numeric = numerics[0];
            const numberValue = Number(numeric).valueOf();

            if (apx == null) {
                let multiplier = null;

                if (!suffix) {
                    switch (localeTimePattern) {
                        case 'h':
                            multiplier = 3600;
                            break;
                        case 'm':
                            multiplier = 60;
                            break;
                        case Parse.STANDARD:
                        case 's':
                            multiplier = 1;
                            break;
                        default:
                    }
                }

                switch (suffix) {
                    case 'h':
                        multiplier = 3600;
                        break;
                    case 'm':
                        multiplier = 60;
                        break;
                    case 's':
                        multiplier = 1;
                        break;
                    default:
                }

                if (multiplier || localeTimePattern.length === 1 || localeTimePattern === Parse.STANDARD)
                    return multiplier ? multiplier * numberValue : null;
            }

            // nibble the unsegmented number 2 digits at a time starting from right
            while (numerics.length < localeTimePattern.length && numerics[0].length > 2) {
                numerics.splice(1, 0, numerics[0].substr(numerics[0].length - 2));
                numerics[0] = numerics[0].slice(0, -2);
            }
        }

        if (apx == null && localeTimePattern.startsWith('h')) apx = 'am';

        const hours = Number(numerics[0]).valueOf();
        let accumulator = 0;

        if (numerics[1]) accumulator += Number(numerics[1]).valueOf() * 60; // minutes

        if (numerics[2]) accumulator += Number(numerics[2]).valueOf(); // seconds

        if (apx === 'am' && hours === 12) return accumulator;

        if (apx === 'pm' && hours < 12) return accumulator + 3600 * (hours + 12);

        if (apx === 'x') {
            if (hours === 12) return accumulator + 3600 * 24;

            if (hours < 12) return accumulator + 3600 * (hours + 24);

            return null; // time > 11x is out of range
        }

        return accumulator + 3600 * hours; // handles military time as well as AM
    },

    parseTimeSpan(text) {
        if (!text || !text.length) return null;

        const unitValues = ['ms', 's', 'm', 'h', 'd', 'w'];
        const unitLevels = { ms: 0, s: 1, m: 2, h: 3, d: 4, w: 5 };
        const unitMultipliers = { ms: 0.001, s: 1, m: 60, h: 3600, d: 3600 * 24, w: 3600 * 24 * 7 };

        const baseUnitValue = this.specifier.parseSpec;

        let baseLevel = unitValues.includes(baseUnitValue) ? unitLevels[baseUnitValue] : unitLevels.m;

        let tokens = splitDecimal(text, true);

        for (let tx = 0; tx < tokens.length; tx++) tokens[tx] = tokens[tx].trim();

        let isNegative = false;

        if (tokens[0].includes('-')) isNegative = true;

        if (tokens[0].includes(':')) baseLevel = unitLevels.s;

        if (!isDecimal(tokens[0])) tokens = tokens.slice(1);

        const numbers = [];
        let currentUnit = null;

        for (let ix = 0; ix < tokens.length; ix += 2) {
            const numberValue = toNumber(trimZerosLeft(tokens[ix]));
            let unitString = tokens[ix + 1];
            unitString = unitString ? unitString.trim() : null;

            let unitLevel = unitLevels[unitString];

            if (unitLevel != null) currentUnit = unitLevel;
            else if (currentUnit != null) {
                unitLevel = currentUnit - 1;
                currentUnit = unitLevel;
            }

            numbers.push({ numberValue, unitLevel });
        }

        if (numbers.length === 0) return null;

        const baseNumber = numbers[numbers.length - 1];

        baseNumber.unitLevel = baseNumber.unitLevel == null ? baseLevel : baseNumber.unitLevel;

        for (let nx = numbers.length - 1; nx > -1; nx--) {
            const currentNumber = numbers[nx];
            const nextNumber = numbers[nx + 1];

            if (currentNumber.unitLevel == null) currentNumber.unitLevel = nextNumber.unitLevel + 1;

            // @ts-ignore
            if (currentNumber.unitValue == null) {
                // @ts-ignore
                currentNumber.unitValue = unitValues[currentNumber.unitLevel];
                // @ts-ignore
                currentNumber.unitMultiplier = unitMultipliers[currentNumber.unitValue];
            }
        }

        let accumulator = 0;

        for (let ax = 0; ax < numbers.length; ax++) {
            // @ts-ignore
            const multiplier = numbers[ax].unitMultiplier;
            if (multiplier < 1)
                accumulator += parseFloat(
                    (numbers[ax].numberValue * multiplier).toFixed(Math.abs(Math.log10(multiplier))),
                );
            else accumulator += numbers[ax].numberValue * multiplier;
        }

        return isNegative ? 0 - accumulator : accumulator;
    },

    parsePercentage(text) {
        if (!text) return null;

        const workingText = text.trim();

        if (workingText.endsWith('%')) {
            const numberValue = ParseSpecifier.parseNumber(workingText.slice(0, -1));

            if (isNaN(numberValue)) return null;

            return numberValue / 100;
        }

        return ParseSpecifier.parseNumber(workingText);
    },

    parseFixed(text) {
        return Number(text);
        // to do: handle mixed in text, stop after fixed number of decimals
    },

    parseInteger(text) {
        return Number(text); // to do: handle mixed in text, stop with periods
    },

    parseBoolean(text) {
        if (!text) return false;

        text = text.toLowerCase();

        if (text === 'true' || text === 'on' || text === 't' || text === 'y' || text === 'yes') return true;

        const numValue = Number(text);

        if (isNaN(numValue)) return false;

        return numValue > 0;
    },
};
