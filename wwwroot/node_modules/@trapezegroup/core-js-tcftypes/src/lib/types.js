// @ts-check
import { colorFromCOLORREF } from '@trapezegroup/core-js-extensions/src/lib/methods.js';
import { Color } from '@trapezegroup/core-js-extensions/src/lib/color.js';
import { getProperty, closest } from '@trapezegroup/core-js-extensions/src/lib/element.js';
import { locale } from './locale.js';
import { Parse, Format } from './format.js';
import { TypeInfo, TCFType } from './typeInfo.js';

export const TcfDataTypesMap = {};

export const booleanComparator =
    /**
     * @param {boolean} a
     * @param {any} b
     */
    function booleanComparator(a, b) {
        if (a == null && b != null) return -1;
        if (a != null && b == null) return 1;
        if (a == null && b == null) return 0;
        if (a === b) return 0;
        if (a === false) return -1;
        return 1;
    };

export const numberComparator = /**
 * @param {number} a
 * @param {number} b
 */ function numberComparator(a, b) {
    if (a == null && b != null) return -1;
    if (a != null && b == null) return 1;
    if (a == null && b == null) return 0;
    return a - b;
};

export const stringComparator = /**
 * @param {number} a
 * @param {number} b
 */ function stringComparator(a, b) {
    if (a == null && b != null) return -1;
    if (a != null && b == null) return 1;
    if (a == null && b == null) return 0;
    if (a === b) return 0;
    if (a > b) return 1;
    return -1;
};

// (89*366 + 280*365) * 86,400,000 = 11,644,473,600,000
const windowsEpochMilliseconds = 11644473600000;

/**
 * @param {Date} date
 */
function toUTCMFM(date) {
    if (date.getTime() > 0)
        return (
            date.getUTCHours() * 3600000 +
            date.getUTCMinutes() * 60000 +
            date.getUTCSeconds() * 1000 +
            date.getUTCMilliseconds()
        );
    return 0;
}

/**
 * Gets the seconds from midnight using UTC
 * @param {Date} date
 */
function toUTCSFM(date) {
    if (date.getTime() > 0) return date.getUTCHours() * 3600 + date.getUTCMinutes() * 60 + date.getUTCSeconds();
    return 0;
}

/**
 *
 * @param {Date} date
 */
function toUTC(date) {
    return toTimeZone(date, -date.getTimezoneOffset());
}

/**
 *
 * @param {Date} date
 */
function toLocale(date) {
    return toTimeZone(date, date.getTimezoneOffset());
}

/**
 *
 * @param {Date} date
 * @param {number} bias
 */
function toTimeZone(date, bias) {
    date.setMinutes(date.getMinutes() + bias);
    return date;
}

/**
 * @param {string} x
 */
function getDecPos(x) {
    const pos = x.indexOf('.') + 1;
    if (pos > 0) return x.length - pos;
    return 0;
}

/**
 * @param {string} num
 * @param {number} index
 */
function insertDecAt(num, index) {
    let result = '';
    const numStr = `${num}`;
    if (index > 0) {
        for (let i = 0; i < numStr.length; i++) {
            if (i === numStr.length - index) result = `${result}.${numStr.charAt(i)}`;
            else result += numStr.charAt(i);
        }
        return result;
    }
    return numStr;
}

/**
 * @param {string} numAsString1
 * @param {string} [numAsString2]
 */
function addNumbers(numAsString1, numAsString2) {
    // TODO this doesn't work if one of the values is negative.
    let numStr1 = `${numAsString1}`.replace(/,/g, '');
    let numStr2 = `${numAsString2}`.replace(/,/g, '');

    let decNum1 = getDecPos(numStr1);
    const decNum1Orig = decNum1;
    let decNum2 = getDecPos(numStr2);
    const decNum2Orig = decNum2;

    numStr1 = numStr1.replace('.', '');
    numStr2 = numStr2.replace('.', '');

    // let numStr2 = numStr1 = "" ;

    let decPlace = decNum1;
    if (decNum1 > decNum2) {
        decPlace = decNum1;
        for (let i = 0; i < decPlace - decNum2Orig; i++) {
            numStr2 += '0';
            decNum2 += 1;
        }
    } else if (decNum2 > decNum1) {
        decPlace = decNum2;
        for (let i = 0; i < decPlace - decNum1Orig; i++) {
            numStr1 += '0';
            decNum1 += 1;
        }
    }

    let xlen = numStr1.length;
    let ylen = numStr2.length;
    if (xlen < ylen) {
        const temp = numStr2;
        numStr2 = numStr1;
        numStr1 = temp;
        const temp2 = decNum1;
        decNum1 = decNum2;
        decNum2 = temp2;
        xlen = numStr1.length;
        ylen = numStr2.length;
    }
    let carry = 0;
    let s = '';
    let numx;
    let numy;
    for (let i = xlen - 1; i >= 0; i--) {
        numy = 0;
        if (ylen - xlen + i > -1) numy = parseInt(numStr2.charAt(ylen - xlen + i), 10);
        numx = parseInt(numStr1.charAt(i), 10);
        s = (numy + numx + carry) % 10 + s;
        carry = Math.floor((numy + numx + carry) / 10);
    }

    if (carry > 0) s = carry + s;
    s = insertDecAt(s, decPlace);
    return s;
}

/**
 * Gets the datatype implementaion class for a given hex value
 * @param {string} hex hex string of type
 * @returns {any} the matching class of the datatype for the hex passed in
 */
export const getDataType = function getDataType(hex) {
    let fhx = hex;

    switch (fhx.length) {
        case 1:
            fhx = `00000${fhx}`;
            break;
        case 2:
            fhx = `0000${fhx}`;
            break;
        case 3:
            fhx = `000${fhx}`;
            break;
        case 4:
            fhx = `00${fhx}`;
            break;
        case 5:
            fhx = `0${fhx}`;
            break;
        default:
    }

    let dtClass = TcfDataTypesMap[fhx];
    if (dtClass === undefined) {
        const typeInfo = new TypeInfo(fhx);

        // Extended types are defined in TCF_ExtTypes.h
        switch (typeInfo.getExt()) {
            case 1:
                dtClass = TcfBoolean;
                break;
            case 10:
                dtClass = TcfTimeSpan;
                break;
            case 11:
                dtClass = TcfTimeSpan;
                break;
            case 12:
                dtClass = TcfBigTimeSpan;
                break;
            case 20:
                dtClass = TcfTime;
                break;
            case 21:
                dtClass = TcfTime;
                break;
            case 30:
                dtClass = TcfDate;
                break;
            case 35:
                dtClass = TcfDateTime;
                break;
            case 40:
            case 41:
            case 42:
            case 43:
            case 44:
                dtClass = typeInfo.isReal() ? TcfDistance : TcfDistanceInt;
                break;
            case 50:
            case 51:
            case 52:
                dtClass = TcfSpeed;
                break;
            case 70:
                dtClass = typeInfo.isString() ? TcfWeekdaysStr : TcfWeekdaysInt;
                break;
            case 99:
                dtClass = TcfColor;
                break;
            case 100:
                dtClass = TcfColorAlpha;
                break;
            case 101:
                dtClass = TcfColorRef;
                break;
            case 130:
                dtClass = TcfVolume;
                break;
            case 140:
                dtClass = TcfPressure;
                break;
            case 150:
                dtClass = TcfAcceleration;
                break;
            case 160:
                dtClass = TcfTemperature;
                break;
            case 170:
                dtClass = TcfFuelEconomy;
                break;
            case 180:
                dtClass = TcfWeight;
                break;
            default:
        }

        if (dtClass === undefined) {
            dtClass = basicDatatypeMap.get(typeInfo.getType());
        }

        if (dtClass) TcfDataTypesMap[fhx] = dtClass;
        else {
            // This type is unknown to us.
            // Normally, we should not be here except if TCF added a new basic type.
            console.error(new Error(`TcfDataTypesMap.getDataType: Unknown type: ${fhx}`));
        }
    }
    return dtClass;
};

/**
 * @param {any} value - test if value looks like int
 * @returns {boolean}
 */
export function isInt(value) {
    if (value === true || value === false) return false;
    if (isNaN(value)) return false;
    if (`${value}`.indexOf('.') > -1) return false;
    if (value > 9223372036854775807 || value < -9223372036854775808) return false;
    return true;
}

/**
 * @param {any} value - test if value looks like byte
 * @returns {boolean}
 */
export function isByte(value) {
    if (!isInt(value)) {
        return false;
    }
    if (value > 255 || value < 0) {
        return false;
    }
    return true;
}

/**
 * @param {any} value - test if value looks like sByte
 * @returns {boolean}
 */
export function isSByte(value) {
    if (!isInt(value)) {
        return false;
    }
    if (value > 127 || value < -128) {
        return false;
    }
    return true;
}

/**
 * @param {any} value - test if value looks like char
 * @returns {boolean}
 */
export function isChar(value) {
    return `${value}`.length === 1;
}

/**
 * @param {any} value - test if value looks like uint16
 * @returns {boolean}
 */
export function isUInt16(value) {
    if (!isInt(value)) {
        return false;
    }
    if (value > 65535 || value < 0) {
        return false;
    }
    return true;
}

/**
 * @param {any} value - test if value looks like int16
 * @returns {boolean}
 */
export function isInt16(value) {
    if (!isInt(value)) {
        return false;
    }
    if (value > 32767 || value < -32768) {
        return false;
    }
    return true;
}

/**
 * @param {any} value - test if value looks like uint32
 * @returns {boolean}
 */
export function isUInt32(value) {
    if (!isInt(value)) {
        return false;
    }
    if (value > 4294967295 || value < 0) {
        return false;
    }
    return true;
}

/**
 * @param {any} value - test if value looks like int32
 * @returns {boolean}
 */
export function isInt32(value) {
    if (!isInt(value)) {
        return false;
    }
    if (value > 2147483647 || value < -2147483648) {
        return false;
    }
    return true;
}

/**
 * @param {any} value - test if value looks like long
 * @returns {boolean}
 */
export function isLong(value) {
    if (!isInt(value)) {
        return false;
    }
    // JavaScript can't work accurately with numbers this big. Use String manipulation instead.
    // if(9223372036854775807 < value || -9223372036854775808 > value){return false;};

    const valueAsString = `${value}`;
    const testStr = valueAsString.charAt(0) === '-' ? valueAsString.substring(1) : valueAsString;
    return isNumIsLessThan(testStr, '9223372036854775808');
}

/**
 * Checks that one number is less than another. Numbers can be of any size as the compare is based on Strings not numbers.
 * Both numbers must be positive.
 * @param {string} number1 - test if value looks like int
 * @param {string} number2 - test if value looks like int
 * @returns {boolean}
 */
export function isNumIsLessThan(number1, number2) {
    if (number1.length < number2.length) {
        return true;
    }

    const number1Str = `${number1}`;
    const number2Str = `${number2}`;
    const maxIndex = number2Str.length - 1;
    for (let i = 0; i < maxIndex; i++) {
        if (number1Str.substring(0, i) === number2Str.substring(0, i)) {
            if (number1Str.charAt(i + 1) > number2Str.charAt(i + 1)) {
                return false;
            }
            if (number1Str.charAt(i + 1) < number2Str.charAt(i + 1)) {
                return true;
            }
        }
    }
    return false;
}

/**
 * @param {any} value - test if value looks like float
 * @returns {boolean}
 */
export function isFloat(value) {
    // TODO - review handling of null values
    if (value == null || value === '') return true;
    if (isNaN(value)) return false;
    if (/^-?\d+(\.\d+)?(e(\+|\-)?\d+)?$/.test(value) === false) {
        return false;
    }
    // TODO write validation logic to check range
    return true;
}

/**
 * @param {any} value - test if value looks like double
 * @returns {boolean}
 */
export function isDouble(value) {
    // TODO - review handling of null values
    if (value == null || value === '') return true;
    if (isNaN(value)) return false;
    if (Infinity < value || -Infinity > value) {
        return false;
    }
    // if(/^[0-9]+(.[0-9]+)$/.test(value) == false){return false;};
    // TODO write validation logic to check range
    return true;
}

/**
 * @param {any} value - test if value looks like string
 * @returns {boolean}
 */
// function isString(value) {
//     if (Array.isArray(value)) return false;

//     const test = `${value}`;
//     if (test !== value || test === '[object Object]') {
//         return false;
//     }
//     return true;
// }

/**
 * @param {any} value - test if value looks like time
 * @returns {boolean}
 */
// function isTime(value) {
//     if (/^(0\d|1\d|2[0-3]):([0-5]\d):([0-5]\d)$/.test(value) === false) {
//         return false;
//     }

//     return true;
// }

/**
 *
 */
export class AbstractType {
    /** @type {any[]} */
    get _localNames() {
        return [];
    }

    /**
     * Implementations of this Class are designed to represent TC::Types.
     * This Class contains general functionality shared between all TCF Types.
     * {note}This is an Abstract class and is not designed to the instantiated directly. Instead, a concrete implementation which extends AbstractType should be instantiated.{note}
     * @param {*} [value] - This can be any value that can be successfully parsed into the data type.
     * @param {HTMLElement} [localeNode] - localNode to be used for localization settings
     */
    constructor(value, localeNode) {
        if (value !== undefined) this.setValue(value);

        this._localeKey = null;
        this._localeContext = null;

        if (localeNode) this.initLocale(localeNode);
    }

    /**
     * Should return the Class name of this data type instance.
     * @return {string} The Class name of the implementation.
     */
    getClass() {
        return this.constructor.name;
    }

    /** @returns {*} Returns the JavaScript equivalent raw value of the data type. e.g. TcfBoolean would return boolean. Int32 would return int. Double would return Number. */
    getValue() {
        return this.value;
    }

    /**
     * Sets the raw value of the data type. The value must be of the correct type for the data type being set. e.g. TcfBoolean would return boolean. Int32 would return int. Double would return Number.
     * @param {*} value - The raw value to assign to this data type
     */
    setValue(value) {
        if (value !== null && this.isValid(value) === false) {
            // TODO create our own specific Error Class that extends Error and throw that instead.
            throw new Error(
                `Incorrect Value: The supplied value is not a valid value for ${this._getValidationMessage()}`,
            );
            // window.console.log("Incorrect Value: The supplied value " + value + " is not a valid value for " + this._getClassName());
        } else this.value = value;
        return this;
    }

    /** @private */
    _getValidationMessage() {
        return this.constructor.name;
    }

    /**
     *
     * @param {HTMLElement} localeNode
     */
    initLocale(localeNode) {
        this.setLocaleContext(localeNode);
        this.setLocaleKey(localeNode);
        return { localeContext: this._localeContext, localKey: this._localeKey };
    }

    /**
     * @param {Element | HTMLElement | { localeContext: any }} localeContext
     */
    setLocaleContext(localeContext) {
        const localeCtx = localeContext || document.body;
        if (localeCtx instanceof Element) {
            this._localeContext = {};
            for (let i = 0, ancestor, name, elem = localeCtx, len = this._localNames.length; i < len; i++) {
                name = this._localNames[i];
                ancestor = elem && closest(`[${name}]`, elem);
                this._localeContext[name] = ancestor ? ancestor.getAttribute(name) || null : null;
            }
            // @ts-ignore
        } else this._localeContext = 'localeContext' in localeCtx ? localeCtx.localeContext : localeCtx;
        return this;
    }

    /**
     * @param {undefined} [localeNode]
     */
    getLocaleContext(localeNode) {
        if (!this._localeContext || localeNode) this.setLocaleContext(localeNode);
        return this._localeContext;
    }

    /**
     * Sets the localization of the data type. A behavior node is passed in. Using the behavior this function looks for the localization keys that are used by this data type. The values of these keys are used for the localization of this data type.
     * The localization values found are either stored in a variable called _localeFormat at instance level or Class level depending on whether useShared was specified.
     * @param {HTMLElement | number | { localKey: number }} [localeNode] - The Element to begin the search for localization keys/values.
     */
    setLocaleKey(localeNode) {
        if (typeof localeNode === 'number') {
            this._localeKey = localeNode;
            return this;
        }

        let localizationKey = this.getLocalizationKey();
        if (localizationKey == null) return this;

        const localeContext = localeNode || document.body;
        if (localeContext instanceof Element) {
            let ancestor = closest(`[${localizationKey}]`, localeContext) || document.body;
            this._localeKey =
                ancestor instanceof HTMLElement &&
                getProperty(ancestor, localizationKey, AbstractType.DEFAULT_LOCALE_KEY.toString());

            localizationKey = localizationKey.replace('Format', 'ParseSpec');
            ancestor = closest(`[${localizationKey}]`, localeContext) || document.body;
            this._parseKey = ancestor instanceof HTMLElement && getProperty(ancestor, localizationKey, this._localeKey);
        } else {
            this._localeKey =
                // @ts-ignore
                ('localKey' in localeContext ? localeContext.localKey : localeContext) ||
                AbstractType.DEFAULT_LOCALE_KEY;
            this._parseKey = this._localeKey;
        }

        return this;
    }

    /**
     * @param {HTMLElement | number | { localKey: number }} [localeNode]
     */
    getLocaleKey(localeNode) {
        if (!this._localeKey || localeNode) this.setLocaleKey(localeNode);
        return this._localeKey;
    }

    /**
     * @param {HTMLElement} [localeNode]
     */
    getParseKey(localeNode) {
        if (!this._parseKey || localeNode) this.setLocaleKey(localeNode);
        return this._parseKey;
    }

    // Override
    /**
     * Should return the name of the local key used by this data type to format the raw value into a display value.
     * @returns {string} The name of the local key to use for formatting.
     */
    getLocalizationKey() {
        return null;
    }

    // Must over ride this method.
    // This method is used to add some kind of type (format) safety to the values being passed though.
    // For example: when setting the value on an int16 there should be an error if a value greater than 65536 is pased through.
    //
    /**
     * Should validate that the String passed in can be parsed into this data type.
     * @abstract
     * @param {*} value - The value to attempt to parse into this data type.
     * @returns {boolean} true if the value can be parsed successfully into this data type. Otherwise, false.
     */
    validate(value) {
        return false;
    }

    /**
     * @param {*} value - The value to validate can be parsed by this data type.
     * @returns {boolean} Whether the value can parsed into this data type.
     */
    isValid(value) {
        return this.validate(value);
    }

    /**
     * Formats the raw value of the data type into a String.
     * @returns {string} String representation of the value of this data type.
     */
    toString() {
        return this.getValue() == null ? '' : this.getValue();
    }

    /**
     * Sets the value of this data type by parsing the value of the String passed in.
     * @param {string} value - The value to parse and set as the value of this data type.
     */
    fromString(value) {
        this.setValue(value);
        return this;
    }

    /**
     * Returns a comparator that can be used to compare two instances of this data type. Given two instances of this data type, a and b respectively, the comparator must correctly return:
     *   <0 if instance a is less than instance b
     *   0 if instance a is equivalent to instance b
     *   >0 if instance a is greater than instance b
     * The comparator should also deal with null values. null will typically be the lowest possible value for an Object.
     * @returns {function} Comparator as described above. Default (if not overridden) is AbstractType.compareNumbers
     */
    getComparator() {
        return numberComparator;
    }

    /** @inheritdoc */
    dispose() {}
}

AbstractType.DEFAULT_LOCALE_KEY = 255;

/** String */
export class TcfString extends AbstractType {
    /**
     * Implements {@link AbstractType#validate}
     * @param {string} value - Checks that the raw value passed in is compatible with this data type.
     * @returns {Boolean} true if the value is compatible with this data type.
     */
    validate(value) {
        return typeof value === 'string';
    }

    /**
     * Implements {@link AbstractType.getComparator}
     * Returns a comparator that can be used to compare two instances of this data type. Given two instances of this data type, a and b respectively, the comparator will return:
     * <0 if instance a is less than instance b
     * 0 if instance a is equivalent to instance b
     * >0 if instance a is greater than instance b
     * null is interpreted as the lowest possible value.
     * @returns {Function} Comparator that will compare two of this data type.
     */
    getComparator() {
        return stringComparator;
    }
}

/** CSV */
export class TcfCsv extends AbstractType {
    /**
     * Implements {@link AbstractType#validate}
     * @param {String} value - Checks that the raw value passed in is compatible with this data type.
     * @returns {Boolean} true if the value is compatible with this data type.
     */
    validate(value) {
        return typeof value === 'string';
    }

    /** @returns {string} the separator for the CSV */
    getSeperator() {
        return ',';
    }
}

TcfDataTypesMap.CSV = TcfCsv;

/** Boolean */
export class TcfBoolean extends AbstractType {
    /** Supplementary locale properies */
    get _localNames() {
        return [
            'localeBooleanYesNoShort',
            'localeBooleanYesNoLong',
            'localeBooleanTrueFalseShort',
            'localeBooleanTrueFalseLong',
            'localeBooleanTrueFalseLong',
            'localeBooleanOnOffShort',
            'localeBooleanOnOffLong',
            'localeBooleanOnOffLong',
            'localeBooleanMark',
        ];
    }

    // boolean internal value
    /**
     * Implements {@link AbstractType#validate}
     * @param {String} value - Checks that the raw value passed in is compatible with this data type.
     * @returns {Boolean} true if the value is compatible with this data type.
     */
    validate(value) {
        return value == null || typeof value === 'number' || typeof value === 'boolean';
    }

    /**
     * Implements {@link AbstractType#getLocalizationKey}
     * Return the localization key that will hold the value for this data type.
     * @returns {String} The name of the local key to use for formatting.
     */
    getLocalizationKey() {
        return 'localeFormatBoolean';
    }

    /**
     * @inheritdoc
     * @param {string | number | boolean} value
     */
    setValue(value) {
        // @ts-ignore
        if (value == null || isNaN(value)) this.value = null;
        else if (typeof value === 'number' || typeof value === 'boolean') this.value = Boolean(value).valueOf();
        return this;
    }

    /** @inheritdoc */
    toString() {
        // let formatSpec = locale.getFormatSpec(this._localeFormat, 'boolean');
        // let standardFormatter = Format.getFormatter(this.parentElement, 'boolean', formatSpec);
        // return standardFormatter.format(this.getValue());
        // note: since the internal format is a js boolean, you can format directly from it
        return locale.toLocalByKey(this.getLocaleContext(), this.getLocaleKey(), 'boolean', this.getValue());
    }

    /**
     * @param {string} value
     */
    fromString(value) {
        // let standardParser = Parse.getParser(this.parentElement, 'boolean', Parse.STANDARD);
        // this.setValue(standardParser.parse(value));
        // note: since the internal format is a js boolean, you can parse directly to it
        const standardParser = Parse.getParser(this.getLocaleContext(), 'boolean', Parse.STANDARD);
        this.setValue(standardParser.parse(value));
        return this;
    }

    /**
     * Implements {@link AbstractType#getComparator}
     * Returns a comparator that can be used to compare two instances of this data type. Given two instances of this data type, a and b respectively, the comparator will return:
     * *<0 if instance a is less than instance b
     * *0 if instance a is equivalent to instance b
     * *>0 if instance a is greater than instance b
     * null is interpreted as the lowest possible value.
     * @returns {Function} Comparator that will compare two of this data type.
     */
    getComparator() {
        return booleanComparator;
    }
}

/** Abstract number to support nuber formatting */
class AbstractNumber extends AbstractType {
    /** @inheritdoc */
    getLocalizationKey() {
        return 'localeFormatNumber';
    }

    /** @inheritdoc */
    toString() {
        const localeKey = this.getLocaleKey();
        if (localeKey)
            return (
                locale.toLocalByKey(this.getLocaleContext(), localeKey, 'number', this.getValue()) || super.toString()
            ); // TODO DEVCORE3-3732, backward compatibility, calling super if no value since localeKey may be set now
        return super.toString();
    }
}

/** Byte */
export class TcfByte extends AbstractType {
    /**
     * @param {any} value
     */
    validate(value) {
        return value == null || isByte(value);
    }
}

/** SByte */
export class TcfSByte extends TcfByte {
    /**
     * @param {any} value
     */
    validate(value) {
        return value == null || isSByte(value);
    }
}

/** Char */
export class TcfChar extends AbstractType {
    /**
     * @param {any} value
     */
    validate(value) {
        return value == null || isChar(value);
    }
}

/** Int16 */
export class TcfInt16 extends AbstractNumber {
    /**
     * @param {any} value
     */
    validate(value) {
        return value == null || isInt16(value);
    }
}

/** Uint16 */
export class TcfUInt16 extends AbstractNumber {
    /**
     * @param {any} value
     */
    validate(value) {
        return value == null || isUInt16(value);
    }
}

/** Int32 */
export class TcfInt32 extends AbstractNumber {
    /**
     * @param {any} value
     */
    validate(value) {
        return value == null || isInt32(value);
    }
}

/** UInt32 */
export class TcfUInt32 extends AbstractNumber {
    /**
     * @param {any} value
     */
    validate(value) {
        return value == null || isUInt32(value);
    }
}

/** Int64 */
export class TcfInt64 extends AbstractNumber {
    /**
     * @param {any} value
     */
    validate(value) {
        return value == null || isLong(value);
    }
}

/** UInt64 */
export class TcfUInt64 extends AbstractNumber {
    /**
     * @param {any} value
     */
    validate(value) {
        return value == null || isLong(value);
    }
}

/** Double */
export class TcfDouble extends AbstractNumber {
    /** @inheritdoc */
    getLocalizationKey() {
        return 'localeFormatDouble';
    }

    /**
     * @param {any} value
     */
    validate(value) {
        return value == null || isDouble(value);
    }

    // TODO DEVCORE3-3732, to handle in formatting framework
    /** @inheritdoc */
    toString() {
        const localeKey = this.getLocaleKey();
        // eslint-disable-next-line eqeqeq
        if (localeKey && localeKey != 255 && isNaN(localeKey) === false) {
            let format = '-#';
            const precision = new TypeInfo(0, 0, localeKey).getFormatPrecision();
            if (precision) format += `.${'#'.repeat(precision)}`;
            return locale.toLocalBySpec(this.getLocaleContext(), format, 'number', this.getValue());
        }

        return super.toString();
    }
}

/** Float */
export class TcfSingle extends AbstractNumber {
    /**
     * @param {any} value
     */
    validate(value) {
        return value == null || isFloat(value);
    }

    // TODO DEVCORE3-3732, to handle in formatting framework
    /** @inheritdoc */
    toString() {
        return TcfDouble.prototype.toString.call(this);
    }
}

//= ============== TCF::Metrics types =========================================

// All data types inherit generic code from AbstractType.
//
// Usage:
//		let weekdaysDataType = new TcfWeekdays("0101010");
//

/** Abtract Metric Type */
class MetricAbstractType extends AbstractType {
    /** Supplementary locale properies */
    get _localNames() {
        return ['localeFormatHideUnits'];
    }

    get formatDataType() {
        return '';
    }

    /** @type {any} */
    get formatParseSpec() {
        return undefined;
    }

    /** @type {any} */
    get formatFormatSpec() {
        return undefined;
    }

    /** @inheritdoc */
    toString() {
        return locale.toLocalByKey(
            this.getLocaleContext(),
            this.getLocaleKey(),
            this.formatDataType,
            this.getValue(),
            this.formatParseSpec,
        );
    }

    /**
     * @param {string} value
     */
    fromString(value) {
        this.setValue(
            locale.fromLocalByKey(
                this.getLocaleContext(),
                this.getParseKey(),
                this.formatDataType,
                value,
                this.formatFormatSpec,
            ),
        );
        return this;
    }
}

/** Metric types locale property names */
class MetricAbstractTime extends MetricAbstractType {
    get _localNames() {
        return [
            'localeFirstDOW',
            'localeToday',
            'localeNow',
            'localeMonthsMedium',
            'localeMonthsLong',
            'localeMonthsShort',
            'localeWeekdaysShort',
            'localeWeekdaysShortUnique',
            'localeWeekdaysMedium',
            'localeWeekdaysLong',
            'localeDayOrdinals',
            'localeMonthOrdinals',
            'localeFormatDateYYPivotYear',
        ];
    }
}

/** Abstract Metric Number Type */
class MetricAbstractNumberBased extends MetricAbstractType {
    /** @inheritdoc */
    toString() {
        return locale.toLocalByKey(
            this.getLocaleContext(),
            this.getLocaleKey(),
            this.formatDataType,
            `${this.getValue()}`,
            this.formatParseSpec,
        );
    }

    /**
     * @param {string} value
     */
    fromString(value) {
        this.setValue(
            parseFloat(
                locale.fromLocalByKey(
                    this.getLocaleContext(),
                    this.getParseKey(),
                    this.formatDataType,
                    value,
                    this.formatFormatSpec,
                ) || 0,
            ),
        );
        return this;
    }
}

/** Weekdays with base type string */
export class TcfWeekdaysStr extends MetricAbstractTime {
    // Validates that the value is '0101010' format.
    /**
     * @param {string} value
     */
    validate(value) {
        return value == null || value === '' || /^[-01]{1,7}$/.test(value);
    }

    /** @inheritdoc */
    _getValidationMessage() {
        return ' TcfWeekdaysStr Expecting format 0101010';
    }

    /** @inheritdoc */
    getLocalizationKey() {
        return 'localeFormatWeekdays';
    }

    get formatDataType() {
        return 'weekdays';
    }
    get formatFormatSpec() {
        return '@weekdays(0,0)';
    }

    /**
     * "Binary value" in this context is a string of 0 and 1 representing week days starting from the first day of the week.
     * This is how the weektemplate is stored in the string type. For example, "1100000" string represents "Sunday Monday - - - - -".
     * See TCF::Metrics::Weekdays class description in TCF_Metrics.cpp.
     * The "Binary value" in this context should not be confused with the integer storage of the week template,
     * where the value is stored in the binary form, and the lowest bit represents Sunday.
     * Therefore, the above string "1100000" would be integer 00000011 (bin) or 3 (dec).
     *
     * TODO - consider renaming this function to avoid confusion.
     *
     * The Weekdays behavior works with the "Binary value" string storage.
     * The WeekdaysInt type (below) inverts the true binary (integer) string to match this "Binary value" convention.
     */
    getBinaryValue() {
        return this.getValue();
    }

    /**
     * @param {any} binaryValue
     */
    setBinaryValue(binaryValue) {
        this.setValue(binaryValue);
    }

    /**
     * @param {string} [value]
     */
    getAsLong(value) {
        let valueInt = 0;
        for (let i = 0, v = value || this.value; i < v.length; i++)
            // eslint-disable-next-line no-bitwise
            valueInt += v.charAt(i) << i;
        return valueInt;
    }
}

/** Weekdays with base Int */
export class TcfWeekdaysInt extends TcfWeekdaysStr {
    // Validates that the value is -1 < int < 127.
    /**
     * @param {string | number} value
     */
    validate(value) {
        return value == null || value === '' || (isSByte(value) && value > -1);
    }

    /** @inheritdoc */
    _getValidationMessage() {
        return ' TcfWeekdaysInt Expecting format int < 128';
    }

    /**
     * @param {string | number | Date} value
     */
    setValue(value) {
        return super.setValue(value === -1 ? null : value);
    }

    /** @inheritdoc */
    getBinaryValue() {
        const value = this.getValue();
        if (value != null)
            return value
                .toString(2)
                .padStart(7, '0')
                .split("")
                .reverse()
                .join("");
        return value;
    }

    /**
     * {warn} Does not take into account the locale (e.g. first day of week settings). Consider using fromString instead which will handle these cases. {warn}
     * @param {string} binaryValue
     */
    setBinaryValue(binaryValue) {
        if (binaryValue == null || binaryValue === '') return this.setValue(null);
        return this.setValue(
            parseInt(
                `${binaryValue
                    .split('')
                    .reverse()
                    .join('')}`,
                2,
            ),
        );
    }

    /**
     * @param {string} str
     */
    fromString(str) {
        this.setBinaryValue(
            locale.fromLocalByKey(
                this.getLocaleContext(),
                this.getParseKey(),
                this.formatDataType,
                str,
                this.formatFormatSpec,
            ),
        );
        return this;
    }

    /** @inheritdoc */
    toString() {
        return locale.toLocalByKey(
            this.getLocaleContext(),
            this.getLocaleKey(),
            this.formatDataType,
            this.getBinaryValue(),
            this.formatParseSpec,
        );
    }
}

/** Time */
export class TcfTime extends MetricAbstractTime {
    // time of day in seconds from midnight
    /**
     * @param {string | number} seconds
     */
    addSeconds(seconds) {
        this.setValue(this.getValue() + seconds);
    }

    /**
     * @param {number} minutes
     */
    addMinutes(minutes) {
        this.setValue(this.getValue() + minutes * 60);
    }

    /**
     * @param {number} hours
     */
    addHours(hours) {
        this.setValue(this.getValue() + hours * 3600);
    }

    /**
     * @param {number} seconds
     */
    subtractSeconds(seconds) {
        this.setValue(this.getValue() - seconds);
    }

    /**
     * @param {number} minutes
     */
    subtractMinutes(minutes) {
        this.setValue(this.getValue() - minutes * 60);
    }

    /**
     * @param {number} hours
     */
    subtractHours(hours) {
        this.setValue(this.getValue() - hours * 3600);
    }

    /** @returns {number} hours parts of the TcfTime */
    getHours() {
        return Math.floor(this.getValue() / 3600);
    }

    /** @returns {number} minutes parts of the TcfTime */
    getMinutes() {
        return Math.floor(this.getValue() / 60) % 60;
    }

    /** @returns {number} seconds parts of the TcfTime */
    getSeconds() {
        return this.getValue() % 60;
    }

    /** Validate value passed in is an int in the range of -2147483647 and 2147483647
     * @param {any} value
     */
    validate(value) {
        return value == null || isInt32(value);
    }

    /** @inheritdoc */
    _getValidationMessage() {
        return ' TcfTime Expecting int in range -2147483647 and 2147483647';
    }

    /** Sets the value
     * @param {?TcfDateTime|number|Date} value - If {@link TcfDateTime} or {@link Date} then the value is equal to the time portion from midnight.
     */
    setValue(value) {
        if (value instanceof Date) this.fromDate(value);
        else if (value instanceof TcfDateTime) this.value = Math.floor((value.getValue() % 86400000) / 1000);
        else if (value == null || isNaN(value)) this.value = null;
        else if (typeof value === 'number' && isInt(value)) this.value = value;
        return this;
    }

    /** @inheritdoc */
    getLocalizationKey() {
        return 'localeFormatTime';
    }

    get formatDataType() {
        return 'time';
    }

    /** @inheritdoc */
    toString() {
        // Over ride toString to not use toLocalByKey since they do not require parser used by toLocalByKey
        const formatSpec = locale.getFormatSpec(this.getLocaleKey(), this.formatDataType) || this.getLocaleKey();
        const formatter = Format.getFormatter(this.getLocaleContext(), this.formatDataType, formatSpec);
        let value = this.getValue();
        if (value === -1) value = null;
        return formatter.format(value);
    }

    /**
     * @param {string} value
     */
    fromString(value) {
        const parseKey = this.getParseKey();
        const parseSpec = locale.getParseSpec(parseKey, this.formatDataType) || parseKey;
        const parser = Parse.getParser(this.getLocaleContext(), this.formatDataType, parseSpec);
        this.setValue(parser.parse(`${value}`));
        return this;
    }

    /**
     * @param {Date} date
     */
    fromDate(date) {
        this.setValue(toUTCSFM(date));
    }
}

/** TimeSpan */
export class TcfTimeSpan extends TcfTime {
    /** @inheritdoc */
    _getValidationMessage() {
        return ' TcfTimeSpan Expecting int in range -2147483647 and 2147483647';
    }

    /** @inheritdoc */
    getLocalizationKey() {
        return 'localeFormatTimeSpan';
    }

    get formatDataType() {
        return 'timespan';
    }

    /** @returns {number} minutes parts of the TcfTimeSpan */
    toMinutes() {
        return this.getValue() / 60;
    }

    /** @returns {number} hours parts of the TcfTimeSpan */
    toHours() {
        return this.getValue() / 3600;
    }

    /** @returns {number} seconds parts of the TcfTimeSpan */
    toSeconds() {
        return this.getValue();
    }

    /** @returns {number} days parts of the TcfTimeSpan */
    toDays() {
        return this.getValue() / 86400;
    }

    /** @returns {number} weeks parts of the TcfTimeSpan */
    toWeeks() {
        return this.getValue() / 604800;
    }

    /**
     * @param {string} [format]
     */
    toString(format) {
        // Over ride toString to not use toLocalByKey since they do not require parser used by toLocalByKey
        const formatSpec =
            locale.getFormatSpec(format || this.getLocaleKey(), this.formatDataType) || format || this.getLocaleKey();
        const formatter = Format.getFormatter(this.getLocaleContext(), this.formatDataType, formatSpec);
        let value = this.getValue();
        if (value === -2147483647) value = null;
        return formatter.format(value);
    }
}

/** BigTimeSpan */
export class TcfBigTimeSpan extends MetricAbstractTime {
    // milliseconds
    // Validate value passed in is an int in the range of -9223372036854775807 and 9223372036854775807
    /**
     * @param {any} value
     */
    validate(value) {
        return value == null || isLong(value);
    }

    /** @inheritdoc */
    _getValidationMessage() {
        return ' TcfBigTimeSpan Expecting int in range -9223372036854775807 and 9223372036854775807';
    }

    /**
     * @param {string | number} millSeconds
     */
    addMilliSeconds(millSeconds) {
        this.setValue(addNumbers(this.getValue() + millSeconds));
    }

    /**
     * @param {string | number} seconds
     */
    addSeconds(seconds) {
        this.setValue(this.getValue() + seconds);
    }

    /**
     * @param {number} minutes
     */
    addMinutes(minutes) {
        this.setValue(this.getValue() + minutes * 60);
    }

    /**
     * @param {number} hours
     */
    addHours(hours) {
        this.setValue(this.getValue() + hours * 3600);
    }

    /**
     * @param {string | number | Date} value
     */
    setValue(value) {
        // @ts-ignore
        if (value == null || isNaN(value)) this.value = null;
        else if (typeof value === 'number' && isInt(value)) this.value = value;
        return this;
    }

    /** @inheritdoc */
    getLocalizationKey() {
        return 'localeFormatTimeSpan';
    }

    get formatDataType() {
        return 'timespan';
    }

    /** @inheritdoc */
    toString() {
        return locale.toLocalByKey(this.getLocaleContext(), this.getLocaleKey(), 'timespan', this.getValue(), 'ms');
    }

    /**
     * @param {string} value
     */
    fromString(value) {
        this.setValue(
            Number(locale.fromLocalByKey(this.getLocaleContext(), this.getParseKey(), 'timespan', value)).valueOf() *
                1000,
        );

        const parseSpec = locale.getParseSpec(this.getLocaleKey(), 'timespan');
        const parser = Parse.getParser(this.getLocaleContext(), 'timespan', parseSpec);

        const parsedValue = parser.parse(value);

        this.setValue(parsedValue == null ? null : Math.floor(parsedValue * 1000));
        return this;
    }
}

/** Date */
export class TcfDate extends MetricAbstractTime {
    /** @returns {TcfDate} the current day (now) */
    static getTodayValue() {
        return new TcfDate().fromString('?').getValue();
    }

    /**
     * @param {string|number|Date} value
     */
    validate(value) {
        return (
            value instanceof Date ||
            // @ts-ignore
            (value == null || value === 0 || value === '0' || isNaN(value)) ||
            (typeof value === 'number' && isInt(value))
        );
    }

    /** @returns {number} the year part of this TcfDate */
    getYear() {
        return parseInt(`${this.getValue()}`.substr(0, 4), 10);
    }

    /** @returns {number} the month part of this TcfDate */
    getMonth() {
        return parseInt(`${this.getValue()}`.substr(4, 2), 10) - 1;
    }

    /** @returns {number} the date part of this TcfDate */
    getDate() {
        return parseInt(`${this.getValue()}`.substr(6, 2), 10);
    }

    /** Takes in a Long that represents a Date Object. e.g. 20090102 yyyymmdd
     * @param {?number|Date|string} value - If {@link Date} then the value is equal to the date portion and the time is dicarded. e.g. we do not round to the nearest day.
     */
    setValue(value) {
        if (value instanceof Date) {
            this.fromDate(value);
            return this;
        }

        // @ts-ignore
        if (value === null || value === 0 || value === '0' || isNaN(value)) {
            this.value = null;
        } else if (typeof value === 'number' && isInt(value)) {
            this.value = value < 16010101 ? null : value;
        }
        return this;
    }

    /** @inheritdoc */
    getLocalizationKey() {
        return 'localeFormatDate';
    } // localeDateFormat

    get formatDataType() {
        return 'date';
    }

    /**
     * @param {string} [format]
     */
    toString(format) {
        let value = this.getValue();
        if (value === 0) value = null;
        if (format) return locale.toLocalBySpec(this.getLocaleContext(), format, 'date', value);
        return locale.toLocalByKey(this.getLocaleContext(), this.getLocaleKey(), 'date', value);
    }

    /**
     * @param {string} value
     * @param {undefined} [format]
     */
    fromString(value, format) {
        this.setValue(
            Number(
                locale.fromLocalByKey(this.getLocaleContext(), format || this.getParseKey(), 'date', value),
            ).valueOf(),
        );
        return this;
    }

    /** Takes the date portion of the JavaScript Date objects date value and sets it as the value.
     * @param {Date} date - the date to set.
     */
    fromDate(date) {
        const year = date.getUTCFullYear();
        const month = `${date.getUTCMonth() + 1}`;
        const day = `${date.getUTCDate()}`;
        const dateInt = parseInt(`${year}${month.padStart(2, '0')}${day.padStart(2, '0')}`, 10);
        this.setValue(dateInt);
        return this;
    }

    /** Converts this Date to a JavaScript Date Object assumes that this {TcfDate} is UTC.
     * @returns {Date} Date representing the current date. Hours, minutes, seconds and millisecods will be 0.
     */
    toDate() {
        const d = new Date();
        d.setUTCFullYear(this.getYear(), this.getMonth(), this.getDate());
        d.setUTCHours(0);
        d.setUTCMinutes(0);
        d.setUTCSeconds(0);
        d.setUTCMilliseconds(0);
        return d;
    }
}

/** DateTime */
export class TcfDateTime extends MetricAbstractTime {
    /** @returns {TcfDateTime} now */
    static now() {
        return new TcfDateTime(new Date());
    }

    // Takes in an int64 (milliseconds since the windows epoch) that represents a DateTime Object.
    // TODO make a more specific validator.
    /**
     * @param {any} value
     */
    validate(value) {
        return value instanceof Date || (typeof value === 'number' && isInt(value));
    }

    /**
     * @param {string | number | Date} value
     */
    setValue(value) {
        if (value instanceof Date) this.value = toUTC(value).getTime() + windowsEpochMilliseconds;
        // @ts-ignore
        else if (value == null || isNaN(value)) this.value = null;
        else if (typeof value === 'number' && isInt(value)) this.value = value;
        return this;
    }

    /** Lets you set the time portion of the DateTime
     * @param {TcfTime} time - Time to set on the DateTime - Must be UTC time
     */
    setTime(time) {
        const date = toLocale(this.toDate());
        date.setHours(time.getHours());
        date.setMinutes(time.getMinutes());
        date.setSeconds(time.getSeconds());
        this.setValue(date);
        return this;
    }

    /** Gets the time portion of the DateTime
     * @returns {TcfTime} time - Time portion of the DateTime - In UTC
     */
    getTime() {
        return new TcfTime(this);
    }

    /** Lets you set the date portion of the DateTime
     * @param {TcfDate} date - Date to set on the DateTime - Must be UTC date
     */
    setDate(date) {
        const d = this.toDate();
        d.setUTCFullYear(date.getYear(), date.getMonth(), date.getDate());
        const oldValue = date.toDate();
        const fromMidnight = toUTCMFM(this.toDate());
        oldValue.setTime(new Date(date.toString('yyyy-MM-dd')).getTime() + fromMidnight);
        this.setValue(oldValue.getTime() + windowsEpochMilliseconds);
        return this;
    }

    /** Gets the date portion of the DateTime
     * @returns {TcfDate} date - Date portion of the DateTime
     */
    getDate() {
        const date = this.toDate();
        return new TcfDate(date);
    }

    /** Calculates the difference between this {Cre.Type.Metric.DateTime} and one passed in. The difference is returned as a {TcfTimespan}.
     * @param {TcfDateTime} dateTime - The dateTime to minus from this.
     * @param {HTMLElement} [localeNode] - The Element to begin the search for localization keys/values.
     * @returns {TcfTimeSpan} timespan - Timespan of the time between the two dates. this - dateTime passed in.
     */
    diff(dateTime, localeNode) {
        const difference = this.getValue() - dateTime.getValue();
        return new TcfTimeSpan(Math.round(difference / 1000), localeNode);
    }

    /** @inheritdoc */
    getLocalizationKey() {
        return 'localeFormatDateTime';
    }

    get formatDataType() {
        return 'datetime';
    }
    get formatParseSpec() {
        return Parse.MILLIS;
    }
    get formatFormatSpec() {
        return Format.MILLIS;
    }

    /**
     * @param {string} [format]
     */
    toString(format) {
        const value = this.getValue();

        const jsMillis = value == null ? null : value - windowsEpochMilliseconds;

        const localTimeOffsetMills = new Date(jsMillis).getTimezoneOffset() * 60000;

        if (format)
            return locale.toLocalBySpec(
                this.getLocaleContext(),
                format,
                'datetime',
                jsMillis + localTimeOffsetMills,
                this.formatParseSpec,
            );
        return locale.toLocalByKey(
            this.getLocaleContext(),
            this.getLocaleKey(),
            'datetime',
            jsMillis + localTimeOffsetMills,
            this.formatParseSpec,
        );
    }

    /**
     * @param {string} value
     * @param {undefined} [format]
     */
    fromString(value, format) {
        const standardValue = locale.fromLocalByKey(
            this.getLocaleContext(),
            format || this.getParseKey(),
            'datetime',
            value,
            this.formatFormatSpec,
        );

        const jsMillis = Number(standardValue).valueOf();

        // hack to handle when near the DST switchover
        let localTimeOffsetMills = new Date(jsMillis).getTimezoneOffset() * 60000;
        localTimeOffsetMills = new Date(jsMillis - localTimeOffsetMills).getTimezoneOffset() * 60000;
        localTimeOffsetMills = new Date(jsMillis - localTimeOffsetMills).getTimezoneOffset() * 60000;

        this.setValue(jsMillis + windowsEpochMilliseconds - localTimeOffsetMills);

        return this;
    }

    /** Converts this DateTime to a JavaScript Date Object
     * @returns {Date} Date representing the current value, performs a UTC to local time zone conversion
     */
    toDate() {
        let date = this.getValue();
        if (date) {
            date = new Date(this.getValue() - windowsEpochMilliseconds);
            // date = date.toLocale();
        } else date = new Date(86400000);
        return date;
    }
}

/** Distance */
export class TcfDistance extends MetricAbstractNumberBased {
    // Value must be in meters
    /**
     * @param {any} value
     */
    validate(value) {
        return value == null || isDouble(value);
    }

    /** @inheritdoc */
    getLocalizationKey() {
        return 'localeFormatDistance';
    }

    get formatDataType() {
        return 'distance';
    }
    
    get formatParseSpec() {
        return locale.parseSpecs.distance['5'];
    }
    
    get formatFormatSpec() {
        return locale.formatSpecs.distance['5'];
    }

    /** @inheritdoc */
    toString() {
        let localeKey = this.getLocaleKey();
        const value = this.getValue();
        if (value >= 1000) {
            if (localeKey === '6') {
                // Auto metric
                localeKey = '1';
            } else if (localeKey === '7' || localeKey === '8') {
                // Auto imperial or meters/miles
                localeKey = '2';
            }
        }

        return locale.toLocalByKey(
            this.getLocaleContext(),
            localeKey,
            this.formatDataType,
            `${value}`,
            this.formatParseSpec,
        );
    }

    // toString() { return locale.toLocalByKey(this.parentElement, this._localeFormat, this.formatDataType, "" + this.getValue(), locale.parseSpecs.distance["5"]); },
    // fromString(value) { this.setValue(new Number(locale.fromLocalByKey(this.parentElement, this._localeFormat, this.formatDataType, value, this.formatFormatSpec)).valueOf()); }
}

/** Distance with base Int */
export class TcfDistanceInt extends TcfDistance {
    // Value must be in meters
    /**
     * @param {any} value
     */
    validate(value) {
        return value == null || isInt(value);
    }

    get formatFormatSpec() {
        return '-#@units(m)';
    }
    // toString() { return locale.toLocalByKey(this.parentElement, this._localeFormat, "distance", "" + this.getValue(), locale.parseSpecs.distance["5"]); },

    // fromString(value) { this.setValue(new Number(locale.fromLocalByKey(this.parentElement, this._localeFormat, "distance", value, "-#@units(m)")).valueOf()); }
}

/** Speed */
export class TcfSpeed extends MetricAbstractNumberBased {
    // Value must be in KPH
    /**
     * @param {any} value
     */
    validate(value) {
        return value == null || isDouble(value);
    }

    /** @inheritdoc */
    getLocalizationKey() {
        return 'localeFormatSpeed';
    }

    get formatDataType() {
        return 'speed';
    }
    get formatParseSpec() {
        return locale.parseSpecs.speed['3'];
    }
    get formatFormatSpec() {
        return locale.formatSpecs.speed['3'];
    }

    // toString () { return locale.toLocalByKey(this.parentElement, this._localeFormat, "speed", "" + this.getValue(), this.formatParseSpec); },

    // fromString(value) { this.setValue(new Number(locale.fromLocalByKey(this.parentElement, this._localeFormat, "speed", value, formatFormatSpec)).valueOf()); }
}

/** Volume */
export class TcfVolume extends MetricAbstractNumberBased {
    // Value must be in Liters
    /**
     * @param {any} value
     */
    validate(value) {
        return value == null || isDouble(value);
    }

    /** @inheritdoc */
    getLocalizationKey() {
        return 'localeFormatVolume';
    }

    get formatDataType() {
        return 'volume';
    }
    get formatParseSpec() {
        return locale.parseSpecs.volume['1'];
    }
    get formatFormatSpec() {
        return locale.formatSpecs.volume['1'];
    }

    // toString () { return locale.toLocalByKey(this.parentElement, this._localeFormat, "volume", "" + this.getValue(), this.formatParseSpec); },

    // fromString(value) { this.setValue(new Number(locale.fromLocalByKey(this.parentElement, this._localeFormat, "volume", value, this.formatFormatSpec)).valueOf()); }
}

/** Pressure */
export class TcfPressure extends MetricAbstractNumberBased {
    // Value must be in KPa
    /**
     * @param {any} value
     */
    validate(value) {
        return value == null || isDouble(value);
    }

    /** @inheritdoc */
    getLocalizationKey() {
        return 'localeFormatPressure';
    }

    get formatDataType() {
        return 'pressure';
    }
    get formatParseSpec() {
        return locale.parseSpecs.pressure['1'];
    }
    get formatFormatSpec() {
        return locale.formatSpecs.pressure['1'];
    }

    // toString () { return locale.toLocalByKey(this.parentElement, this._localeFormat, "pressure", "" + this.getValue(), this.formatParseSpec); },

    // fromString(value) { this.setValue(new Number(locale.fromLocalByKey(this.parentElement, this._localeFormat, "pressure", value, this.formatFormatSpec)).valueOf()); }
}

/** Acceleration */
export class TcfAcceleration extends MetricAbstractNumberBased {
    // Value must be in m/s^2
    /**
     * @param {any} value
     */
    validate(value) {
        return value == null || isDouble(value);
    }

    /** @inheritdoc */
    getLocalizationKey() {
        return 'localeFormatAcceleration';
    }

    get formatDataType() {
        return 'acceleration';
    }
    get formatParseSpec() {
        return locale.parseSpecs.acceleration['1'];
    }
    get formatFormatSpec() {
        return locale.formatSpecs.acceleration['1'];
    }

    // toString () { return locale.toLocalByKey(this.parentElement, this._localeFormat, "acceleration", "" + this.getValue(), this.formatParseSpec); },

    // fromString(value) { this.setValue(new Number(locale.fromLocalByKey(this.parentElement, this._localeFormat, "acceleration", value, this.formatFormatSpec)).valueOf()); }
}

/** Temperature */
export class TcfTemperature extends MetricAbstractNumberBased {
    // Value must be in Celsius
    /**
     * @param {any} value
     */
    validate(value) {
        return value == null || isDouble(value);
    }

    /** @inheritdoc */
    getLocalizationKey() {
        return 'localeFormatTemperature';
    }

    get formatDataType() {
        return 'temperature';
    }
    get formatParseSpec() {
        return locale.parseSpecs.temperature['1'];
    }
    get formatFormatSpec() {
        return locale.formatSpecs.temperature['1'];
    }

    /** @inheritdoc */
    toString() {
        return locale.toLocalByKey(
            this.getLocaleContext(),
            this.getLocaleKey(),
            'temperature',
            `${this.getValue()}`,
            this.formatParseSpec,
        );
    }

    // fromString(value) { this.setValue(new Number(locale.fromLocalByKey(this.parentElement, this._localeFormat, "temperature", value, this.formatFormatSpec)).valueOf()); }
}

/** Fuel Economy */
export class TcfFuelEconomy extends MetricAbstractNumberBased {
    // Value must be in Liters per 100KM
    /**
     * @param {any} value
     */
    validate(value) {
        return value == null || isDouble(value);
    }

    /** @inheritdoc */
    getLocalizationKey() {
        return 'localeFormatFuelEconomy';
    }

    get formatDataType() {
        return 'fueleconomy';
    }
    get formatParseSpec() {
        return locale.parseSpecs.fueleconomy['2'];
    }
    get formatFormatSpec() {
        return locale.formatSpecs.fueleconomy['2'];
    }

    // toString () { return locale.toLocalByKey(this.parentElement, this._localeFormat, "fuelEconomy", "" + this.getValue(), this.formatParseSpec); },

    // fromString(value) { this.setValue(new Number(locale.fromLocalByKey(this.parentElement, this._localeFormat, "fuelEconomy", value, this.formatFormatSpec)).valueOf()); }
}

/** Weight */
export class TcfWeight extends MetricAbstractNumberBased {
    // Value must be in Kilograms
    /**
     * @param {any} value
     */
    validate(value) {
        return value == null || isDouble(value);
    }

    /** @inheritdoc */
    getLocalizationKey() {
        return 'localeFormatWeight';
    }

    get formatDataType() {
        return 'weight';
    }
    get formatParseSpec() {
        return locale.parseSpecs.weight['1'];
    }
    get formatFormatSpec() {
        return locale.formatSpecs.weight['1'];
    }

    /** @inheritdoc */
    toString() {
        let localeKey = this.getLocaleKey();
        const value = this.getValue();
        if (value >= 1000) {
            if (localeKey === '8') {
                // Auto metric
                localeKey = '3';
            } else if (localeKey === '9') {
                // Auto imperial
                localeKey = '7';
            }
        } else if (value < 1) {
            if (localeKey === '8') {
                // Auto metric
                localeKey = '2';
            } else if (localeKey === '9') {
                // Auto imperial
                localeKey = '5';
            }
        }

        return locale.toLocalByKey(
            this.getLocaleContext(),
            localeKey,
            this.formatDataType,
            `${value}`,
            this.formatParseSpec,
        );
    }

    // toString () { return locale.toLocalByKey(this.parentElement, this._localeFormat, "weight", "" + this.getValue(), this.formatParseSpec); },

    // fromString(value) { this.setValue(new Number(locale.fromLocalByKey(this.parentElement, this._localeFormat, "weight", value, this.formatFormatSpec)).valueOf()); }
}

/** ColorRef */
export class TcfColorRef extends MetricAbstractType {
    /**
     * @param {number} value
     */
    validate(value) {
        return typeof value === 'number' && value >= 0 && value <= 0xffffffff;
    }

    /** @inheritdoc */
    _getValidationMessage() {
        return 'TcfColorRef expecting an integer between 0 to 4294967295 (0xFFFFFFFF)';
    }

    /** @inheritdoc */
    getLocalizationKey() {
        return 'localeFormatColorRef';
    }

    get formatDataType() {
        return 'colorRef';
    }

    /** @inheritdoc */
    toString() {
        if (this.value == null) return '';

        const localeFormat = this.getLocaleKey();
        colorFromCOLORREF(this.value, TcfColorRef.COLOR_OBJ);
        switch (parseInt(localeFormat, 10)) {
            case 2:
                return `0x${TcfColorRef.COLOR_OBJ.toCOLORREF()
                    .toString(16)
                    .padStart(6, '0')}`;
            case 3:
                return TcfColorRef.COLOR_OBJ.toCOLORREF();
            case 4:
                return `0x${TcfColorRef.COLOR_OBJ.toHex(true).substr(1)}`;
            case 5:
                // eslint-disable-next-line no-bitwise
                return (this.getValue() | 0xff000000) >>> 0;
            case 255:
                return this.getValue();
            default: {
                const params = locale.getFormatSpec(localeFormat, this.formatDataType);
                return TcfColorRef.COLOR_OBJ.toCss(params.alpha, params.format);
            }
        }
    }

    // TODO can't distinguish between ARGB and COLORREF raw values...
    /**
     * @param {string} value
     */
    fromString(value) {
        const valueInt = Object.prototype.toString.call(value) === '[object String]' && /^[0-9]+$/.test(value) ? parseInt(value, 10) : value;
        if (valueInt === null || this.isValid(valueInt)) this.setValue(valueInt);
        else this.setValue(TcfColorRef.COLOR_OBJ.setColor(valueInt).toCOLORREF());
        return this;
    }
}

TcfColorRef.COLOR_OBJ = new Color();

/** Color */
export class TcfColor extends MetricAbstractType {
    /**
     * @param {TcfColor} dt
     */
    static FORMATTER_2(dt) {
        return TcfColor.COLOR_OBJ.setColor(dt.value)
            .toCOLORREF()
            .toString(16)
            .padStart(6, '0');
    }
    /**
     * @param {TcfColor} dt
     */
    static FORMATTER_3(dt) {
        return TcfColor.COLOR_OBJ.setColor(dt.value).toCOLORREF();
    }
    /**
     * @param {TcfColor} dt
     */
    static FORMATTER_4(dt) {
        // eslint-disable-next-line no-bitwise
        return `0x${TcfColor.COLOR_OBJ.setColor((dt.value | 0xff000000) >>> 0)
            .toHex(true)
            .substr(1)}`;
    }
    /**
     * @param {TcfColor} dt
     */
    static FORMATTER_5(dt) {
        // eslint-disable-next-line no-bitwise
        return (dt.getValue() | 0xff000000) >>> 0;
    }
    /**
     * @param {TcfColor} dt
     */
    static FORMATTER_255(dt) {
        return dt.getValue();
    }
    /**
     * @param {TcfColor} dt
     * @param {number} localeFormat
     */
    static FORMATTER_DEFAULT(dt, localeFormat) {
        const params = locale.getFormatSpec(localeFormat, dt.formatDataType);
        const alpha = localeFormat === 1 ? false : params.alpha;
        // eslint-disable-next-line no-bitwise
        return TcfColor.COLOR_OBJ.setColor((dt.value | 0xff000000) >>> 0).toCss(alpha, params.format);
    }

    /**
     * @param {number} value
     */
    validate(value) {
        return typeof value === 'number' && value >= 0 && value <= 0xffffffff;
    }

    /** @inheritdoc */
    _getValidationMessage() {
        return 'TcfColor expecting an integer between 0 to 4294967295 (0xFFFFFFFF)';
    }

    /** @inheritdoc */
    getLocalizationKey() {
        return 'localeFormatColor';
    }

    get formatDataType() {
        return 'color';
    }

    /** @inheritdoc */
    toString() {
        if (this.value == null) return '';

        const localeFormat = this.getLocaleKey() || 255;
        return (TcfColor[`FORMATTER_${localeFormat}`] || TcfColor.FORMATTER_DEFAULT)(this, localeFormat);
    }

    /**
     * @param {string|number} value
     */
    fromString(value) {
        let valueInt = Object.prototype.toString.call(value) === '[object String]' && /^[0-9]+$/.test(value) ? parseInt(value, 10) : value;

        if (valueInt === null || this.isValid(valueInt)) {
            // eslint-disable-next-line no-bitwise
            if (valueInt !== null) valueInt = (valueInt | 0xff000000) >>> 0;
            this.setValue(valueInt);
        } else {
            TcfColor.COLOR_OBJ.setColor(0);
            TcfColor.COLOR_OBJ.setColor(value);
            TcfColor.COLOR_OBJ.a = 1;
            this.setValue(TcfColor.COLOR_OBJ.toInt(true));
        }
        return this;
    }
}

TcfColor.COLOR_OBJ = new Color();

/** Color with Alpha */
export class TcfColorAlpha extends TcfColor {
    /**
     * @param {TcfColorAlpha} dt
     */
    static FORMATTER_4(dt) {
        return `0x${TcfColorAlpha.COLOR_OBJ.setColor(dt.value)
            .toHex(true)
            .substr(1)}`;
    }
    /**
     * @param {TcfColorAlpha} dt
     */
    static FORMATTER_5(dt) {
        return dt.getValue();
    }
    /**
     * @param {TcfColorAlpha} dt
     * @param {number} localeFormat
     */
    static FORMATTER_DEFAULT(dt, localeFormat) {
        const params = locale.formatSpecs.color[localeFormat];
        const alpha = localeFormat === 1 ? true : params.alpha;
        return TcfColorAlpha.COLOR_OBJ.setColor(dt.value).toCss(alpha, params.format);
    }

    /** @inheritdoc */
    _getValidationMessage() {
        return 'TcfColorAlpha expecting an integer between 0 to 4294967295 (0xFFFFFFFF)';
    }

    /** @inheritdoc */
    getLocalizationKey() {
        return 'localeFormatColorAlpha';
    }

    get formatDataType() {
        return 'colorAlpha';
    }

    /**
     * @param {string|number} value
     */
    fromString(value) {
        const valueInt = Object.prototype.toString.call(value) === '[object String]' && /^[0-9]+$/.test(value) ? parseInt(value, 10) : value;
        if (valueInt === null || this.isValid(valueInt)) this.setValue(valueInt);
        else this.setValue(TcfColorAlpha.COLOR_OBJ.setColor(valueInt).toInt(true));
        return this;
    }
}

//---------------------------------------------------------
// Basic abstract matrix data type.
//

/** Variant */
export class TcfVariant extends AbstractType {
    /**
     * @inheritdoc
     * @param {any} value
     */
    validate(value) {
        return true;
    } // variant can be anything
}

export const basicDatatypeMap = new Map();
basicDatatypeMap.set(TCFType.TCF_Boolean, TcfBoolean);
basicDatatypeMap.set(TCFType.TCF_Byte, TcfByte);
basicDatatypeMap.set(TCFType.TCF_SByte, TcfSByte);
basicDatatypeMap.set(TCFType.TCF_Char, TcfChar);
basicDatatypeMap.set(TCFType.TCF_WChar, TcfChar);
basicDatatypeMap.set(TCFType.TCF_Int16, TcfInt16);
basicDatatypeMap.set(TCFType.TCF_UInt16, TcfUInt16);
basicDatatypeMap.set(TCFType.TCF_Int32, TcfInt32);
basicDatatypeMap.set(TCFType.TCF_UInt32, TcfUInt32);
basicDatatypeMap.set(TCFType.TCF_Int64, TcfInt64);
basicDatatypeMap.set(TCFType.TCF_UInt64, TcfUInt64);
basicDatatypeMap.set(TCFType.TCF_Double, TcfDouble);
basicDatatypeMap.set(TCFType.TCF_Single, TcfSingle);
basicDatatypeMap.set(TCFType.TCF_STR, TcfString);
basicDatatypeMap.set(TCFType.TCF_WSTR, TcfString);
basicDatatypeMap.set(TCFType.TCF_String, TcfString);
basicDatatypeMap.set(TCFType.TCF_Variant, TcfVariant);
