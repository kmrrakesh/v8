// @ts-check
import { clone as jsonClone } from '@trapezegroup/core-js-extensions/src/lib/json.js';
import { AbstractType, basicDatatypeMap, getDataType } from './types.js';
import { TCFType } from './typeInfo.js';
import { rowsetUtil } from './rowsetUtil.js';

/**
 * @param {any} value - test if value looks like Rowset
 * @returns {boolean}
 */
function isRowset(value) {
    // TODO - review handling of null values
    if (value == null) {
        return true;
    }

    // TODO - perform a throrough test for rowset pieces
    if (value instanceof Rowset || (value.header && value.data) || Array.isArray(value)) {
        return true;
    }

    return false;
}

/**
 * A basic matrix data type abstraction. The data stored in the AbtractMatrix must be a 2 dimensional Array which will form the matrix. The first dimension will form the rows of the matrix and a second dimension will form the columns. The values in the second dimension Array will be the represent the value of each matrix cell.
 * {note}This is an Abstract class and is not designed to the instantiated directly. Instead, a concrete implementation which extends Core.Type.AbstractMatrix should be instantiated.{note}
 */
export class AbstractMatrix extends AbstractType {
    /**
     * @param {any} obj
     */
    static instanceOf(obj) {
        return obj instanceof AbstractMatrix;
    }

    /**
     * Gets the current backing data
     */
    getValue() {
        return this.json;
    }

    /**
     * @param {string | number | Date} value
     */
    setValue(value) {
        if (value !== null && this.isValid(value) === false) {
            // TODO create our own specific Error Class that extends Error and throw that instead.
            throw new Error(
                `Incorrect Value: The supplied value is not a valid value for ${this._getValidationMessage()}`,
            );
        } else {
            this.setData(value);
        }

        return this;
    }

    /**
     * @param {any} value
     */
    validate(value) {
        return isRowset(value);
    }

    /**
     * @returns {string}
     */
    toString() {
        return this.getValue() == null ? '' : JSON.stringify(this.getValue());
    }

    /**
     * @param {string} value
     */
    fromString(value) {
        this.setValue(JSON.parse(value));
        return this;
    }

    /**
     * Sets the object that we be used as the backing data for this AbstractMatrix
     * @param {Object} rawJsonRowset -
     * @property {Array} rawJsonRowset.data - 2 dimensional Array repreneting rows, columns, and matrix cell values.
     */
    setData(rawJsonRowset) {
        this.json = rawJsonRowset;
    }

    /**
     * Returns the value of a cell in the matrix.
     * @param {number} row - The row the cell whose value to retrieve exists in
     * @param {number} col - The column the cell whose value to retrieve exists in
     * @returns {Object} The value that resides in the cell which exists at the row and column specified. The value could be any Object.
     */
    getCell(row, col) {
        return this.json.data[row][col];
    }

    /**
     * Sets the value of a cell which resides at the row and column specified.
     * @param {number} row - The row the cell whose value to retrieve exists in
     * @param {number} col - The column the cell whose value to retrieve exists in
     * @param {Object} value - The value to place in the cell which exists at the row and column specified. The value could be any Object.
     */
    setCell(row, col, value) {
        this.json.data[row][col] = value;
    }

    /**
     * Should return a hexdecimal String that describes the data type of the value of a given cell. The data type returned should exist as a key in the Core.Type.DataTypesMap.
     * @param {Number} row - The row in the matrix containing the cell whose data type will be retrieved
     * @param {Number} col - The column in the matrix containing the cell whose data type will be retrieved
     * @returns {String} Hexadecimal String that describes the data type of the value of a given cell. The data type returned should exist as a key in the Core.Type.DataTypesMap
     * @abstract
     */
    getCellDataType(row, col) {
        throw new Error('Core.Type.AbstractMatrix: Unimplemented method getCellDataType');
    }

    /**
     * Should return a default value for a given cell.
     * @param {Number} row - The row in the matrix containing the cell whose default value will be retrieved
     * @param {Number} col - The column in the matrix containing the cell whose default value will be retrieved
     * @returns {Object} The default value for the given cell
     * @abstract
     */
    getCellDefault(row, col) {
        throw new Error('Core.Type.AbstractMatrix: Unimplemented method getCellDefault');
    }

    /**
     * Checks if there is currently ant data being stored in this matrix.
     * @returns {Boolean} true if the matrix contains any data. Otherwise false is returned.
     */
    hasData() {
        return !!(this.json && this.json.data && this.json.data.length > 0);
    }

    /**
     * Returns the number of rows currently being stored in this matrix.
     * @returns {Number} Number of rows in matrix
     */
    getRowCount() {
        return this.json.data.length;
    }

    /**
     * Returns the number of columns currently being stored in this matrix.
     * @returns {Number} Number of columns in matrix
     */
    getColCount() {
        return this.json.header.length;
    }

    /**
     * Returns the specified row index.
     * @param {*} row - Row index
     * @returns {*} Returns the specified row index
     */
    getRowIndex(row) {
        return row;
    }

    /**
     * Returns the index of a column whose name matches the name passed in.
     * @param {string|number} colName - The name of the column whose index will be returned.
     * @param {boolean} [_treatNumberAsColumnName] - Whether to treat the colName as an index
     * @returns {number} The column index of the first column found whose name matches the name passed in. If a column of that name can not be found then null is returned.
     */
    getColIndex(colName, _treatNumberAsColumnName) {
        return -1;
    }

    /** */
    getColumnName(row, col) {
        return null;
    }

    /**
     * Adds an empty row to the matrix. Each cell in the row is given a value of an empty String
     * @returns {Number} The new number of rows in the matrix
     */
    addRow() {
        const rowCount = this.json.data.length;
        this.json.data[rowCount] = [];
        for (let i = 0, len = this.getColCount(); i < len; i++) this.json.data[rowCount][i] = '';

        return this.json.data.length - 1;
    }

    /**
     * @param {number} row - The row index to check exists.
     * @param {number} [col] - The column that contains the field that exists in the row being checked for existence.
     * @returns {boolean} Whether the row index exists in the matrix
     */
    hasRow(row, col) {
        return !!(this.json.data[row] !== undefined || row === -1);
    }

    // Returns the Row index of the first value found in the column specified.
    // value can be a single value or an Array of values that represent columns of the row to find.
    /**
     * {note}Review this function. It looks to be used by the grid plug-ins.{note}
     * @param {any[]|any} values
     * @param {number} [startRow]
     * @param {number} [startCol]
     */
    indexOf(values, startRow, startCol) {
        const sr = typeof startRow === 'undefined' ? 0 : startRow;
        const sc = typeof startCol === 'undefined' ? 0 : startCol;

        if (values instanceof Array)
            for (let i = sr, row, len = this.json.data.length, valuesLen = values.length; i < len; i++) {
                row = this.json.data[i];
                // eslint-disable-next-line no-plusplus
                for (let j = 0, col = sc; j < valuesLen; j++, col++) {
                    if (row[col] !== values[j]) break;
                    if (j === valuesLen - 1) return i;
                }
            }
        else
            for (let i = sr, row, len = this.json.data.length; i < len; i++) {
                row = this.json.data[i];
                if (row[sc] === values) return i;
            }
        return -1;
    }

    /**
     * Retrieves a Rowset attribute by name.
     * @param {String} name - Name of the attribute to retrieve
     * @returns {String} The value of the Rowset attribute. If the Rowset attribute does not exist then undefined will be returned.
     */
    getAttribute(name) {
        return this.json.attrbiutes && this.json.attributes[name];
    }
}

/**
 * Rowset data type
 */
export class Rowset extends AbstractMatrix {
    /**
     * Returns whether the object passed in is an instance of Rowset
     * @param {Object} obj - The object to test the instance of
     * @returns {boolean} true if the object is an instance of Rowset. Otherwise false is returned
     */
    static instanceOf(obj) {
        return obj instanceof Rowset;
    }

    /** Iterates through the collection passed in and creates a Rowset from it.
     * @param {Object[]} rowsetArray - Array of like JSON Objects and coerces them into a Core.Tyope.Rowset. For example: {html}<pre>[{foo: 1, bar: 4},{foo: 9, bar: 4},{foo: 4, bar 34, z: 45}]</pre>{html}
     */
    static fromArray(rowsetArray) {
        const rowset = new Rowset();
        const colIndices = {};

        if (!rowsetArray || !rowsetArray.length) return rowset;

        const map = rowsetArray[0];
        const nestedRowsets = {};

        for (let i = 0, keys = Object.keys(map), iLen = keys.length; i < iLen; i++) {
            const colName = keys[i];
            let colType = null;
            switch (typeof map[colName]) {
                case 'string':
                    colType = TCFType.TCF_String;
                    break;
                case 'boolean':
                    colType = TCFType.TCF_Boolean;
                    break;
                case 'number':
                    colType = TCFType.TCF_Double;
                    break;
                default:
                    if (Array.isArray(map[colName])) {
                        colType = TCFType.TCF_Rowset;
                        nestedRowsets[colName] = 1;
                    } else colType = TCFType.TCF_Variant;
                    break;
            }
            colIndices[colName] = rowset.addCol(colName, colType.toString(16).toUpperCase());
        }

        const colNames = Object.keys(colIndices);

        for (let i = 0, len = rowsetArray.length; i < len; i++) {
            const obj = rowsetArray[i];
            const rowData = [];
            for (let j = 0, jLen = colNames.length; j < jLen; j++) {
                const colName = colNames[j];
                rowData[colIndices[colName]] = colName in nestedRowsets ? Rowset.fromArray(obj[colName]) : obj[colName];
            }
            rowset.addRow(rowData);
        }
        return rowset;
    }

    /**
     * Normalizes the specified column name.
     * This method should be used when working with column names externally from the rowset.
     * @param {string|number} colName
     */
    static normalizeColumnName(colName) {
        return colName == null ? null : colName.toString().toUpperCase();
    }

    /**
     * Normalizes an array of column names, and returns a map to the original column names.
     * This is useful when normalized column names are worked internally within a class, but the original column name is returned.
     * @param {any[]} colNames
     */
    static normalizeColumnNames(colNames) {
        const colNameMap = {};

        for (let c = 0, cols = colNames.length; c < cols; c++) {
            const normalizedColName = Rowset.normalizeColumnName(colNames[c]);
            colNameMap[normalizedColName] = colNames[c];
            colNames[c] = normalizedColName;
        }

        return colNameMap;
    }

    /** @typedef {{name: string; type: string}} RowsetHeader */
    /**
     * @typedef {Object} RowsetData 
     * @property {string} [RowsetData._TCF_Rowset] -
     * @property {number} [RowsetData.mode] -
     * @property {Array} [RowsetData.defaults] -
     * @property {Array[]} RowsetData.data -
     * @property {Array[RowsetHeader]} RowsetData.header -
     */

    /**
     * This class is designed to mimic the data type TCF_ROWSET in the client. The aim is to provide JavaScript functions that resemble the operations available in the TCF_ROWSET.
     * A TCF_ROWSET is serialized (to JSON) on the server, transferred to the client, and passed to the Rowset in client. The Rowset can then be used to accessed and mutate the serialized TCF_ROWSET on the client and sent back to the server.
     * This gives the benefit of always working with the data in Rowset format both on the server and the client.
     * Generally speaking, Rowset simply acts as an API to mutate the serialized TCF_ROWSET received form the server application. The same serialized Object is sent back to the server. This means that no parsing or formatting of the serialized Rowset is required on the client side.
     * Rowset can also be used to create new Rowsets. This is done by default when no data Object is passed to the constructor and then using the functions to add data to the Rowset.
     * In it's most basic form a skeleton serialized TCF_ROWSET is expected to look like:
     * {code}{ _TCF_Rowset: "version=1", name: "", mode: 0, attributes: {}, header: [], defaults: [], data: [] }{code}
     * @param {Rowset|RowsetData} [rawJsonRowset] - If not specified a new serialized Rowset object will be created. If Rowset then the underlying serialized TCF_Rowset of that Rowset will be used. If an Object then it is assumed that the Object is a serialized TCF_ROWSET.
     */
    constructor(rawJsonRowset) {
        super();

        this.setRowset(rawJsonRowset);
        this.colIndices = {};
        this.layoutColCount = undefined;
        this.layoutRowCount = undefined;
    }

    /**
     * Sets the name property of the serialized TCF_ROWSET.
     * @param {String} name - The name of the Rowset
     */
    setName(name) {
        this.json.name = name;
        return this;
    }

    /**
     * Gets the name property of the serialized TCF_ROWSET.
     * @returns {String} The name of the serialized TCF_ROWSET.
     */
    getName() {
        return this.json.name;
    }

    /**
     * Sets the backing serialized TCF_ROWSET. This will replace the current serialized TCF_ROWSET. If there is no reference to the previous serialized TCF_ROWSET then it will be lost.
     * @param {Object} rawJsonRowset -
     */
    setRowset(rawJsonRowset) {
        let jsonRowset = rawJsonRowset;
        if (!jsonRowset) {
            jsonRowset = {
                _TCF_Rowset: 'version=1',
                name: '',
                mode: 0,
                attributes: {},
                header: [],
                defaults: [],
                data: [],
            };
        }

        if ('_TCF_Rowset' in jsonRowset === false && Array.isArray(jsonRowset)) {
            jsonRowset = Rowset.fromArray(jsonRowset);
        }

        if (jsonRowset instanceof Rowset) {
            jsonRowset = jsonRowset.json;
        }

        if (!jsonRowset.attributes) {
            jsonRowset.attributes = {};
        }

        this.colIndices = {};
        this.setData(jsonRowset);
    }

    /**
     * Retrieves the current value stored in a field.
     * @param {number} row - The row that contains the field.
     * @param {number|string} [col] - The column that contains the field
     * @returns {Object} Returns the Object contained in the field
     */
    getField(row, col) {
        let colIndex = col;
        if (this.hasData() === false && row > -1) return null;
        // @ts-ignore
        if (isNaN(colIndex)) {
            colIndex = this.getColIndex(col);
        }
        if (row === -1 && this.json.header.length === 0) {
            return null;
        }
        if (colIndex < 0) {
            return null;
        }
        if (row < -1) {
            return '';
        }
        if (row === -1) {
            const header = this.getHeader(row, colIndex);
            // eslint-disable-next-line no-nested-ternary
            return 'caption' in header
                ? header.caption
                : header.attributes && 'caption' in header.attributes
                    ? header.attributes.caption
                    : header.name;
        }

        if (typeof this.json.data[row][colIndex] === 'undefined' || this.json.data[row][colIndex] == null) {
            if (this.json.defaults)
                // @ts-ignore
                return this.getCellDefault(row, colIndex);
            return null;
        }

        return this.json.data[row][colIndex];
    }

    /**
     * Sets the current Object stored in a field.
     * @param {number} row - The row that contains the field
     * @param {number|string} col - The column that contains the field
     * @param {Object} value - The Object to store in the field
     */
    setField(row, col, value) {
        let colIndex = col;
        // @ts-ignore
        if (isNaN(col)) {
            colIndex = this.getColIndex(colIndex);
        }

        const { displayMode } = this.getHeader(row, colIndex);
        if (displayMode === undefined || displayMode === 0) {
            // @ts-ignore
            this.setCell(row, colIndex, value);
        }
    }

    /**
     * Gets the header properties Object for a given col.
     * @param {number|string} row - The row that contains the field
     * @param {number|string} [col] - The column that contains the field
     * @also
     * @param {number|string} row - The column that contains the header Object to retrieve. If not specified then all headers for this serialized TCF_ROWSET are returned as an Array.
     * @returns {Object} Returns the Object representing the headers for the given column. If column is not specified then all headers for this serialized TCF_ROWSET are returned as an Array.
     */
    getHeader(row, col) {
        let colIndex = col;
        if (col == null) colIndex = row;

        if (colIndex === undefined) return this.json.header;

        colIndex = this.getColIndex(colIndex);

        return colIndex > -1 ? this.json.header[colIndex] : null;
    }

    /**
     * Retrieves the datatype in the hexadecimal format for the given column.
     * @param {number} [row] - The row that contains the field whose type is being retrieved
     * @param {number|string} col - The column that contains the data type to retrieve
     * @returns {String} Hexadecimal String value that represents the data type of the column. If the col is &lt; 0 then "string" is returned.
     */
    getCellDataType(row, col) {
        if (col < 0) return 'string';

        // TODO - if the column is of type variant and variant is implemented, return variant's type.
        return this.getHeader(row, col).type;
    }

    /**
     * Retrieves the name for the given column.
     * @param {number} col - The column that contains the column name to retrieve.
     * @also
     * @param {number} row - The row that contains the field whose column name is being retrieved
     * @param {number} [col] - The column that contains the column name to retrieve.
     * @returns {String} The name property of the given column
     */
    getColumnName(row, col) {
        let colIndex = col;
        if (colIndex == null) colIndex = row;

        return typeof colIndex !== 'undefined' ? this.json.header[colIndex].name : this.json.header.name;
    }

    /** Retrieves the names of the columns in this Rowset.
     * @returns {String[]} The names of the columns in this Rowset
     */
    getColumnNames() {
        const names = [];
        for (let col = 0, count = this.getColCount(); col < count; col++)
            names[names.length] = typeof col !== 'undefined' ? this.json.header[col].name : this.json.header.name;

        return names;
    }

    /**
     * Used to get the case sensitive column name given an insesitive column name.
     * @param {string} columnName - The case insesitive column name.
     * @returns {String} The case sensitive column name or null if not found.
     */
    normalizeColumnName(columnName) {
        const index = this.getColIndex(columnName);
        if (index < 0) return null;
        // @ts-ignore
        return this.getColumnName(index);
    }

    /**
     * Adds a new column to the end of the serialized TCF_ROWSET.
     * @param {String} colName - The name to give to the column
     * @param {string} colType - The data type the column will represent
     * @param {number} [maxLength] - TCF property. Not used current on client
     * @param {Object} [defaultValue] - The default value to be used by the fields in this column. Must be valid with the data type.
     * @param {boolean} [useSharedRowsets] - TCF property. Not used current on client
     * @param {String} [colAttributes] - TCF property. Not used current on client
     * @also
     * @param {Object} colName - Header object to add. The value is copied.
     */
    addCol(colName, colType, maxLength, defaultValue, useSharedRowsets, colAttributes) {
        let colDef = null;
        if (typeof colType === 'string') {
            colDef = { name: colName, type: colType };

            if (maxLength) {
                // @ts-ignore
                colDef.maxLength = maxLength;
            }

            if (this.json.defaults) {
                this.json.defaults.push(
                    typeof defaultValue === 'undefined' || defaultValue == null ? null : defaultValue,
                );
            }

            if (useSharedRowsets) {
                // @ts-ignore
                colDef.useSharedRowsets = useSharedRowsets;
            }

            if (colAttributes) {
                Object.assign(colDef, colAttributes);
            }
        } else colDef = jsonClone(colName);

        return this.json.header.push(colDef) - 1;
    }

    /**
     * Sets a Rowset attribute. If an attribute of the same name exists it is overwritten.
     * @param {String} name - Name of the attribute
     * @param {String} value - The value to assign to the attribute
     */
    addAttribute(name, value) {
        this.json.attributes[name] = value;
        return this;
    }

    /**
     * Retrieves a Rowset attribute by name.
     * @param {String} name - Name of the attribute to retrieve
     * @returns {String} The value of the Rowset attribute. If the Rowset attribute does not exist then undefined will be returned.
     */
    getAttribute(name) {
        return this.json.attributes[name];
    }

    /**
     * Check if an attrbiute exists by name.
     * @param {String} name - Name of the attribute to retrieve
     * @returns {boolean}
     */
    hasAttribute(name) {
        return name in this.json.attributes;
    }

    /**
     * Deletes an attribute by name.
     * @param {String} name - Name of the attribute to delete
     */
    deleteAttribute(name) {
        delete this.json.attributes[name];
    }

    /**
     * Implements {@link Core.Type.AbstractMatrix#getCellDefault}.
     * @param {number} [row] - The row that contains the field whose default value is being retrieved
     * @param {number} [col] - The column that contains the field whose default value is being retrieved
     * @returns {any}
     */
    getCellDefault(row, col) {
        if (typeof col !== 'undefined') return this.json.defaults[col] === undefined ? null : this.json.defaults[col];
        return this.json.defaults;
    }

    /**
     * Returns the index of a column whose name matches the name passed in.
     * @param {string|number} colName - The name of the column whose index will be returned.
     * @param {boolean} [_treatNumberAsColumnName] - Whether to treat the colName as an index
     * @returns {number} The column index of the first column found whose name matches the name passed in. If a column of that name can not be found then null is returned.
     */
    getColIndex(colName, _treatNumberAsColumnName) {
        // @ts-ignore
        if (!isNaN(colName) && !_treatNumberAsColumnName) {
            if (typeof colName === 'number') {
                return this.json.header[colName] ? colName : -1;
            }
            const index = this.getColIndex(colName, true);
            if (index === -1) {
                return this.json.header[colName] ? parseInt(colName, 10) : -1;
            }
        }

        const normalizeColName = Rowset.normalizeColumnName(colName);

        if (
            this.colIndices[colName] != null &&
            // eslint-disable-next-line eqeqeq
            Rowset.normalizeColumnName(this.getColumnName(null, this.colIndices[colName])) == normalizeColName
        )
            return this.colIndices[colName];

        for (let i = 0, len = this.getColCount(); i < len; i++) {
            // eslint-disable-next-line eqeqeq
            if (Rowset.normalizeColumnName(this.getColumnName(null, i)) == normalizeColName) {
                this.colIndices[colName] = i;
                return i;
            }
        }

        return -1;
    }

    /**
     * Returns a Rowset that represents the row at the row index passed in.
     * @param {number} row - The row index to retrieve
     * @returns {RowsetRow} A RowsetRow that is backed by the serialized TCF_ROWSET row. So any changes made to this {@link Rowset} will be made to the underlying serialized TCF_ROWSET.
     */
    getRow(row) {
        if (row < 0 || row >= this.json.data.length) throw new Error('Rowset: Rowset row index is out of range');
        return this.hasRow(row) ? new RowsetRow(this, row) : null;
    }

    // Searches each field in a column. If the field matches value passed in Gets a rowsetRow
    /**
     * Returns a Rowset that represents the row at the specified row index and matches the value specified.
     * @param {*} value - Value to match against
     * @param {number|String} colIndex - Column to search for matching value
     * @returns {RowsetRow} A RowsetRow that is backed by the serialized TCF_ROWSET row. So any changes made to this {@link Rowset} will be made to the underlying serialized TCF_ROWSET. Returns null when no matching row was found
     */
    getRowByFieldValue(value, colIndex) {
        let col = colIndex;
        // @ts-ignore
        if (isNaN(col)) col = this.getColIndex(col);

        for (let i = 0, len = this.getRowCount(); i < len; i++)
            if (this.json.data[i][col] === value) return this.getRow(i);
        return null;
    }

    /**
     * Looks for a value in a given column. The row index of the first found value is returned.
     * @param {Object} value - The RAW value to compare.
     * @param {number | String} col - The column index to search for the value.
     * @param {number} [startRow] - The row to start the search from.
     * @param {function} [comparator] - Default to ===
     * @returns {number} Row index of the found value or -1 if not found.
     */
    find(value, col, startRow, comparator) {
        let colIndex = col;
        // @ts-ignore
        if (isNaN(colIndex)) colIndex = this.getColIndex(colIndex);

        for (let rowIndex = startRow == null ? 0 : startRow, len = this.json.data.length; rowIndex < len; rowIndex++) {
            if (comparator === undefined) {
                if (this.json.data[rowIndex][colIndex] === value) return rowIndex;
            } else if (comparator(value, this.json.data[rowIndex][colIndex])) return rowIndex;
        }

        return -1;
    }

    /**
     * Looks for a value in a given column. The row of the first found value is returned.
     * @param {Object} value - The RAW value to compare.
     * @param {number | String} colIndex - The column index to search for the value.
     * @param {number} [startRow] - The row to start the search from.
     * @returns {RowsetRow} Row of the found value or -1 if not found.
     * @param {any} comparator
     */
    findRow(value, colIndex, startRow, comparator) {
        const rowIndex = this.find(value, colIndex, startRow, comparator);
        return rowIndex === -1 ? null : new RowsetRow(this, rowIndex);
    }

    /**
     * Looks for a values in the given columns. The row and col index of the first found value is returned.
     * @param {Object[]} values - The RAW values to compare.
     * @param {number[] | String[]} colIndices - The columns indices to search for the values.
     * @param {number} [startRow] - The row to start the search from.
     * @returns {object} object containing row and col properties of the match. Undefined is returned if not found.
     * @param {any} comparator
     */
    findValues(values, colIndices, startRow, comparator) {
        if (values.length === 1 && colIndices.length > 1)
            while (values.length < colIndices.length) values.push(values[0]);

        for (let i = 0, iLen = values.length; i < iLen; i++) {
            const result = this.find(values[i], colIndices[i], startRow || 0, comparator);
            if (result > -1)
                return {
                    row: result,
                    col: colIndices[i],
                };
        }
        return undefined;
    }

    /**
     * Looks for a value in a given column. All rows found are returned.
     * @param {Object} value - The RAW value to compare.
     * @param {number | String} col - The column index to search for the value.
     * @param {number} [startRow] - The row to start the search from.
     * @returns {number[]} Row indices of the first found value or empty Array if not found.
     * @param {any[]} rowsToSearch
     */
    findAll(value, col, startRow, rowsToSearch) {
        let colIndex = col;
        // @ts-ignore
        if (isNaN(colIndex)) colIndex = this.getColIndex(colIndex);
        const foundRows = [];
        for (
            let row = startRow || 0, rowLen = rowsToSearch ? rowsToSearch.length : this.json.data.length;
            row < rowLen;
            row++
        ) {
            const rowIndex = rowsToSearch ? rowsToSearch[row] : row;
            if (this.json.data[rowIndex][colIndex] === value) foundRows[foundRows.length] = rowIndex;
        }
        return foundRows;
    }

    /**
     * Looks for a values in the given columns. All rows found are returned.
     * @param {Object[]} values - The RAW values to compare.
     * @param {number[] | String[]} colIndices - The columns indices to search for the values.
     * @param {number} [startRow] - The row to start the search from.
     * @param {number[]} [rowsToSearch]
     * @returns {number[]} Row indices of the first found value or empty Array if not found.
     */
    findAllValues(values, colIndices, startRow, rowsToSearch) {
        let matchingRows = rowsToSearch;
        for (let valueIndex = 0, valueIndexLen = values.length; valueIndex < valueIndexLen; valueIndex++) {
            matchingRows = this.findAll(values[valueIndex], colIndices[valueIndex], startRow || 0, matchingRows);
            if (matchingRows.length === 0) return matchingRows;
        }
        return matchingRows;
    }

    /** Returns rowset with sub-set of records filtered out based on values in specified column.
     * @param {String|number} column - The column to filter on
     * @param {*} value - The value to filter on. Can be a callback functionwhich returns a boolean to add the value or not.
     * @param {boolean} [doMatch=true] - If set to true then the resulting rowset will contain only those rows where value in the columnName column and value combined using operator produce true, otherwise only the records where the result is false will be copied. It is optional and assumed "true" by default.
     * @returns {Rowset}
     */
    filter(column, value, doMatch) {
        let performatch = doMatch;
        if (performatch === undefined) {
            performatch = true;
        }

        let useCallback = false;
        if (typeof value === 'function') {
            useCallback = true;
        }

        const rs = new Rowset();
        rs.json.header = jsonClone(this.json.header);

        const rsData = rs.json.data;

        for (let r = 0, rCount = this.json.data.length; r < rCount; r++) {
            const fieldValue = this.getField(r, column);
            if (
                useCallback
                    ? value(fieldValue)
                    : (performatch && fieldValue === value) || (!performatch && fieldValue !== value)
            )
                rsData[rsData.length] = jsonClone(this.json.data[r]);
        }

        return new Rowset(rs);
    }

    /**
     * @param {number|string} col
     * @returns {number}
     */
    getMinValue(col) {
        let colIndex = col;
        // @ts-ignore
        if (isNaN(colIndex)) colIndex = this.getColIndex(colIndex);
        const len = this.getRowCount();

        if (len === 0) return null;

        let minValue = this.getField(0, colIndex);

        for (let rowIndex = 1; rowIndex < len; rowIndex++) {
            const value = this.getField(rowIndex, colIndex);
            if (value < minValue) minValue = value;
        }

        return minValue;
    }

    /**
     * @param {number|string} col
     * @returns {number}
     */
    getMaxValue(col) {
        let colIndex = col;
        // @ts-ignore
        if (isNaN(colIndex)) colIndex = this.getColIndex(colIndex);
        const len = this.getRowCount();

        if (len === 0) return null;

        let maxValue = this.getField(0, colIndex);

        for (let rowIndex = 1; rowIndex < len; rowIndex++) {
            const value = this.getField(rowIndex, colIndex);
            if (value > maxValue) maxValue = value;
        }

        return maxValue;
    }

    /**
     * Finds all of the unique values and passes them back in a HashMap.
     * @param {number | string | number[] | string[] | any[]} colIndex - The column index or name to look for distinct values
     * @param {boolean} [asSortedArray] - Whether to sort the values.
     * @returns {Object} Name value map. Name is the value as a string. Value is he count of values found.
     * @param {{ [x: string]: number; }} [_result] - private
     * @param {any[]} [_sortedArray] - private
     */
    getDistinctValues(colIndex, asSortedArray, _result, _sortedArray) {
        const topOfCallStack = _result === undefined;
        // eslint-disable-next-line no-param-reassign
        _result = _result || {};
        // eslint-disable-next-line no-param-reassign
        _sortedArray = _sortedArray || null;
        // eslint-disable-next-line no-param-reassign
        if (asSortedArray && !_sortedArray) _sortedArray = [];

        if (Array.isArray(colIndex)) {
            for (let i = 0, iLen = colIndex.length; i < iLen; i++) {
                this.getDistinctValues(colIndex[i], asSortedArray, _result, _sortedArray);
            }
        } else {
            // eslint-disable-next-line no-param-reassign
            colIndex = this.getColIndex(colIndex);
            if (colIndex > -1) {
                for (let rowIndex = 0, len = this.getRowCount(); rowIndex < len; rowIndex++) {
                    const rawValue = this.getField(rowIndex, colIndex);
                    const value = `${rawValue}`;
                    if (value in _result) {
                        // eslint-disable-next-line no-plusplus
                        _result[value]++;
                    } else {
                        _result[value] = 1;
                        if (_sortedArray) {
                            _sortedArray[_sortedArray.length] = rawValue;
                        }
                    }
                }
            }
        }
        if (topOfCallStack && _sortedArray) {
            // eslint-disable-next-line no-param-reassign
            colIndex = Array.isArray(colIndex) ? colIndex[0] : colIndex;
            const DtClass = getDataType(this.getHeader(colIndex).type);
            return _sortedArray.sort(new DtClass().getComparator());
        }
        return _result;
    }

    // Inserts a new row and the end of the Rowset
    /**
     * Creates a new RowsetRow and appends the row to the end of the serialized TCF_ROWSET. The row is populated with the supplied data. The data argument can be either an Array of values or an {@link Rowset}. If no argument is passed in then a new row will be added using the column default values.
     * @param {Array} [data] - The data to enter into the new row. The indices of the values in the Array must match the indices of the columns in the serialized TCF_ROWSET
     * @also
     * @param {Rowset} [data] - The data to enter into the new row.
     * @returns {Number} The new row length of the Rowset
     */
    addRow(data) {
        if (data instanceof Rowset) {
            const row = data;
            const rowCount = this.json.data.length;
            this.json.data[rowCount] = [];
            for (let i = 0; i < this.getColCount(); i++)
                // @ts-ignore
                this.json.data[rowCount][i] = row.getField(this.getColumnName(i));
        } else if (data) this.json.data[this.json.data.length] = data;
        else {
            const rowCount = this.json.data.length;
            this.json.data[rowCount] = [];
            for (let i = 0, len = this.getColCount(); i < len; i++)
                this.json.data[rowCount][i] = this.getCellDefault(rowCount, i);
        }
        return this.json.data.length - 1;
    }

    // Inserts a new row at the given index of the Rowset
    /**
     * Creates a new RowsetRow and inserts it into the serialized TCF_ROWSET at the given index. The new Row is populated with the supplied data. If no data is supplied then the row is populated with the default values.
     * @param {number} index - The row index of the serialized TCF_ROWSET to insert the new row at
     * @param {Array} [dataArray] - The data to enter into the new row. The indices of the values in the Array must match the indices of the columns in the serialized TCF_ROWSET
     * @returns {number} The new row length of the Rowset
     */
    insertRowAt(index, dataArray) {
        this.json.data.splice(index, 0, []);
        for (let i = 0, len = this.getColCount(); i < len; i++)
            this.json.data[index][i] = dataArray ? dataArray[i] : this.getCellDefault(0, i);

        return this.json.data.length - 1;
    }

    /**
     * Creates a new RowsetRow and inserts it into the serialized TCF_ROWSET at the given index. The new Row is populated with the supplied data. If no data is supplied then the row is populated with the default values. If no index is passed then the new row is appended to the end of the serialized TCF_ROWSET.
     * @param {number} [index] - The row index of the serialized TCF_ROWSET to insert the new row at
     * @param {Array} [dataArray] - The data to enter into the new row. The indices of the values in the Array must match the indices of the columns in the serialized TCF_ROWSET
     * @returns {number} The new row length of the Rowset
     */
    insertRow(index, dataArray) {
        if (index === undefined || index === null) return this.addRow(dataArray);
        return this.insertRowAt(index, dataArray);
    }

    /**
     * Removes a RowsetRow at the specified index from the serialized TCF_ROWSET.
     * @param {number} [index] - The row index of the serialized TCF_ROWSET to remove from. If it is not specified, the last RowsetRow within the serialized TCF_ROWSET will be removed.
     * @returns {RowsetRow} Removed RowsetRow. Returns NULL when the index does not exists within the serialized TCF_ROWSET, no RowsetRow was removed
     */
    removeRow(index) {
        let indexOrLast = index;
        indexOrLast = indexOrLast === undefined ? this.json.length - 1 : indexOrLast;
        if (this.json.data[indexOrLast]) return this.json.data.splice(indexOrLast, 1);
        return null;
    }

    /**
     * Removes a Column at the specified index from the serialized TCF_ROWSET.
     * @param {number|string} [index] - The row index of the serialized TCF_ROWSET to remove from. If it is not specified, the last column within the serialized TCF_ROWSET will be removed.
     */
    removeColumn(index) {
        let colIndex = index;
        if (typeof colIndex === 'string') colIndex = this.getColIndex(colIndex);
        colIndex = colIndex === undefined ? this.getColCount() - 1 : colIndex;
        this.json.header.splice(index, 1);
        const { data } = this.json;
        for (let i = 0, iLen = data.length; i < iLen; i++) data[i].splice(index, 1);
    }

    /**
     * Checks if the RowsetRow specified by the index currently has default values.
     * @param {number} index - RowsetRow index
     * @returns {Boolean} TRUE if the specified row currently has default values, otherwise FALSE is returned.
     */
    isRowDefault(index) {
        for (let i = 0, len = this.getColCount(); i < len; i++)
            if (this.getField(index, i) !== this.getCellDefault(index, i)) return false;

        return true;
    }

    /**
     * Returns the serialized TCF_ROWSET as a String.
     * @returns {String} String representing the the backing TCF_ROWSET
     */
    toString() {
        if (this.getValue() === null) {
            return 'Rows: 0 Columns: 0 Column Names: }';
        }
        // return JSON.stringify(this);
        // TODO used the following line to prevent cluttering the log.
        // return this.json;
        const colNames = [];
        const colCount = this.getColCount();
        const rowCount = this.getRowCount();
        for (let i = 0; i < colCount; i++) colNames[colNames.length] = this.getColumnName(i);
        return `Rows: ${rowCount} Columns: ${colCount} Column Names: ${colNames.join(',')}`;
    }

    /** This is a private method to be used in the native JSON processes. It's not marked private because the native JSON requires this function to be called toJSON.
     * @private
     */
    toJSON() {
        return this.json;
    }

    /**
     * @param {any} options
     */
    toConsole(options) {
        return rowsetUtil.rowsetToConsole(this, options);
    }
    /**
     * @param {any} options
     */
    toCsv(options) {
        return rowsetUtil.rowsetToCsv(this, options);
    }
    /**
     * @param {any} options
     */
    toExcel(options) {
        return rowsetUtil.rowsetToExcel(this, options);
    }
    /**
     * @param {any} options
     */
    toHtml(options) {
        return rowsetUtil.rowsetToHtml(this, options);
    }
    /**
     * @param {any} options
     */
    toText(options) {
        return rowsetUtil.rowsetToText(this, options);
    }

    /**
     * Returns an Array representing the data in this Rowset. The Array will contain multiple Objects, each Object representing a row in this Rowset. Each Object will contain columnName/fieldValue pairs for each column in the Rowset.
     * @returns {Array} Array representing the TCF_ROWSET (data portion only). Complex Obects are included by reference and not copies.
     * @example [{col1Name: row1Value, col2Name: row1Value},{col1Name: row2Value, col2Name: row2Value}]
     * @param {any} [options]
     */
    toArray(options) {
        const optionsWithDefaults = Object.assign(
            {
                includeColumnType: false,
                includeHeaderRow: true,
            },
            options || {},
        );

        return rowsetUtil.rowsetToArray(this, optionsWithDefaults);
    }

    /**
	 * @deprecated Use toArray which follow the to<Action> naming.
	Returns an Array representing the data in this Rowset. The Array will contain multiple Objects, each Object representing a row in this Rowset. Each Object will contain columnName/fieldValue pairs for each column in the Rowset.
	 * @returns {Array} Array representing the TCF_ROWSET (data portion only). Complex Obects are included by reference and not copies.
	 * @example [{col1Name: row1Value, col2Name: row1Value},{col1Name: row2Value, col2Name: row2Value}]
	 * @param {any} [options]
	 */
    asArray(options) {
        const optionsWithDefaults = Object.assign(
            {
                includeColumnType: false,
                includeHeaderRow: true,
            },
            options || {},
        );

        return rowsetUtil.rowsetToArray(this, optionsWithDefaults);
    }

    /**
     * Iterates throught the serialized TCF_ROWSET.
     * @param {Function} func - Iterator callback function. Returns the column value as the first parameter if colName is specified, otherwise a Rowset is returned. If func returns the global $break object, the iteration will stop.
     * @param {String} [colName] - If a colName is specified, forEach will iterate through the specified column, otherwise all rows will be interated.
     */
    forEach(func, colName) {
        if (colName) {
            const colIndex = this.getColIndex(colName);
            for (let i = 0, len = this.json.data.length; i < len; i++)
                if (func(this.json.data[i][colIndex]) === true) break;
        } else {
            for (let i = 0, len = this.json.data.length; i < len; i++) if (func(this.getRow(i)) === true) break;
        }
    }
}

// ------------------- Rowset Row ------------------
// Represents a Row in a Core.Type.Rowset.
// Takes in rowData in the form of 2 array objects.
// {colNames: ['name1', 'name2], colValues: [val1, val2]}
//
/**
 * Represents a Row in a Core.Type.Rowset.
 * Takes in rowData in the form of 2 array objects.
 * {colNames: ['name1', 'name2], colValues: [val1, val2]}
 */
export class RowsetRow extends AbstractMatrix {
    /**
     * @inheritdoc
     * @param {Rowset} rowset
     * @param {number} rowIndex
     */
    constructor(rowset, rowIndex) {
        super();

        this.rowset = rowset;
        this.rowIndex = rowIndex;

        if (rowset.layoutColCount || rowset.getAttribute('displayColCount')) {
            this.layoutColCount = rowset.layoutColCount || rowset.getAttribute('displayColCount');
        }
    }

    /**
     * Gets a header by Row Name or Row Index
     * @param {string|number} col
     */
    getHeader(col) {
        return this.rowset.getHeader(this.rowIndex, col);
    }

    /** Gets a field by Row Name or Row Index
     * @param {string|number} col
     */
    getField(col) {
        return this.rowset.getField(this.rowIndex, col);
    }

    /**
     *
     * @param {string|number} col
     * @param {*} value
     */
    setField(col, value) {
        let colIndex = col;
        // @ts-ignore
        if (isNaN(colIndex)) colIndex = this.rowset.getColIndex(colIndex);
        const { displayMode } = this.rowset.getHeader(this.rowIndex, colIndex);
        if (displayMode === undefined || displayMode === 0)
            // @ts-ignore
            this.rowset.setCell(this.rowIndex, colIndex, value);
    }

    /**
     * @param {string | number} colName
     */
    getColIndex(colName) {
        return this.rowset.getColIndex(colName);
    }

    /** @returns {number} Number of columns in the RowsetRow */
    getColCount() {
        return this.rowset.getColCount();
    }

    /**
     * @param {number} col
     */
    getColumnName(col) {
        return this.rowset.getColumnName(col);
    }

    /** @returns {object} RowsetROw as an object with keys for header names and values of the column values. */
    asObject() {
        const obj = {};
        for (let i = 0, len = this.rowset.getColCount(); i < len; i++) {
            obj[this.rowset.getColumnName(null, i)] =
                this.rowIndex < 0 ? this.rowset.getField(this.rowIndex, i) : this.rowset.json.data[this.rowIndex][i];
        }
        return obj;
    }
}

basicDatatypeMap.set(TCFType.TCF_Rowset, Rowset);
basicDatatypeMap.set(TCFType.TCF_RowsetRow, RowsetRow);
