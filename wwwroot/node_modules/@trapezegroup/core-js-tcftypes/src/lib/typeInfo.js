// @ts-check
/* eslint-disable no-bitwise */
import { TcfDataTypesMap, AbstractType } from './types.js';

// Basic TCFType enumeration (defined in TCF_Core.h)
export const TCFType = {
    TCF_Undefined: 0, // used to specify undefined type
    TCF_Boolean: 1, // Boolean basic type.
    TCF_Byte: 2, // Byte basic type.
    TCF_SByte: 3, // SByte basic type.
    TCF_Char: 4, // Char basic type.
    TCF_WChar: 5, // WChar basic type.
    TCF_Int16: 6, // Int16 basic type.
    TCF_UInt16: 7, // UInt16 basic type.
    TCF_Int32: 8, // Int32 basic type.
    TCF_UInt32: 9, // UInt32 basic type.
    TCF_Int64: 10, // Int64 basic type.
    TCF_UInt64: 11, // UInt64 basic type.
    TCF_Double: 12, // Double basic type.
    TCF_Single: 13, // Single basic type.
    TCF_STR: 14, // narrow (MBCS) string pointer standard type
    TCF_WSTR: 15, // wide (Unicode) string pointer standard type
    TCF_String: 16, // String standard object type
    TCF_Rowset: 17, // Rowset standard object type
    TCF_Binary: 18, // Binary standard object type
    TCF_Variant: 19, // Variant standard object type
    TCF_RowsetRow: 20, // RowsetRow object (part of a Rowset object)
    TCF_RowsetField: 21, // RowsetField object (part of a Rowset object)
};

/**
 * TypeInfo helpers
 */
export class TypeInfo {
    /**
     * @param {number} type - Base type as decimal
     * @returns {boolean} true of the type is one of the string types
     */
    static isString(type) {
        return type >= TCFType.TCF_STR && type <= TCFType.TCF_String;
    }

    /**
     * @param {number} type - Base type as decimal
     * @returns {boolean} true if the type is one of the numeric types (any integral or real type)
     */
    static isNumber(type) {
        return type >= TCFType.TCF_Byte && type <= TCFType.TCF_Single;
    }

    /**
     * @param {number} type - Base type as decimal
     * @returns {boolean} true if the type is any one of the integral types (non-floating point number)
     */
    static isIntegral(type) {
        return type >= TCFType.TCF_Byte && type <= TCFType.TCF_UInt64;
    }

    /**
     * @param {number} type - Base type as decimal
     * @returns {boolean} true if the type is one of the floating point types
     */
    static isReal(type) {
        return type === TCFType.TCF_Double || type === TCFType.TCF_Single;
    }

    /**
     * @param {number} type - Base type as decimal
     * @returns {boolean} true if the type is Rowset
     */
    static isRowset(type) {
        return type === TCFType.TCF_Rowset;
    }

    /**
     * @inheritdoc
     * @param {number|string} [type] hex base type
     * @param {number} [ext] hex ext type
     * @param {number} [format] hex type format
     */
    constructor(type, ext, format) {
        this.clear();
        this.set(type, ext, format);
    }

    /**
     * Sets the type info for this intance
     * @param {number|string} type hex base type
     * @param {number} [ext] hex ext type
     * @param {number} [format] hex type format
     */
    set(type, ext, format) {
        if (typeof type === 'string') {
            // Type expected as "EEFFTT" hex value string
            this.info = parseInt(type, 16);
            return;
        }

        if (type > 0xff) {
            // Type passed in one piece
            this.info = type & 0xff000000;
            return;
        }

        // assemble type from pieces
        this.info &= 0xff000000;
        this.info |= type;
        this.info |= (format || 0) << 8;
        this.info |= (ext || 0) << 16;
    }

    /** Clears out the type info for this instance */
    clear() {
        // Tpe information stored as EEFFTT (EE=extended, FF=format, TT=TCFType)
        this.info = 0x0;
    }

    /** @returns {number} current base type hex value */
    getType() {
        return this.info & 0x000000ff;
    }

    /** @returns {number} current format type hex value */
    getFormat() {
        return (this.info & 0x0000ff00) >> 8;
    }

    /** @returns {number} current ext type hex value */
    getExt() {
        return (this.info & 0x00ff0000) >> 16;
    }

    /** @returns {number} current precision part from the format */
    getFormatPrecision() {
        return this.getFormat() & 0x0f;
    }

    /** @returns {number} current style part from the format */
    getFormatStyle() {
        return (this.getFormat() & 0xf0) >> 4;
    }

    /** @returns {boolean} if type info is string */
    isString() {
        return TypeInfo.isString(this.getType());
    }

    /** @returns {boolean} if type info is number */
    isNumber() {
        return TypeInfo.isNumber(this.getType());
    }

    /** @returns {boolean} if type info is integral number */
    isIntegral() {
        return TypeInfo.isIntegral(this.getType());
    }

    /** @returns {boolean} if type info is real number */
    isReal() {
        return TypeInfo.isReal(this.getType());
    }

    /** @returns {boolean} if type info is Rowset */
    isRowset() {
        return TypeInfo.isRowset(this.getType());
    }
}

/**
 * @param {string|AbstractType} classname class to get hex value of
 * @returns {string} hex value for the given AbstractType class
 */
export const getHex = function getHex(classname) {
    let classNameStr = classname;
    if (classNameStr instanceof AbstractType) {
        classNameStr = classNameStr.constructor.name;
    }

    let hex = TcfDataTypesMap[classNameStr];
    if (!hex) {
        switch (classNameStr) {
            case 'TcfBoolean':
                hex = '1';
                break;
            case 'TcfTimeSpan':
                hex = 'A0000';
                break;
            case 'TcfBigTimeSpan':
                hex = 'C0000';
                break;
            case 'TcfTime':
                hex = '140000';
                break;
            case 'TcfDate':
                hex = '1E0000';
                break;
            case 'TcfDateTime':
                hex = '230000';
                break;
            case 'TcfDistance':
                hex = '28000C';
                break;
            case 'TcfDistanceInt':
                hex = '280008';
                break;
            case 'TcfSpeed':
                hex = '340000';
                break;
            case 'TcfWeekdaysStr':
                hex = '46000E';
                break;
            case 'TcfWeekdaysInt':
                hex = '460008';
                break;
            case 'TcfColor':
                hex = '630000';
                break;
            case 'TcfColorAlpha':
                hex = '640000';
                break;
            case 'TcfColorRef':
                hex = '650000';
                break;
            case 'TcfVolume':
                hex = '820000';
                break;
            case 'TcfPressure':
                hex = '8C0000';
                break;
            case 'TcfAcceleration':
                hex = '960000';
                break;
            case 'TcfTemperature':
                hex = 'A00000';
                break;
            case 'TcfFuelEconomy':
                hex = 'AA0000';
                break;
            case 'TcfWeight':
                hex = 'B40000';
                break;
            case 'TcfByte':
                hex = '2';
                break;
            case 'TcfSByte':
                hex = '3';
                break;
            case 'TcfChar':
                hex = '4';
                break;
            case 'TcfWChar':
                hex = '5';
                break;
            case 'TcfInt16':
                hex = '6';
                break;
            case 'TcfUInt16':
                hex = '7';
                break;
            case 'TcfInt32':
                hex = '8';
                break;
            case 'TcfUInt32':
                hex = '9';
                break;
            case 'TcfInt64':
                hex = 'A';
                break;
            case 'TcfUInt64':
                hex = 'B';
                break;
            case 'TcfDouble':
                hex = 'C';
                break;
            case 'TcfSingle':
                hex = 'D';
                break;
            case 'TcfSTR':
                hex = 'E';
                break;
            case 'TcfWSTR':
                hex = 'F';
                break;
            case 'TcfString':
                hex = '10';
                break;
            case 'TcfRowset':
                hex = '11';
                break;
            case 'TcfVariant':
                hex = '13';
                break;
            case 'TcfRowsetRow':
                hex = '14';
                break;
            case 'TcfCsv':
                hex = '';
                break;
            default:
        }
        if (hex) {
            TcfDataTypesMap[classname] = hex;
        }
    }

    return hex;
};
