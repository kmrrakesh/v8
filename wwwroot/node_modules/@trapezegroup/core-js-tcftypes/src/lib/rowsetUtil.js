// @ts-check

import { fromCsvWithRanges } from '@trapezegroup/core-js-extensions/src/lib/string.js';
import { valueCount } from '@trapezegroup/core-js-extensions/src/lib/array.js';
import { toDisplayValue } from './fields/fields.js';
import { TypeInfo } from './typeInfo.js';
import { getDataType } from './types.js';
import { RowsetExcel } from './rowsetExcel.js';

const _templateEscCharBackup = /\\(.)/g;
const _templateEscCharRestore = /\$_ESCAPE_(\d+)_\$/g;
const _templateOptional = /(\[.+?\])+/g;
const _templateFields = /(\<\S+?\>)/g;
const _templateFieldsHandlebars = /(\{\{\S+?\}\})/g;

export const rowsetUtil = {
    /**
     * Localizes a Rowsets field using the {@link toDisplayValue}.
     * @param {number} row - The row of the {@link Rowset} to use.
     * @param {number} col - The column of the {@link Core.Type.Rowset} to use.
     * @param {import('./rowset.js').Rowset} rowset - The Rowset to use.
     * @param {HTMLElement} [behaviorNode] - The {@link Element} to use for localization context.
     * @param {String} [value] - If a value is suuplied it will be used instead but the fields column info will still be used for localizing the value.
     * @param {function} [getDataTypeImplementatin] - A function that returns a class that extends {@link Core.Type.AbstractType}. By default the class that represents the column will be used.
     * @param {function} [getFieldsInfo] - A function that returns fields info that is used for localization e.g. selectors and input type. By Defulat the column header is used.
     */
    getLocalizedValue(row, col, rowset, behaviorNode, value, getDataTypeImplementatin, getFieldsInfo) {
        const dataType = getDataTypeImplementatin
            ? getDataTypeImplementatin(row, col)
            : rowset.getHeader(row, col).type;
        const typeFormat = new TypeInfo(dataType).getFormat();
        const dtInstance = rowsetUtil._getCachedDataType(dataType, rowset, behaviorNode);
        dtInstance.setValue(value === undefined ? rowset.getField(row, col) : value);
        typeFormat && dtInstance.setLocaleKey(typeFormat);
        const fieldsInfo = getFieldsInfo ? getFieldsInfo(row, col) : rowset.getHeader(row, col);
        return toDisplayValue(dtInstance, fieldsInfo, typeFormat ? undefined : behaviorNode);
    },

    /** Localizes a Rowsets field using the {@link Core.Cast.toDisplayValue}.
     * @param {import('./rowset.js').RowsetRow} rowsetRow - The RowsetRow to use.
     * @param {number} col - The column of the {@link Core.Type.Rowset} to use.
     * @param {HTMLElement} behaviorNode - The {@link Element} to use for localization context. Defaults to document.body.
     * @param {String} [value] - If a value is suuplied it will be used instead but the fields column info will still be used for localizing the value.
     * @param {function} [getDataTypeImplementatin] - A function that returns a class that extends {@link Core.Type.AbstractType}. By default the class that represents the column will be used.
     * @param {function} [getFieldsInfo] - A function that returns fields info that is used for localization e.g. selectors and input type. By Defulat the column header is used.
     */
    getLocalizedValueFromRow(rowsetRow, col, behaviorNode, value, getDataTypeImplementatin, getFieldsInfo) {
        return rowsetUtil.getLocalizedValue(
            rowsetRow.rowIndex,
            col,
            rowsetRow.rowset,
            behaviorNode,
            value,
            getDataTypeImplementatin,
            getFieldsInfo,
        );
    },

    /** @private */
    _getCachedDataType(type, rowset, behaviorNode) {
        if (!rowset._dataTypeInstanceMap) rowset._dataTypeInstanceMap = new Map();
        let dtInstance = rowset._dataTypeInstanceMap.get(type);
        if ((typeof dtInstance === 'undefined') === true) {
            const DtClass = getDataType(type);
            dtInstance = new DtClass();
            dtInstance.initLocale(behaviorNode || document.body);
            rowset._dataTypeInstanceMap.set(type, dtInstance);
        }
        return dtInstance;
    },

    _localCache: {},

    /**
     * Default implementaion to get the Header from a Rowset column.
     * @param {import('./rowset.js').Rowset} rs
     * @param {number} row
     * @param {number} col
     * @returns {any} The column header
     */
    getInputFieldLayout(rs, row, col) {
        return rs.getHeader(row, col);
    },

    /**
     * Default implementaion to get the Caption Styles from a Rowset column.
     * @param {import('./rowset.js').Rowset} rs
     * @param {number} row
     * @param {number} col
     * @returns {any} The column header
     */
    getCaptionStyles(rs, row, col) {
        return rs.getHeader(row, col).captionStyle;
    },

    /**
     * Default implementaion to get the Caption CSS from a Rowset column.
     * @param {import('./rowset.js').Rowset} rs
     * @param {number} row
     * @param {number} col
     * @returns {any} The column header
     */
    getCaptionCss(rs, row, col) {
        return rs.getHeader(row, col).captionCSS;
    },

    /**
     * Default implementaion to get the aption Description from a Rowset column.
     * @param {import('./rowset.js').Rowset} rs
     * @param {number} row
     * @param {number} col
     * @returns {any} The column header
     */
    getCaptionDescription(rs, row, col) {
        return rs.getHeader(row, col).description;
    },

    /**
     * Default implementaion to get the Display Styles from a Rowset column.
     * @param {import('./rowset.js').Rowset} rs
     * @param {number} row
     * @param {number} col
     * @returns {any} The column header
     */
    getDisplayStyles(rs, row, col) {
        return rs.getHeader(row, col).displayStyles;
    },

    /**
     * Default implementaion to get the Display CSS from a Rowset column.
     * @param {import('./rowset.js').Rowset} rs
     * @param {number} row
     * @param {number} col
     * @returns {any} The column header
     */
    getDisplayCss(rs, row, col) {
        return rs.getHeader(row, col).captionCSS;
    },

    /**
     * Default implementaion to get the Selector information from a Rowset column.
     * @param {import('./rowset.js').Rowset} rs
     * @param {number} row
     * @param {number} col
     * @returns {any} The column header
     */
    getSelector(rs, row, col) {
        return rs.getHeader(row, col).selector;
    },

    /**
     * Default implementaion to get the isDynamic iformation from a Rowset column.
     * @param {import('./rowset.js').Rowset} rs
     * @param {number} row
     * @param {number} col
     * @returns {any} The column header
     */
    isDynamic(rs, row, col) {
        return !!rs.getHeader(row, col).isDynamic;
    },

    /**
     * Tests if an object looks like raw base data for a Rowset
     * @param {object} obj object to test
     * @returns {boolean}
     */
    is_TCF_Rowset(obj) {
        return obj._TCF_Rowset !== undefined;
    },

    /**
     * Output the Rwoset to Excel
     * @param {import('./rowset.js').Rowset} rowset
     * @param {*} options
     */
    rowsetToExcel(rowset, options) {
        const optionsWithDefuaults = Object.assign(
            options || {},
            { worksheetName: 'Rowset Export', localize: true },
            false,
        );

        let rowsetWithSelectionApplied = rowset;
        if (optionsWithDefuaults.selection)
            rowsetWithSelectionApplied = optionsWithDefuaults.selection.applySelectionToRowset(
                rowsetWithSelectionApplied,
            );

        new RowsetExcel()
            .addWorksheetFromRowset('Rowset Export', rowsetWithSelectionApplied, optionsWithDefuaults)
            .run();
    },

    /** Generates an HTML Element output for the specified rowset */
    rowsetToHtml(rowset, options) {
        const data = this.rowsetTo2DArray(rowset, options);
        const rowCount = data.length;
        const colCount = rowCount ? data[0].length : 0;

        const hasHeaderRow = !options || options.includeHeaderRow !== false;
        const table = document.createElement('table');

        if (hasHeaderRow) {
            const thead = table.appendChild(document.createElement('thead'));

            for (let tr = thead.appendChild(document.createElement('tr')), c = 0; c < colCount; c++) {
                const th = document.createElement('th');
                th.innerText = data[0][c];
                tr.appendChild(th);
            }
        }

        const tbody = table.appendChild(document.createElement('tbody'));

        for (let r = hasHeaderRow ? 1 : 0; r < rowCount; r++)
            for (let tr = tbody.appendChild(document.createElement('tr')), c = 0; c < colCount; c++) {
                const td = document.createElement('td');
                td.innerText = data[r][c];
                tr.appendChild(td);
            }

        return table;
    },

    /** Outputs the specified rowset to the browser's developer console if supported */
    rowsetToConsole(rowset, options) {
        let consoleTableToStringSupport = true;
        try {
            // eslint-disable-next-line no-console
            console.table.toString();
        } catch (e) {
            consoleTableToStringSupport = false;
        }

        // eslint-disable-next-line no-console
        if (consoleTableToStringSupport && console.table.toString().indexOf('[native code]') !== -1)
            // eslint-disable-next-line no-console
            console.table(this.rowsetToArray(rowset, options));
        // eslint-disable-next-line no-console
        else console.log(this.rowsetToText(rowset, options));
    },

    /** Converts the specified rowset to a CSV format */
    rowsetToCsv(rowset, options) {
        return this.rowsetToText(
            rowset,
            Object.assign(options || {}, {
                fieldDelimiter: ',',
                fieldEnclosure: '"',
                prettyPrint: false,
            }),
        );
    },

    /** Converts the specified rowset to a human-readable tabular text format */
    rowsetToText(rowset, options) {
        const optionsWithDefaults = Object.assign(
            {
                fieldDelimiter: ' ',
                fieldEnclosure: '',
                prettyPrint: true,
                rowDelimiter: '\n',
            },
            options || {},
        );

        const data = this.rowsetTo2DArray(rowset, optionsWithDefaults);
        const rowCount = data.length;
        const colCount = rowCount ? data[0].length : 0;
        let result = '';
        const colMaxLen = [];

        if (optionsWithDefaults.prettyPrint)
            for (let c = 0; c < colCount; c++)
                for (let r = 0; r < rowCount; r++)
                    colMaxLen[c] = Math.max(
                        colMaxLen[c] || 0,
                        `${data[r][c]}`.length + optionsWithDefaults.fieldEnclosure.length * 2,
                    );

        for (let r = 0; r < rowCount; r++) {
            for (let c = 0; c < colCount; c++) {
                const padding = colMaxLen[c] - `${data[r][c]}`.length - optionsWithDefaults.fieldEnclosure.length * 2;
                result +=
                    optionsWithDefaults.fieldEnclosure +
                    data[r][c] +
                    optionsWithDefaults.fieldEnclosure +
                    (c < colCount - 1 ? optionsWithDefaults.fieldDelimiter : '') +
                    (optionsWithDefaults.prettyPrint ? ''.padStart(padding, ' ') : '');
            }
            result += optionsWithDefaults.rowDelimiter;
        }

        return result;
    },

    /** Converts the specified rowset to an array of objects */
    rowsetToArray(rowset, options) {
        const data = this.rowsetTo2DArray(rowset, options);
        const rowCount = data.length;
        const colCount = rowCount ? data[0].length : 0;
        const result = [];

        const colNames = [];
        for (let c = 0; c < colCount; c++) colNames[colNames.length] = data[0][c];

        for (let r = 1; r < rowCount; r++) {
            result[result.length] = {};
            const row = result[result.length - 1];

            for (let c = 0; c < colCount; c++) row[colNames[c]] = data[r][c];
        }

        return result;
    },

    /**
     * Converts the specified rowset to a 2-dimensional array
     * @param {Object} [options] - Conversion ooptions
     * @param {Array|String} [options.columns] - Columns to include, can be an Array or CSV of column names, all columns are included if not specified
     * @param {Boolean} [options.includeColumnType=TRUE] - Include column type inside of column name
     * @param {Boolean} [options.includeHeaderRow=TRUE] - Include header names in the first element of the array
     * @param {Boolean|Element} [options.localizeValue] - Return localized field headers and values when TRUE or a node is specified
     * @param {Array|String} [options.rows] - Rows to include, can be an Array or Ranged-CSV of row indices, all rows are included if not specified
     * @returns {Array} Returns a 2-dimensional array of the rowset
     */
    rowsetTo2DArray(rowset, options) {
        const optionsWithDefaults = Object.assign(
            {
                includeColumnType: true,
                includeHeaderRow: true,
            },
            options || {},
        );

        if ('columns' in optionsWithDefaults && typeof optionsWithDefaults.columns === 'string')
            optionsWithDefaults.columns = optionsWithDefaults.columns.split(',');
        if ('rows' in optionsWithDefaults && typeof optionsWithDefaults.rows === 'string')
            optionsWithDefaults.rows = fromCsvWithRanges(optionsWithDefaults.rows);

        const data = [];
        const rowsetRowCount = rowset.getRowCount();
        const selectedColumns = [];
        // eslint-disable-next-line no-nested-ternary
        const selectedRows = optionsWithDefaults.rows
            ? optionsWithDefaults.rows
            : rowsetRowCount
                ? fromCsvWithRanges(`0-${rowsetRowCount - 1}`)
                : [];
        for (
            let mapColumns =
                    optionsWithDefaults.columns && optionsWithDefaults.columns instanceof Array
                        ? valueCount(optionsWithDefaults.columns)
                        : null,
                c = 0,
                cols = rowset.getColCount();
            c < cols;
            c++
        ) {
            const colName = rowset.getColumnName(null, c);
            if (!mapColumns || colName in mapColumns) selectedColumns[selectedColumns.length] = c;
        }

        const colCount = selectedColumns.length;

        if (optionsWithDefaults.includeHeaderRow) {
            // eslint-disable-next-line no-multi-assign
            const header = (data[data.length] = []);

            for (let c = 0; c < colCount; c++) {
                const rowsetHeader = rowset.getHeader(selectedColumns[c]);
                header[header.length] =
                    (optionsWithDefaults.localizeValue
                        ? rowsetHeader.caption || rowsetHeader.name
                        : rowsetHeader.name) + (optionsWithDefaults.includeColumnType ? ` (${rowsetHeader.type})` : '');
            }
        }

        for (let r = 0, rows = selectedRows.length; r < rows; r++) {
            // eslint-disable-next-line no-multi-assign
            const row = (data[data.length] = []);

            for (let c = 0; c < colCount; c++)
                row[c] = optionsWithDefaults.localizeValue
                    ? this.getLocalizedValue(
                          selectedRows[r],
                          selectedColumns[c],
                          rowset,
                          optionsWithDefaults.localizeValue instanceof HTMLElement
                              ? optionsWithDefaults.localizeValue
                              : null,
                      )
                    : rowset.getField(selectedRows[r], selectedColumns[c]);
        }

        return data;
    },

    /** Replicates the tcf expression {@link https://dev.trapsoft.com/confluence/pages/viewpage.action?pageId=487|string-template}.
     * @param {HTMLElement} nodeLocale - The node to use for localizing the rowset fields
     * @param {String} template - Template string
     * @param {import('./rowset.js').Rowset} rs - Rowset with values
     * @param {number} row - Rowset row
     * @param {String} [breakStr] - Not yet implemented
     * @param {String} [prefix] - Not yet implemented
     * @returns {String}
     */
    template(nodeLocale, template, rs, row, breakStr, prefix) {
        let replacedField = false;
        /** escapeCharBackupReplacer */
        const escapeCharBackupReplacer = function escapeCharBackupReplacer(match, group1, offset, string) {
            return `$_ESCAPE_${group1.charCodeAt(0)}_$`;
        };
        /** escapeCharRestoreReplacer */
        const escapeCharRestoreReplacer = function escapeCharRestoreReplacer(match, group1, offset, string) {
            return String.fromCharCode(group1);
        };
        /** optionalReplacer */
        const optionalReplacer = function optionalReplacer(match, group1, offset, string) {
            let offsetNum = offset;
            let string2 = string;
            if (typeof offsetNum !== 'number') {
                // eslint-disable-next-line prefer-rest-params
                let i = 3;
                // eslint-disable-next-line prefer-rest-params
                for (let iLen = arguments.length; i < iLen; i++) if (typeof arguments[i] === 'number') break;
                // eslint-disable-next-line prefer-rest-params
                offsetNum = arguments[i];
                // eslint-disable-next-line prefer-rest-params
                string2 = arguments[i + 1];
            }
            if (offsetNum && string2[offsetNum - 1] === '\\') return match;
            const result = rowsetUtil.template(
                nodeLocale,
                group1.substr(1, group1.length - 2),
                rs,
                row,
                breakStr,
                prefix,
            );
            // @ts-ignore
            if (result._replacedField) return result.toString();
            return '';
        };
        /** fieldReplacer */
        const fieldReplacer = function fieldReplacer(match, group1, offset, string) {
            const fieldName = group1.substr(1, group1.length - 2);
            const col = rs.getColIndex(fieldName);
            if (col === -1) return '';
            const value = rowsetUtil.getLocalizedValue(row, col, rs, nodeLocale);
            if (!value) return '';
            replacedField = true;
            return value;
        };
        // eslint-disable-next-line no-new-wrappers
        const result = new String(
            template
                .replace(_templateEscCharBackup, escapeCharBackupReplacer)
                .replace(_templateOptional, optionalReplacer)
                .replace(_templateFields, fieldReplacer)
                .replace(_templateFieldsHandlebars, fieldReplacer)
                .replace(_templateEscCharRestore, escapeCharRestoreReplacer)
                .replace(/\\/g, ''),
        );
        // @ts-ignore
        result._replacedField = replacedField;
        // @ts-ignore
        return result;
    },
};
