/* eslint-disable no-new-wrappers */
/* eslint-disable no-nested-ternary */
/* eslint-disable no-plusplus */
/* eslint-disable no-param-reassign */
/* eslint-disable func-names */
/* eslint-disable require-jsdoc */
// @ts-check
// Provides a mechanism for retrieving, managing and persisting data. See confluence for more information.

import { AOP } from '@trapezegroup/core-js-aop/src/lib/aop.js';
import { toDisplayValue } from '../fields/fields.js';
import { Criteria } from './criteria.js';
import { Rowset } from '../rowset.js';
import { TcfVariant } from '../types.js';
import { rowsetUtil } from '../rowsetUtil.js';

/**
 * Returns a rowset grouped by the specified criteria with a count of rows for each group.
 * If the criteria isn't grouped, then a rowset with the total number of rows is returned.
 * @param {AbstractDataSource} ds - The data source object
 * @param {Criteria} criteria - The criteria object
 * @param {String} [colNameCount=count] - The name for the count column
 * @returns {import('../rowset.js').Rowset} The grouped rowset
 */
export const getGroupedRowsetByCount = function(ds, criteria, colNameCount) {
    colNameCount = colNameCount || 'count';

    const groupedRowset = new Rowset();
    const column = criteria.groupByClauses.length && criteria.groupByClauses[0].column;
    groupedRowset.addCol(colNameCount, '8', null, 0);
    groupedRowset.addCol(column, '10');

    if (criteria.groupByClauses.length)
        for (let r = 0, rows = ds.rowset.getRowCount(); r < rows; r++)
            groupedRowset.addRow([ds.getGroupSize(r), ds.rowset.getField(r, column)]);
    else groupedRowset.addRow([ds.rowset.getRowCount(), colNameCount]);

    return groupedRowset;
};

class AbstractDataSource {
    constructor() {
        this.criteria = new Criteria();

        /** @type {Rowset} */
        this.rowset = null;
    }

    /** Gets the current filtering Criteria */
    getCriteria() {
        return this.criteria;
    }

    // Sets the current filtering Criteria.
    // This Criteria will be used the next time a fetch is invoked.
    setCriteria(criteria) {
        this.criteria = criteria;
    }

    // Set Criteria effective row range
    setRowsForCriteriaInclusion(arrayOfRows) {
        this.criteria.setRowsToInclude(arrayOfRows);
    }

    setFixedRows(arrayOfRows) {
        arrayOfRows = Criteria.prototype._formatArray.call(this, arrayOfRows);
        this.fixedRows = [];
        for (let i = 0; i < arrayOfRows.length + 1; i++) this.fixedRows[arrayOfRows[i]] = true;
    }

    // Replaces all current data in the DataSource Object.
    setData(data) {
        throw new Error('Unimplemented API: Core.System.AbstractDataSource.setData');
    }

    // This method will initialize the data. The method must be called before the data can be accessed.
    // properties - Optional - Allows us to perform actions such as specifying callbacks and/or queries so that only
    //							subsets of data are used.
    //
    fetch(properties) {
        throw new Error('Unimplemented API: Core.System.AbstractDataSource.fetch');
    }

    // This method will close the data source. The method must be called when finished with the DataSource.
    // Code is used for tidying up the
    close() {
        throw new Error('Unimplemented API: Core.System.AbstractDataSource.close');
    }

    //
    getValue(item, attribute, defaultValue) {
        throw new Error('Unimplemented API: Core.System.AbstractDataSource.getValue');
    }

    //
    setValue(item, attribute, value) {
        throw new Error('Unimplemented API: Core.System.AbstractDataSource.setValue');
    }

    //
    isItem(item) {
        throw new Error('Unimplemented API: Core.System.AbstractDataSource.isItem');
    }

    getGroupSize(r) {}
}

export class RowsetDataSource extends AbstractDataSource {
    constructor(rawJsonRowset) {
        super();

        this.dirtyFields = [];
        this.localeNode = document.body;

        this.inSwitchMode = false;
        this.switchInit = false;

        this.groupingExceptions = [];
        this.setFixedRows([]);
        this.setRowsForCriteriaInclusion('0');

        // Pagination members
        this.pagination = false;
        this.totalRows = null;
        this.totalCols = null;
        this.suppliedRowsFrom = null;
        this.suppliedRowsTo = null;
        this.suppliedColsFrom = null;
        this.suppliedColsTo = null;
        this.pagUrl = null;
        this.pagPageSize = null;

        if (rawJsonRowset) this.setData(rawJsonRowset);
    }

    //
    // Sets the Data on the underlying Rowset.
    //
    setData(rawJsonRowset) {
        this.close();

        this.dirtyFields = [];

        this.inSwitchMode = false;
        this.switchInit = rawJsonRowset._switchInit || false;

        this.rowset = new Rowset(rawJsonRowset);
        AOP.aroundAll(this.rowset, { getRow: this._aroundGetRow, setCell: this._aroundSetCell }, this);
        AOP.beforeAll(
            this.rowset,
            {
                getRowIndex: this._beforeGetRowIndex,
                getRowCount: this._beforeGetRowCount,
            },
            this,
        );
        AOP.afterAll(
            this.rowset,
            {
                addRow: this._afterAddRow,
                insertRowAt: this._afterAddRow,
                removeRow: this._afterRemoveRow,
            },
            this,
        );

        this.wrappedHasRow = false;

        if (
            rawJsonRowset.attributes &&
            rawJsonRowset.attributes.pagination &&
            rawJsonRowset.attributes.pagination.toLowerCase() === 'true'
        ) {
            this.pagination = true;
            this.totalRows = parseInt(rawJsonRowset.attributes.pagMaxRows, 10);
            this.totalCols = parseInt(rawJsonRowset.attributes.pagMaxCols, 10);
            this.suppliedRowsFrom = parseInt(rawJsonRowset.attributes.pagSuppliedRows.split('-')[0], 10);
            this.suppliedRowsTo = parseInt(rawJsonRowset.attributes.pagSuppliedRows.split('-')[1], 10);
            this.suppliedColsFrom = parseInt(rawJsonRowset.attributes.pagSuppliedCols.split('-')[0], 10);
            this.suppliedColsTo = parseInt(rawJsonRowset.attributes.pagSuppliedCols.split('-')[1], 10);
            this.pagUrl = rawJsonRowset.attributes.pagUrl;
            this.pagPageSize = parseInt(rawJsonRowset.attributes.pagPageSize, 10);
            this.pageStatus = [];
            AOP.beforeAll(this.rowset, { getCell: this._beforeGetCell, getField: this._beforeGetCell }, this);
        }
        this._wrapHasRow();

        this._rowOrder = [];

        this._initRowOrder();
        this.setRowsForCriteriaInclusion(`0-${this.rowset.getRowCount()}`);
    }

    setLocaleNode(localeNode) {
        this.localeNode = localeNode;
    }

    // Performs switching logic when a cell is requested.
    _aroundGetCell(proceed, scope, row, col) {
        // TODO check if Cell is rowset and wrap in a RowsetDataSource
        if (this.inSwitchMode && this._isSwitched !== true) {
            this._isSwitched = true;
            col = this._getRealRow(col);
            const result = col === undefined ? '' : proceed.call(scope, col, row);
            this._isSwitched = false;
            return result;
        }
        row = this._getRealRow(row);
        return row === undefined ? '' : proceed.call(scope, row, col);
    }

    _aroundFind(proceed, scope, value, colIndex, startRow) {
        let result = proceed.call(scope, value, colIndex, startRow);
        result = this.getAliasRow(result);
        if (result === undefined) return -1;
        return result;
    }

    _aroundGetColumn(proceed, scope, row, col) {
        // TODO check if Cell is rowset and wrap in a RowsetDataSource
        if (this.inSwitchMode && this._isSwitched !== true) {
            this._isSwitched = true;
            const result = proceed.call(scope, col, row);
            this._isSwitched = false;
            return result;
        }
        return proceed.call(scope, row, col);
    }

    // Ensures that the field being retrieved exists and has been properly initialized.
    _beforeGetCell(scope, row, col) {
        if (this.inSwitchMode && this._isSwitched !== true) {
            if (col != null && this.rowset.json.data[col] === undefined) this._loadPageHandler(col);
        } else if (row != null && row > -1 && this.rowset.json.data[row] === undefined) {
            const reqContext = this._createPageRequestContext(row);
            if (this.pageStatus[reqContext.page] === undefined) this.pageStatus[reqContext.page] = {};
            const pageStatus = this.pageStatus[reqContext.page];

            if (pageStatus.loading === true) return this._rowNotLoadedHandler(row, col);

            if (pageStatus.loading !== true && pageStatus.loaded !== true) {
                this._loadPageHandler(reqContext);
                this.pageStatus[reqContext.page].loading = true;
                return this._rowNotLoadedHandler(row, col);
            }
        }
        return undefined;
    }

    _beforeGetRowCount(scope, realDataRowCount) {
        if (realDataRowCount) return undefined;
        return this._rowsToSort === undefined ? undefined : this._rowsToSort.length;
    }

    _beforeGetRowIndex(scope, row, col) {
        return this._getRealRow(row);
    }

    setPageLoadedHandler(impl) {
        this._pageLoadedHandler = impl;
    }

    _pageLoadedHandler(context) {}

    // Provides a way of setting a production implementation of _rowNotLoadedHandler.
    setRowNotLoadedHandler(impl) {
        this._rowNotLoadedHandler = impl;
    }

    _rowNotLoadedHandler(row, col) {
        return null;
    }

    // Provides a way of setting a production implementation of _loadPageHandler.
    setLoadPageHandler(impl) {
        this._loadPageHandler = impl;
    }

    // Loads a page of data from the data store.
    _loadPageHandler(paginationContext) {}

    // Adds a page of data (loaded for pagination) to the Rowset.
    supplyPage(paginationContext, json) {
        const newPage = json; // eval((transport.responseText || '').unfilterJSON());

        if (newPage.attributes && newPage.attributes.pagination.toLowerCase() === 'true') {
            const suppliedRowsFrom = parseInt(newPage.attributes.pagSuppliedRows.split('-')[0], 10);
            const suppliedRowsTo = parseInt(newPage.attributes.pagSuppliedRows.split('-')[1], 10) + 1;
            for (let i = suppliedRowsFrom, k = 0, len = suppliedRowsTo; i < len; i++, k++) {
                if (!this.rowset.json.data[i]) this.rowset.json.data[i] = [];
                for (let j = 0, len2 = this.rowset.getColCount(); j < len2; j++)
                    this.rowset.json.data[i][j] = newPage.data[k][j];
            }
            this._initRowOrder(suppliedRowsFrom, suppliedRowsTo);
        }

        // TODO Need to tie this code to also run after any custom implementations.
        this.pageStatus[paginationContext.page].loaded = true;
        this.pageStatus[paginationContext.page].loading = false;
        // Custom Logic specific to an implementation.
        this._pageLoadedHandler(paginationContext);
    }

    _createPageRequestContext(row) {
        let fromRow = 0;
        let toRow = 0;
        let page = 0;
        for (let i = 0; i < row; i += this.pagPageSize, page++) fromRow = i;

        toRow = fromRow + this.pagPageSize;
        fromRow++;

        const context = { origReqRow: row, fromRow, toRow, page };

        return context;
    }

    // Will generate a page of results. This is for testing only. The implementation will be server side.
    _generateFakePage(paginationContext, onSuccess) {
        const pc = paginationContext;

        // generate page
        const json = {};
        json._TCF_Rowset = 'version=1';
        json.attributes = {};
        json.attributes.pagination = 'true';
        json.attributes.pagMaxRows = '10000';
        json.attributes.pageMaxCols = '100';
        json.attributes.pagSuppliedRows = `${pc.fromRow}-${pc.toRow}`;
        json.attributes.pagSuppliedCols = this.rowset.getColCount();
        json.data = {};
        for (let i = 0, iLen = pc.toRow - pc.fromRow + 1; i < iLen; i++) {
            if (!json.data[i]) json.data[i] = [];
            for (let j = 0, jLen = this.rowset.getColCount(); j < jLen; j++)
                json.data[i][j] = this.rowset.json.defaults[j];
        }

        return json;
    }

    _aroundGetRow(proceed, scope, row) {
        return proceed.call(scope, this._getRealRow(row));
    }

    //
    // Perform additional behavior to the setField method.
    // Marks the edited field as dirty.
    //
    _aroundSetCell(proceed, scope, row, col, value) {
        // Make sure matrix Array exists

        if (this.inSwitchMode && this._isSwitched !== true) {
            this._isSwitched = true;
            if (this.dirtyFields[col] === undefined) {
                this.dirtyFields[col] = [];
            }
            this.dirtyFields[col][row] = value;
            const result = proceed.call(scope, col, row, value);
            this._isSwitched = false;
            return result;
        }
        const realRow = this._getRealRow(row);
        if (this.dirtyFields[realRow] === undefined) {
            this.dirtyFields[realRow] = [];
        }
        this.dirtyFields[realRow][col] = value;
        return proceed.call(scope, realRow, col, value);
    }

    /** The main function for retrieving a Rowset.
     * @param {Object} [properties] - Properties Defining the fetch result.
     * @param {Criteria} [properties.sortCriteria] -
     */
    fetch(properties) {
        if (properties) {
            this._initRowOrder();

            if (properties.sortCriteria) {
                this.criteria = properties.sortCriteria;
                this._applyCriteria();
            }
        }
        return this.rowset;
    }

    // Builds 3 arrays from the rowAliases, rows to include in criteria, rows to exclude in criteria and Fixed rows.
    // The rows to include in criteria Array is passed through each clause in the criteria.
    // The 3 Arrays are then merged back into the rowAlias Array.
    // TODO if we need to apply more than one criteria, try simply running this method for each criteria.
    _applyCriteria() {
        // TODO if we introduce multiple criteria Object for sorting different ranges of the Rowset,
        //		repeat the following code for each criteria Object.
        const clauses = this.criteria.getClauses();

        let rowsToSort = [];
        const sortExclusions = [];
        const fixedRows = [];

        // Find the rows to be effected by the criteria and apply the clauses to them
        for (let i = 0; i < this._rowOrder.length; i++) {
            if (this.fixedRows[i] === undefined)
                if (this.criteria.isRowEffected(this._rowOrder[i])) rowsToSort[i] = this._rowOrder[i];
                else sortExclusions[i] = this._rowOrder[i];
            else fixedRows[i] = this._rowOrder[i];
        }

        // Apply the clauses to them
        for (let i = 0; i < clauses.length; i++) {
            const clause = clauses[i];
            switch (clause.type) {
                case Criteria.WHERE:
                    rowsToSort = this._filter(rowsToSort, clause.colIdentifier, clause.operation, clause.value);
                    break;
                case Criteria.ORDERBY:
                    rowsToSort = this._sort(
                        rowsToSort,
                        clause.colIdentifier,
                        clause.comparator,
                        clause.orderAsc,
                        clause.localize,
                    );
                    break;
                case Criteria.GROUPBY:
                    rowsToSort = this._group(rowsToSort, clause.colIdentifier, clause.comparator);
                    break;
                case Criteria.GROUPBYEXCL:
                    rowsToSort = this._ungroup(rowsToSort, clause.rowsToExclude);
                    break;
                default:
            }
        }

        const origSize = this._rowOrder.length;
        this._rowOrder = [];

        // We need to work with a consistent rowToSort. So we need to format it by removing all undefined values.
        for (let i = 0; i < rowsToSort.length; i++)
            if (rowsToSort[i] === undefined) {
                rowsToSort.splice(i, 1);
                i--;
            }

        // TODO if there was grouping apply any grouping exceptions
        // ....Ungrouping code here, just before the merge.

        // Merge fixed, exclusion and inclusion values. Iterate through each row adding either Fixed, Excluded, Included or undefined values.
        for (let i = 0, incIndex = 0, excIndex = 0; i < origSize; i++, excIndex++) {
            // First check that we have a fixed value in this row
            if (fixedRows[i] !== undefined) this._rowOrder[i] = fixedRows[i];
            // Check if we have an exclusion in this row
            else if (sortExclusions[excIndex] !== undefined) this._rowOrder[i] = sortExclusions[excIndex];
            // If no fixed of excluded values for row then take the next sorted value from rowsToSort
            else if (rowsToSort[0] !== undefined) {
                this._rowOrder[i] = rowsToSort[incIndex];
                incIndex++;
            } else {
                // If there were no more values in rowsToSort (maybe a filter removed them) then get the next exclusion value or undefined if there is none
                excIndex = this._findNextIndexHelper(sortExclusions, excIndex + 1);
                this._rowOrder[i] = sortExclusions[excIndex];
            }
        }
        this._rowsToSort = rowsToSort;
    }

    _findNextIndexHelper(array, startIndex) {
        for (let i = startIndex; i < array.length; i++) if (array[i] !== undefined) return i;
        return array.length;
    }

    _findNextUndefinedHelper(array, startIndex) {
        for (let i = startIndex; i < array.length; i++) if (array[i] === undefined) return i;
        return array.length;
    }

    // Check if specified col parameter is a column name
    _isColumnName(col) {
        return this.rowset.getColumnNames().indexOf(col) > -1 || isNaN(col);
    }

    // Sort by a column in the Rowset. To sort only a section of the Rowset simply specify the startIndex and endIndex.
    // colIndex - (Required) The columnIndex to sort
    // comparator - (Required) function that will compare 2 values.
    //				The comparator should return
    //					-int if value1 < value2
    //					0 if value1 == value2
    //					+int if value1 > value2
    // orderAsc - (Optional - default true) true order asceding, false order descending
    // startIndex - (Optional - default 0) the index to start the ordering
    // endIndex - (optional - default is size of rowset) the index to stop the ordering
    _sort(rowsToSort, colIndex, comparator, orderAsc, localize) {
        if (this._isColumnName(colIndex)) colIndex = this.rowset.getColIndex(colIndex);

        if (colIndex < 0) localize = false;

        this._wrapGetters();
        let fieldsInfo = null;
        let dataType = null;
        if (localize) {
            fieldsInfo = this.rowset.getHeader(colIndex);
            dataType = new TcfVariant();
        }

        const objCache = {};

        // Wrap the comparator. Finds the 2 values from the rowset and pass them to the comparator.
        const compWrapper = function(left, right) {
            const realLeftValue = localize
                ? `${toDisplayValue(dataType.setValue(this.rowset.json.data[left][colIndex]), fieldsInfo)}`
                : colIndex < 0
                    ? objCache[left] || (objCache[left] = this.rowset.getRow(left).asObject())
                    : this.rowset.json.data[left][colIndex];
            const realRightValue = localize
                ? `${toDisplayValue(dataType.setValue(this.rowset.json.data[right][colIndex]), fieldsInfo)}`
                : colIndex < 0
                    ? objCache[right] || (objCache[right] = this.rowset.getRow(right).asObject())
                    : this.rowset.json.data[right][colIndex];
            if (orderAsc === undefined || orderAsc === true) return comparator(realLeftValue, realRightValue);
            return comparator(realRightValue, realLeftValue);
        }.bind(this);

        rowsToSort.sort(compWrapper);

        return rowsToSort;
    }

    // Filters a column using the regular expression passed.
    // To filter only a section of the Rowset, simply pass in the startIndex and endIndex.
    // Only rows shown where the value in the column specified tests positive against the RegExp will be available.
    // colIndex - (Required) the column to filter
    // operation - (Future use) the operation to use in forming the compare (equal, not equal, greater than etc.).
    // regExp - (Required) Array of Regular Expression to test the column values against. They are applied in an OR operation.
    _filter(rowsToSort, colIndex, operation, regExp) {
        this._wrapGetters();

        if (!Array.isArray(regExp)) regExp = [regExp];

        if (colIndex === null) {
            const cols = this.rowset.getColCount();

            for (let r = 0, rows = rowsToSort.length; r < rows; r++)
                if (rowsToSort[r] !== undefined) {
                    let matches = false;

                    for (let c = 0; c < cols && !matches; c++)
                        matches = this._filterIsValueMatch(c, this.rowset.json.data[rowsToSort[r]][c], regExp);

                    if (!matches) rowsToSort[r] = undefined;
                }
        } else {
            if (this._isColumnName(colIndex)) colIndex = this.rowset.getColIndex(colIndex);

            if (colIndex > -1 && colIndex < this.rowset.getColCount() && regExp.length) {
                for (let i = 0, len = rowsToSort.length; i < len; i++) {
                    if (rowsToSort[i] !== undefined) {
                        const matches = this._filterIsValueMatch(
                            colIndex,
                            this.rowset.json.data[rowsToSort[i]][colIndex],
                            regExp,
                        );

                        if (!matches) rowsToSort[i] = undefined;
                    }
                }
            }
        }

        return rowsToSort;
    }

    _filterIsValueMatch(col, rawValue, testValues) {
        let matches = false;

        if (rawValue != null) {
            const value = this.localizeValue(rawValue, col);

            for (let i = 0, iLen = testValues.length; i < iLen && !matches; i++)
                switch (typeof testValues[i]) {
                    case 'function':
                        matches = testValues[i](rawValue);
                        break;
                    case 'object':
                        matches = testValues[i].test(value);
                        break;
                    case 'string':
                        matches = `${value}`.toLowerCase().indexOf(`${testValues[i]}`.toLowerCase()) > -1;
                        break;
                    default:
                }
        }

        return matches;
    }

    localizeValue(value, col) {
        return rowsetUtil.getLocalizedValue(0, col, this.rowset, this.localeNode, value);
    }

    // Groups all of the rows in the Rowset by value.
    // For different type of grouping, use different comparators.
    _group(rowsToSort, colIndex, comparator) {
        this._wrapGetters();

        if (this._isColumnName(colIndex)) colIndex = this.rowset.getColIndex(colIndex);

        if (colIndex < 0) return rowsToSort;

        // Wrap the comparator. Finds the 2 values from the rowset and pass them to the comparator.
        const compWrapper = function(left, right) {
            if (left === undefined || right === undefined || left === false || right === false) return 0;
            const realLeftValue = this.rowset.json.data[rowsToSort[left]][colIndex];
            const realRightValue = this.rowset.json.data[rowsToSort[right]][colIndex];
            return comparator(realRightValue, realLeftValue);
        }.bind(this);

        for (let curRow = 0, len = rowsToSort.length; curRow < len; curRow++) {
            let nextRow = this._findNextIndexHelper(rowsToSort, curRow + 1);
            if (
                rowsToSort[curRow] !== undefined &&
                (rowsToSort[nextRow] !== undefined || curRow === len - 1 || nextRow === len)
            ) {
                // eslint-disable-next-line no-new-wrappers
                const groupHeader = new Number(rowsToSort[curRow]);
                rowsToSort[curRow] = groupHeader;
                // @ts-ignore
                groupHeader.subRows = [];
                // @ts-ignore
                groupHeader.expanded = false;

                // Compare this row with next. If same filter this row.
                for (
                    ;
                    (rowsToSort[nextRow] === undefined || compWrapper(curRow, nextRow) === 0) &&
                    nextRow < rowsToSort.length;
                    nextRow++
                ) {
                    if (rowsToSort[nextRow] !== undefined) {
                        // @ts-ignore
                        groupHeader.subRows.push(rowsToSort[nextRow]);
                        rowsToSort[nextRow] = undefined;
                    }
                }
                curRow = nextRow - 1;
            }
        }

        return rowsToSort;
    }

    // Iterates through the list of real rows in the ungroupList.
    // If it can find the real row, AND that entry is grouped, will expand that group.
    _ungroup(rowsToSort, ungroupList, comparator) {
        // Iterate through the rows to ungroup
        for (let i = 0; i < ungroupList.length; i++) {
            // Try to find real row in the rowsToSort
            const curRow = this._specialIndexOf(rowsToSort, ungroupList[i]);
            if (curRow > -1) {
                const { subRows } = rowsToSort[curRow];
                if (subRows !== undefined) {
                    // Mark group as expanded
                    rowsToSort[curRow].expanded = true;
                    // Add the subrows back into the rowsToSort and remove an undefined Row to keep the size of the array the same.
                    for (let j = 0; j < subRows.length; j++) {
                        const undefIndex = this._findNextUndefinedHelper(rowsToSort, curRow);
                        rowsToSort.splice(undefIndex, 1);
                        rowsToSort.splice(curRow + j + 1, 0, subRows[j]);
                    }
                }
            }
        }
        return rowsToSort;
    }

    _specialIndexOf(array, value) {
        for (let i = 0, size = array.length; i < size; i++) if (array[i] === value) return i;
        return -1;
    }

    isGroupHeader(row) {
        return this._rowOrder[row] !== undefined && this._rowOrder[row].subRows !== undefined;
    }

    getGroupSize(row) {
        if (this.isGroupHeader(row)) return this._rowOrder[row].subRows.length + 1;
        return -1;
    }

    isGroupExpanded(row) {
        return this.isGroupHeader(row) ? this._rowOrder[row].expanded : false;
    }

    getSubRows(row) {
        return this._rowOrder[row].subRows;
    }

    // Add a grouping exception. The row passed in is converted to the real row.
    // This ensures we don't lose position of the expanded group due to filtering or ordering as the real row never moves (but the alias will)
    addGroupException(rowAlias) {
        const realRow = this._getRealRow(rowAlias);
        this.groupingExceptions.push(realRow);
    }

    // Initializes the Row Alias map.
    _initRowOrder(from, to) {
        for (let i = from || 0, len = to || this.rowset.json.data.length; i < len; i++) {
            const alias = new Number(i);
            // @ts-ignore
            alias._alias = 1;
            const real = new Number(i);
            // @ts-ignore
            real._real = 1;
            // @ts-ignore
            this._rowOrder[alias] = real;
        }
    }

    // Given a rowAlias, will lookup and return the real row index in the Rowset.
    _getRealRow(rowAlias) {
        if (rowAlias instanceof Number && '_real' in rowAlias) return rowAlias;
        // return this.criteria.isRowEffected(rowAlias) ? rowAlias : this._rowOrder[rowAlias];
        return rowAlias < 0 ? rowAlias : this._rowOrder[rowAlias];
    }

    getActualRowIndex(rowAlias) {
        return this._getRealRow(rowAlias);
    }

    getAliasRow(realRow) {
        if (realRow instanceof Number && '_alias' in realRow) if (realRow < 0) return realRow;
        for (let i = 0, rowOrder = this._rowOrder, len = rowOrder.length; i < len; i++)
            if (rowOrder[i] === realRow) {
                const result = new Number(i);
                // @ts-ignore
                result._alias = 1;
                return result;
            }
        return -1;
    }

    isRowEffectedByCriteria(row) {
        return this.criteria.isRowEffected(row);
    }

    // Closes the dataSource
    // Performs any tidy up
    close() {
        this.rowset = null;
        // TODO any clean up
    }

    // Swiches the
    switchRowsCols(inSwitchMode) {
        if (inSwitchMode === true || inSwitchMode === false) {
            this.inSwitchMode = inSwitchMode;
        } else {
            this.inSwitchMode = !this.inSwitchMode;
        }

        this._wrapGetters();
    }

    // Initializes the wrapping of the Rowset methods.
    _wrapGetters() {
        if (this.switchInit === false) {
            this.switchInit = true;
            // @ts-ignore
            this.rowset._switchInit = true;

            AOP.aroundAll(
                this.rowset,
                {
                    getCell: this._aroundGetCell,
                    getField: this._aroundGetCell,
                    getCellDataType: this._aroundGetColumn,
                    getHeader: this._aroundGetColumn,
                    getColumnName: this._aroundGetColumn,
                    find: this._aroundFind,
                },
                this,
            );

            this._wrapHasRow();
        }
    }

    // Wraps the Rowset method hasRow. This is required because we want to perform the hasRow function
    // on the rowAlias map NOT the actual Rowset.
    _wrapHasRow() {
        if (!this.wrappedHasRow) {
            this.rowset.hasRow = function(row, col) {
                if (row === -1) return true;
                if (this.pagination) return row <= this.totalRows;

                const realRow = this._getRealRow(row);
                return typeof realRow !== 'undefined';
            }.bind(this);
            this.wrappedHasRow = true;
        }
    }

    _afterAddRow(result) {
        const index = new Number(this._rowOrder.length);
        // @ts-ignore
        index._w = 1;
        // @ts-ignore
        this._rowOrder[index] = result;
        return result;
    }

    _afterRemoveRow(result, scope, index) {
        // @ts-ignore
        this._rowOrder.splice(this.getAliasRow(index === undefined ? this.rowset.json.length - 1 : index), 1);
        return result;
    }

    // Returns whether the dataSource is currently switching row and column indexes
    isSwitched() {
        return !!this.inSwitchMode;
    }

    isDirtyField(row, col) {
        row = this._getRealRow(row);

        if (this.isSwitched()) {
            const temp = row;
            row = col;
            col = temp;
        } else row = this._getRealRow(row);
        if (typeof this.dirtyFields[row] !== 'undefined' && typeof this.dirtyFields[row][col] !== 'undefined')
            return true;

        return false;
    }

    // Returns a Rowset containing dirty fields.
    // The Rowset has 3 columns named r,c,v which are rowIndex, colIndex, new value respectively.
    getDirtyFields() {
        const rowset = new Rowset();
        rowset.addCol('r', '000008', null, null, false, null);
        rowset.addCol('c', '000008', null, null, false, null);
        rowset.addCol('v', '000010', null, null, false, null);
        for (let i = 0, rowCount = this.dirtyFields.length; i < rowCount; i++)
            if (this.dirtyFields[i])
                for (let j = 0, colCount = this.dirtyFields[i].length; j < colCount; j++)
                    if (typeof this.dirtyFields[i][j] !== 'undefined') {
                        if (this.dirtyFields[i][j] === '' || this.dirtyFields[i][j] === null)
                            rowset.addRow([i, j, null]);
                        else rowset.addRow([i, j, this.dirtyFields[i][j]]);
                    }

        return rowset;
    }

    // Takes a Rowset containing dirty fields.
    // The Rowset should have 3 columns named r,c,v which are rowIndex, colIndex, new value respectively.
    setDirtyFields(rowset) {
        const dummyFunc = function() {};
        const rowCol = rowset.getColIndex('r');
        const colCol = rowset.getColIndex('c');
        const valueCol = rowset.getColIndex('v');

        for (let i = 0, len = rowset.getRowCount(true); i < len; i++) {
            const row = rowset.getField(i, rowCol);
            const col = rowset.getField(i, colCol);
            const value = rowset.getField(i, valueCol);
            this._aroundSetCell(dummyFunc, this, row, col, value);
        }
    }

    serializeCriteria() {
        return this.criteria.serialize({});
    }

    deserializeCriteria(obj) {
        this.criteria.deserialize(obj);
        this._applyCriteria();
    }
}
