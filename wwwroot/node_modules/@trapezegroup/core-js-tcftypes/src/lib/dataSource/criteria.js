/* eslint-disable no-eval */
/* eslint-disable no-plusplus */
/* eslint-disable no-param-reassign */
// @ts-check

/** @typedef {number|string} CriteriaKey */

/** @typedef {Where|Order|GroupBy|GroupByExcl} AnyCriteria */

/**
 * @typedef {object} Where
 * @property {string} type
 * @property {string} colIdentifier
 * @property {string} operation
 * @property {function[] | string[] | RegExp[]} value
 * @property {CriteriaKey} key
 */

/**
 * @typedef {object} Order
 * @property {string} type
 * @property {string} colIdentifier
 * @property {string} comparator
 * @property {boolean} orderAsc
 * @property {boolean} localize
 * @property {CriteriaKey} key
 */

/**
 * @typedef {object} GroupBy
 * @property {string} type
 * @property {string} colIdentifier
 * @property {string} comparator
 * @property {CriteriaKey} key
 */

/**
 * @typedef {object} GroupByExcl
 * @property {number[]} rowsToExclude
 * @property {CriteriaKey} key
 */

/** Critera class used to add clauses to a DataSource for filtering, ordering, sorting, etc. */
export class Criteria {
    /** Instantiates a new Criteria */
    constructor() {
        /** @type {Where[]} */
        this.whereClauses = [];
        /** @type {Order[]} */
        this.orderByClauses = [];
        /** @type {GroupBy[]} */
        this.groupByClauses = [];
        /** @type {GroupByExcl[]} */
        this.groupByExclClauses = [];

        /** @type {any[] | boolean[]} */
        this.effectedRows = [];
    }

    /**
     * marks the range of rows to be excluded from the criteria
     * @param {string[]} arrayOfRows
     */
    setRowsToInclude(arrayOfRows) {
        const arrayOfRowsStr = this._formatArray(arrayOfRows);
        /** @type {any[] | boolean[]} */
        this.effectedRows = [];
        for (let i = 0; i < arrayOfRowsStr.length; i++) this.effectedRows[arrayOfRowsStr[i]] = true;
    }

    /**
     * @param {string[] | string} arrayOfRows
     */
    _formatArray(arrayOfRows) {
        const array = [];

        if (typeof arrayOfRows === 'string') {
            const candidates = arrayOfRows.split(',');
            for (let i = 0; i < candidates.length; i++) {
                if (candidates[i].length)
                    if (candidates[i].indexOf('-')) {
                        const range = candidates[i].split('-');
                        for (let j = parseInt(range[0], 10), len = parseInt(range[1], 10) + 1; j < len; j++)
                            array.push(j);
                    } else {
                        array.push(parseInt(candidates[i], 10));
                    }
            }
        } else {
            for (let i = 0, len = arrayOfRows.length + 1; i < len; i++) array.push(parseInt(arrayOfRows[i], 10));
        }
        return array;
    }

    /**
     * Validates that the Array has contiguous rows.
     * @param {number[]} arrayOfRows
     */
    _validateArray(arrayOfRows) {
        let check = 0;
        let i = check;

        do {
            check = arrayOfRows[i];
            if (check === undefined || check !== arrayOfRows[i - 1] + 1)
                throw new Error(
                    'Core.System.DataSource.Criteria: Range of Rows to include in Criteria must be contiguous. ie 2,3,4,5 not 2,3,5.',
                );
            i++;
        } while (i < arrayOfRows.length);

        for (i = 0; i < arrayOfRows.length; i++)
            if (arrayOfRows[i] === undefined || (i !== 0 && arrayOfRows[i] !== arrayOfRows[i - 1] + 1))
                throw new Error(
                    'Core.System.DataSource.Criteria: Range of Rows to include in Criteria must be contiguous. ie 2,3,4,5 not 2,3,5.',
                );
    }

    /**
     * @param {string | number} row
     */
    isRowEffected(row) {
        return this.effectedRows[row] === true;
    }

    // ------ Filter Clauses ------
    /**
     * @param {string} colIdentifier
     * @param {string} operation
     * @param {function[]|string[]|RegExp[]} value
     * @param {CriteriaKey} key
     * @returns {Where}
     */
    createWhereClause(colIdentifier, operation, value, key) {
        return {
            type: Criteria.WHERE,
            colIdentifier,
            operation,
            value,
            key: key || new Date().getTime(),
        };
    }

    /**
     * @param {Where} whereClause
     */
    addWhereClause(whereClause) {
        // Remove any previous where clause for this column
        // this._removeColIdentifierFromClauses(this.whereClauses, colIdentifier);
        // Add the new where clause
        // this.whereClauses.push(clause);
        // return clause;
        if (this.whereClauses.indexOf(whereClause) < 0) this.whereClauses.push(whereClause);
    }

    /**
     * @param {Where} whereClause
     */
    removeWhereClause(whereClause) {
        const start = this.whereClauses.indexOf(whereClause);
        this.whereClauses.splice(start, 1);
    }

    /** @returns {Where[]} */
    getWhereClauses() {
        return this.whereClauses;
    }

    /**
     * @param {CriteriaKey} key
     * @returns {Where}
     */
    getWhereClause(key) {
        return this._getClauseByKey('whereClauses', key);
    }

    /**
     * @param {Where} whereClause
     * @returns {boolean}
     */
    hasWhereClause(whereClause) {
        return this.whereClauses.indexOf(whereClause) !== -1;
    }

    // ------ Order Clauses ------
    /**
     * @param {string} colIdentifier
     * @param {string} comparator
     * @param {boolean} orderAsc
     * @param {boolean} localize
     * @param {CriteriaKey} key
     * @returns {Order}
     */
    createOrderByClause(colIdentifier, comparator, orderAsc, localize, key) {
        return {
            type: Criteria.ORDERBY,
            colIdentifier,
            comparator,
            orderAsc,
            localize: !!localize,
            key: key || new Date().getTime(),
        };
    }

    /**
     * @param {Order} orderByClause
     */
    addOrderBy(orderByClause) {
        if (this.orderByClauses.indexOf(orderByClause) < 0) this.orderByClauses.push(orderByClause);
    }

    /**
     * @param {Order} orderByClause
     */
    removeOrderBy(orderByClause) {
        const start = this.orderByClauses.indexOf(orderByClause);
        this.orderByClauses.splice(start, 1);
    }

    /** @returns {Order[]} */
    getOrderByClauses() {
        return this.orderByClauses;
    }

    /**
     * @param {CriteriaKey} key
     */
    getOrderByClause(key) {
        return this._getClauseByKey('orderByClauses', key);
    }

    // ------ Group Clauses ------
    /**
     * @param {string} colIdentifier
     * @param {string} comparator
     * @param {CriteriaKey} key
     * @returns {GroupBy}
     */
    createGroupByClause(colIdentifier, comparator, key) {
        return {
            type: Criteria.GROUPBY,
            colIdentifier,
            comparator,
            key: key || new Date().getTime(),
        };
    }

    /**
     * @param {GroupBy} groupByClause
     * @returns {number}
     */
    addGroupBy(groupByClause) {
        if (this.groupByClauses.indexOf(groupByClause) < 0) this.groupByClauses.push(groupByClause);
        return this.groupByClauses.length - 1;
    }

    /**
     * @param {GroupBy} groupByClause
     */
    removeGroupBy(groupByClause) {
        const start = this.groupByClauses.indexOf(groupByClause);
        this.groupByClauses.splice(start, 1);
    }

    /** @returns {GroupBy[]} */
    getGroupByClauses() {
        return this.groupByClauses;
    }

    /**
     * @param {CriteriaKey} key
     * @returns {GroupBy}
     */
    getGroupByClause(key) {
        return this._getClauseByKey('groupByClauses', key);
    }

    // ------ Group Exclusion Clauses ------
    /**
     * @param {number[]} rowsToExclude
     * @param {CriteriaKey} key
     */
    createGroupByExclClause(rowsToExclude, key) {
        return {
            type: Criteria.GROUPBYEXCL,
            rowsToExclude,
            key: key || new Date().getTime(),
        };
    }

    /**
     * @param {GroupByExcl} groupByExclClause
     */
    addGroupByExcl(groupByExclClause) {
        if (this.groupByExclClauses.indexOf(groupByExclClause) < 0) this.groupByExclClauses.push(groupByExclClause);
    }

    /**
     * @param {GroupByExcl} groupByExclClause
     */
    removeGroupByExcl(groupByExclClause) {
        const start = this.groupByExclClauses.indexOf(groupByExclClause);
        this.groupByExclClauses.splice(start, 1);
    }

    /** @returns {GroupByExcl[]} */
    getGroupByExclClauses() {
        return this.groupByExclClauses;
    }

    /** Remove all exlusins */
    removeAllGroupExclusions() {
        for (let i = 0; i < this.groupByExclClauses.length; i++) this.groupByExclClauses[i].rowsToExclude = [];
    }

    /**
     * @param {CriteriaKey} key
     */
    getGroupByExclClause(key) {
        return this._getClauseByKey('groupByExclClauses', key);
    }

    /**
     * Returns clauses in the order they should be performed.
     * 1 - Filters
     * 2 - Groups
     * 3 - Ordering
     * 4 - Group Exclusions (After ordering because we don't want ordering to effect the contents of a group. Ordering on the group could, optionally, be done later.)
     * @returns {AnyCriteria[]}
     */
    getClauses() {
        return (
            this.whereClauses

                // @ts-ignore
                .concat(this.orderByClauses)
                .concat(this.groupByClauses)
                .concat(this.groupByExclClauses)
        );
    }

    /**
     * @param {string} clauseType
     * @param {CriteriaKey} key
     */
    _getClauseByKey(clauseType, key) {
        const clauses = this[clauseType];
        for (let i = 0, iLen = clauses.length; i < iLen; i++) if (clauses[i].key === key) return clauses[i];
        return undefined;
    }

    /** @returns {{whereClauses: CriteriaKey[], orderByClauses: CriteriaKey[], groupByClauses: CriteriaKey[], groupByExclClauses: CriteriaKey[]}} */
    getKeys() {
        return {
            whereClauses: this._getKeys('whereClauses'),
            orderByClauses: this._getKeys('orderByClauses'),
            groupByClauses: this._getKeys('groupByClauses'),
            groupByExclClauses: this._getKeys('groupByExclClauses'),
        };
    }

    /**
     * @param {string} clauseType
     * @returns {CriteriaKey[]}
     */
    _getKeys(clauseType) {
        const keys = [];
        const clauses = this[clauseType];
        for (let i = 0, iLen = clauses.length; i < iLen; i++) keys[keys.length] = clauses[i].key;
        return keys;
    }

    /** @returns {boolean} */
    hasClauses() {
        return this.getClauses().length > 0;
    }

    /**
     * @param {[Where,Order,GroupBy]} clauses
     * @param {string} colIdentifier
     */
    _removeColIdentifierFromClauses(clauses, colIdentifier) {
        for (let i = 0; i < clauses.length; i++) if (clauses[i].colIdentifier === colIdentifier) clauses.splice(i, 1);
    }

    /** @inheritdoc */
    toString() {}

    /** @inheritdoc */
    fromString() {}

    /** @typedef {{column: string, operation: string, value: string, key: CriteriaKey}} SerializedWhere */
    /**
     * Returns a Core.Type.Rowset containing where clauses.
     * The Rowset has 3 columns named column, operation, value.
     * @returns {SerializedWhere[]}}
     */
    serializeWhereClauses() {
        const clauses = [];
        for (let i = 0, rowCount = this.whereClauses.length; i < rowCount; i++) {
            let { value } = this.whereClauses[i];
            if (Array.isArray(value)) {
                const whereClauseValue = this.whereClauses[i].value;
                value = [];
                for (let j = 0, jLen = whereClauseValue.length; j < jLen; j++)
                    value[j] = whereClauseValue[j].toString();
            } else {
                // @ts-ignore
                value = value.toString();
            }
            clauses.push({
                column: this.whereClauses[i].colIdentifier,
                operation: this.whereClauses[i].operation,
                value,
                key: this.whereClauses[i].key,
            });
        }
        // @ts-ignore
        return clauses;
    }

    /**
     * @param {SerializedWhere[]} obj
     */
    deserializeWhereClauses(obj) {
        for (let i = 0, len = obj.length; i < len; i++) {
            let { value } = obj[i];
            if (Array.isArray(value)) {
                for (let j = 0, jLen = value.length; j < jLen; j++) value[j] = eval(value[j]);
            } else value = eval(value);
            // @ts-ignore
            this.addWhereClause(this.createWhereClause(obj[i].column, obj[i].operation, value, obj[i].key));
        }
    }

    /** @typedef {{column: string, comparator: string, orderAsc: boolean, localize: boolean, key: CriteriaKey}} SerializedOrder */
    /**
     * Returns a Core.Type.Rowset containing Order By clauses.
     * The Rowset has 3 columns named column, comparator, orderAsc.
     * @returns {SerializedOrder[]}}
     */
    serializeOrderByClauses() {
        const clauses = [];
        for (let i = 0, rowCount = this.orderByClauses.length; i < rowCount; i++)
            clauses.push({
                column: this.orderByClauses[i].colIdentifier,
                comparator: this.orderByClauses[i].comparator.toString(),
                orderAsc: this.orderByClauses[i].orderAsc,
                localize: this.orderByClauses[i].localize,
                key: this.orderByClauses[i].key,
            });
        return clauses;
    }

    /**
     * @param {SerializedOrder[]} obj
     */
    deserializeOrderByClauses(obj) {
        for (let i = 0, len = obj.length; i < len; i++)
            this.addOrderBy(
                this.createOrderByClause(
                    obj[i].column,
                    eval(`(temp=${obj[i].comparator})`),
                    obj[i].orderAsc,
                    obj[i].localize,
                    obj[i].key,
                ),
            );
    }

    /** @typedef {{column: string, comparator: string, key: CriteriaKey}} SerializedGroupBy */
    /**
     * Returns a Core.Type.Rowset containing Group By clauses.
     * The Rowset has 2 columns named column, operation, value.
     * @returns {SerializedGroupBy[]}}
     */
    serializeGroupByClauses() {
        const clauses = [];
        for (let i = 0, rowCount = this.groupByClauses.length; i < rowCount; i++)
            clauses.push({
                column: this.groupByClauses[i].colIdentifier,
                comparator: this.groupByClauses[i].comparator.toString(),
                key: this.groupByClauses[i].key,
            });
        return clauses;
    }

    /**
     * @param {SerializedGroupBy[]} obj
     */
    deserializeGroupByClauses(obj) {
        for (let i = 0, len = obj.length; i < len; i++)
            this.addGroupBy(this.createGroupByClause(obj[i].column, eval(`(temp=${obj[i].comparator})`), obj[i].key));
    }

    /** @typedef {{rowsToExclude: string, key: CriteriaKey}} SerializedGroupByExcl */
    /** @returns {SerializedGroupByExcl[]} */
    serializeGroupByExclClauses() {
        const clauses = [];
        for (let i = 0, rowCount = this.groupByExclClauses.length; i < rowCount; i++)
            clauses.push({
                rowsToExclude: this.groupByExclClauses[i].rowsToExclude.join(','),
                key: this.groupByExclClauses[i].key,
            });
        return clauses;
    }

    /**
     * @param {SerializedGroupByExcl[]} obj
     */
    deserializeGroupByExclClauses(obj) {
        for (let i = 0, len = obj.length; i < len; i++) {
            const rowsToExcl = [];
            const strings = obj[i].rowsToExclude.split(',');
            for (let j = 0; j < strings.length; j++)
                if (strings[j].length > 0) rowsToExcl.push(parseInt(strings[j], 10));
            this.addGroupByExcl(this.createGroupByExclClause(rowsToExcl, obj[i].key));
        }
    }

    /**
     * @param {{ whereClauses: SerializedWhere[]; orderByClauses: SerializedOrder[]; groupByClauses: SerializedGroupBy[]; groupByExclClauses: SerializedGroupByExcl[]; }} obj
     */
    serialize(obj) {
        // @ts-ignore
        if (!obj) obj = {};
        obj.whereClauses = this.serializeWhereClauses();
        obj.orderByClauses = this.serializeOrderByClauses();
        obj.groupByClauses = this.serializeGroupByClauses();
        obj.groupByExclClauses = this.serializeGroupByExclClauses();
        return obj;
    }

    /**
     * @param {{ whereClauses: SerializedWhere[]; orderByClauses: SerializedOrder[]; groupByClauses: SerializedGroupBy[]; groupByExclClauses: SerializedGroupByExcl[]; }} obj
     */
    deserialize(obj) {
        this.deserializeWhereClauses(obj.whereClauses);
        this.deserializeOrderByClauses(obj.orderByClauses);
        this.deserializeGroupByClauses(obj.groupByClauses);
        this.deserializeGroupByExclClauses(obj.groupByExclClauses);
    }
}

Criteria.WHERE = 'where';
Criteria.ORDERBY = 'orderby';
Criteria.GROUPBY = 'groupby';
Criteria.GROUPBYEXCL = 'groupbyexcl';
