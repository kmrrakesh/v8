// @ts-check
/* global expect, describe, it */
import * as tcfTypes from '../../../src/lib/types.js';
import { TypeInfo, TCFType } from '../../../src/lib/typeInfo.js';
import { Rowset, RowsetRow } from '../../../src/lib/rowset.js';
import { rowsetUtil } from '../../../src/lib/rowsetUtil.js';

/**
 * @param {any} obj
 */
const clone = function(obj) {
    return JSON.parse(JSON.stringify(obj));
};

const customMatchers = {
    toEqual: (util, customEqualityTesters) => ({
        compare: (actual, expected) => {
            const result = {};
            result.pass = util.equals(actual, expected, customEqualityTesters) || actual == expected;
            if (!result.pass) {
                result.message = function() {
                    return `Expected ${actual} to equal ${expected}`;
                };
            }
            return result;
        },
    }),
};

/**
 * @param {string|any} expectedOrMessage
 * @param {any} actualOrExpected
 * @param {any} [actual]
 */
const assertEquals = function(expectedOrMessage, actualOrExpected, actual) {
    if (actual) {
        expect(actual).toEqual(actualOrExpected, expectedOrMessage);
    } else {
        expect(actualOrExpected).toEqual(expectedOrMessage);
    }
};

/**
 * @param {string|any} expectedOrMessage
 * @param {any} actualOrExpected
 * @param {any} [actual]
 */
const assertMatch = function(expectedOrMessage, actualOrExpected, actual) {
    if (actual) {
        expect(actual).toMatch(actualOrExpected, expectedOrMessage);
    } else {
        expect(actualOrExpected).toMatch(expectedOrMessage);
    }
};

/** @param {*} value */
const assertObject = function(value) {
    expect(typeof value).toContain('object');
};

/** @param {*} obj */
const assertFunction = function(obj) {
    expect(typeof obj).toBe('function');
};

/**
 * @param {*} message
 * @param {*} func
 */
const assertException = function(message, func) {
    expect(func).toThrow();
};

/**
 * @param {*} message
 * @param {*} func
 */
const assertNoException = function(message, func) {
    expect(func).not.toThrow();
};

/**
 * @param {*} tag
 * @param {*} properties
 */
const createElement = function(tag, properties) {
    const element = document.createElement(tag);
    for (const name in properties) {
        element.setAttribute(name, properties[name]);
    }
    return element;
};

describe('Core.Type', () => {
    beforeEach(() => {
        // @ts-ignore
        jasmine.addMatchers(customMatchers);
    });

    /** @param {string} method */
    const assertCommonWholeNumberTest = function(method) {
        expect(tcfTypes[method]()).toBe(false);
        expect(tcfTypes[method](true)).toBe(false);
        expect(tcfTypes[method](false)).toBe(false);
        expect(tcfTypes[method]('a')).toBe(false);
        expect(tcfTypes[method](0.1)).toBe(false);
        expect(tcfTypes[method](-9223372036854777000)).toBe(false); // Rounded because its greater Number.MIN_SAFE_INTEGER
        expect(tcfTypes[method](9223372036854777000)).toBe(false); // Rounded because its greater Number.MAX_SAFE_INTEGER

        expect(tcfTypes[method](null)).toBe(true);
        expect(tcfTypes[method]('')).toBe(true);
    };

    /** @param {string} method */
    const assertCommonRealNumberTest = function(method) {
        expect(tcfTypes[method]('a')).toBe(false);
        expect(tcfTypes[method]('1.1.1')).toBe(false);

        expect(tcfTypes[method]()).toBe(true); // Inconsistent
        expect(tcfTypes[method](null)).toBe(true);
        expect(tcfTypes[method](1)).toBe(true);
        expect(tcfTypes[method](1.1)).toBe(true);
        expect(tcfTypes[method](-1)).toBe(true);
        expect(tcfTypes[method](-1.1)).toBe(true);

        expect(tcfTypes[method]('')).toBe(true);
        expect(tcfTypes[method]('1')).toBe(true);
        expect(tcfTypes[method]('1.1')).toBe(true);
        expect(tcfTypes[method]('-1')).toBe(true);
        expect(tcfTypes[method]('-1.1')).toBe(true);
    };

    it('IsInt', () => {
        assertCommonWholeNumberTest('isInt');

        expect(tcfTypes.isInt(0)).toBe(true);
        expect(tcfTypes.isInt(1)).toBe(true);
        expect(tcfTypes.isInt('0')).toBe(true);
        expect(tcfTypes.isInt('1')).toBe(true);
    });

    it('IsByte', () => {
        assertCommonWholeNumberTest('isByte');

        expect(tcfTypes.isByte(-1)).toBe(false);
        expect(tcfTypes.isByte(256)).toBe(false);
        expect(tcfTypes.isByte('-1')).toBe(false);
        expect(tcfTypes.isByte('256')).toBe(false);

        expect(tcfTypes.isByte(0)).toBe(true);
        expect(tcfTypes.isByte(255)).toBe(true);
        expect(tcfTypes.isByte('0')).toBe(true);
        expect(tcfTypes.isByte('255')).toBe(true);
    });

    it('IsSByte', () => {
        assertCommonWholeNumberTest('isSByte');

        expect(tcfTypes.isSByte(-129)).toBe(false);
        expect(tcfTypes.isSByte(128)).toBe(false);
        expect(tcfTypes.isSByte('-129')).toBe(false);
        expect(tcfTypes.isSByte('128')).toBe(false);

        expect(tcfTypes.isSByte(-128)).toBe(true);
        expect(tcfTypes.isSByte(127)).toBe(true);
        expect(tcfTypes.isSByte('-128')).toBe(true);
        expect(tcfTypes.isSByte('127')).toBe(true);
    });

    it('IsChar', () => {
        expect(tcfTypes.isChar(10)).toBe(false);
        expect(tcfTypes.isChar('10')).toBe(false);
        expect(tcfTypes.isChar('aa')).toBe(false);
        expect(tcfTypes.isChar(true)).toBe(false);
        expect(tcfTypes.isChar(false)).toBe(false);

        expect(tcfTypes.isChar(0)).toBe(true);
        expect(tcfTypes.isChar(1)).toBe(true);
        expect(tcfTypes.isChar('0')).toBe(true);
        expect(tcfTypes.isChar('1')).toBe(true);
        expect(tcfTypes.isChar('a')).toBe(true);
    });

    it('IsUInt16', () => {
        assertCommonWholeNumberTest('isUInt16');

        expect(tcfTypes.isUInt16(-1)).toBe(false);
        expect(tcfTypes.isUInt16(65536)).toBe(false);
        expect(tcfTypes.isUInt16('-1')).toBe(false);
        expect(tcfTypes.isUInt16('65536')).toBe(false);

        expect(tcfTypes.isUInt16(0)).toBe(true);
        expect(tcfTypes.isUInt16(65535)).toBe(true);
        expect(tcfTypes.isUInt16('0')).toBe(true);
        expect(tcfTypes.isUInt16('65535')).toBe(true);
    });

    it('IsInt16', () => {
        assertCommonWholeNumberTest('isInt16');

        expect(tcfTypes.isInt16(-32769)).toBe(false);
        expect(tcfTypes.isInt16(32768)).toBe(false);
        expect(tcfTypes.isInt16('-32769')).toBe(false);
        expect(tcfTypes.isInt16('32768')).toBe(false);

        expect(tcfTypes.isInt16(-32768)).toBe(true);
        expect(tcfTypes.isInt16(32767)).toBe(true);
        expect(tcfTypes.isInt16('-32768')).toBe(true);
        expect(tcfTypes.isInt16('32767')).toBe(true);
    });

    it('IsUInt32', () => {
        assertCommonWholeNumberTest('isUInt32');

        expect(tcfTypes.isUInt32(-1)).toBe(false);
        expect(tcfTypes.isUInt32(4294967296)).toBe(false);
        expect(tcfTypes.isUInt32('-1')).toBe(false);
        expect(tcfTypes.isUInt32('4294967296')).toBe(false);

        expect(tcfTypes.isUInt32(0)).toBe(true);
        expect(tcfTypes.isUInt32(4294967295)).toBe(true);
        expect(tcfTypes.isUInt32('0')).toBe(true);
        expect(tcfTypes.isUInt32('4294967295')).toBe(true);
    });

    it('IsInt32', () => {
        assertCommonWholeNumberTest('isInt32');

        expect(tcfTypes.isInt32(-2147483649)).toBe(false);
        expect(tcfTypes.isInt32(2147483648)).toBe(false);
        expect(tcfTypes.isInt32('-2147483649')).toBe(false);
        expect(tcfTypes.isInt32('2147483648')).toBe(false);

        expect(tcfTypes.isInt32(-2147483648)).toBe(true);
        expect(tcfTypes.isInt32(2147483647)).toBe(true);
        expect(tcfTypes.isInt32('-2147483648')).toBe(true);
        expect(tcfTypes.isInt32('2147483647')).toBe(true);
    });

    it('IsLong', () => {
        assertCommonWholeNumberTest('isLong');

        expect(tcfTypes.isLong('-9223372036854775808')).toBe(false);
        expect(tcfTypes.isLong('9223372036854775808')).toBe(false);
        expect(tcfTypes.isLong('9223372036854775809')).toBe(false);

        expect(tcfTypes.isLong('-9223372036854775807')).toBe(true);
        expect(tcfTypes.isLong('9223372036854775806')).toBe(true);
    });

    it('IsFloat', () => {
        assertCommonRealNumberTest('isFloat');

        expect(tcfTypes.isFloat('.0')).toBe(false);
        expect(tcfTypes.isFloat('.1')).toBe(false);
        expect(tcfTypes.isFloat('-.0')).toBe(false);
        expect(tcfTypes.isFloat('-.1')).toBe(false);

        expect(tcfTypes.isFloat(1.1e10)).toBe(true);
        expect(tcfTypes.isFloat(1.1e10)).toBe(true);
        expect(tcfTypes.isFloat(1.1e-10)).toBe(true);
        expect(tcfTypes.isFloat(-1.1e10)).toBe(true);
        expect(tcfTypes.isFloat(-1.1e10)).toBe(true);
        expect(tcfTypes.isFloat(-1.1e-10)).toBe(true);

        expect(tcfTypes.isFloat('1.1e10')).toBe(true);
        expect(tcfTypes.isFloat('1.1e+10')).toBe(true);
        expect(tcfTypes.isFloat('1.1e-10')).toBe(true);
        expect(tcfTypes.isFloat('-1.1e10')).toBe(true);
        expect(tcfTypes.isFloat('-1.1e+10')).toBe(true);
        expect(tcfTypes.isFloat('-1.1e-10')).toBe(true);
    });

    it('IsDouble', () => {
        assertCommonRealNumberTest('isDouble');

        expect(tcfTypes.isDouble('.0')).toBe(true);
        expect(tcfTypes.isDouble('.1')).toBe(true);
        expect(tcfTypes.isDouble('-.0')).toBe(true);
        expect(tcfTypes.isDouble('-.1')).toBe(true);
    });

    it('IsString', () => {
        expect(TypeInfo.isString(13)).toBe(false);
        expect(TypeInfo.isString(14)).toBe(true);
        expect(TypeInfo.isString(15)).toBe(true);
        expect(TypeInfo.isString(16)).toBe(true);
        expect(TypeInfo.isString(17)).toBe(false);
    });

    it('IsRowset', () => {
        expect(TypeInfo.isRowset(16)).toBe(false);
        expect(TypeInfo.isRowset(17)).toBe(true);
        expect(TypeInfo.isRowset(18)).toBe(false);
    });

    // it('IsTime', () =>
    // {
    //     expect(tcfTypes.TcfisTime()).toBe(false);
    //     expect(tcfTypes.TcfisTime(null)).toBe(false);
    //     expect(tcfTypes.TcfisTime(true)).toBe(false);
    //     expect(tcfTypes.TcfisTime(false)).toBe(false);
    //     expect(tcfTypes.TcfisTime(0)).toBe(false);
    //     expect(tcfTypes.TcfisTime(1)).toBe(false);
    //     expect(tcfTypes.TcfisTime('0:00:00')).toBe(false);
    //     expect(tcfTypes.TcfisTime('1:00:00')).toBe(false);
    //     expect(tcfTypes.TcfisTime('00:00:00 AM')).toBe(false);
    //     expect(tcfTypes.TcfisTime('00:00:00 PM')).toBe(false);

    //     expect(tcfTypes.TcfisTime(' 00:00-00')).toBe(false);
    //     expect(tcfTypes.TcfisTime('00:00-00 ')).toBe(false);
    //     expect(tcfTypes.TcfisTime(' 00:00-00 ')).toBe(false);

    //     expect(tcfTypes.TcfisTime('00:00-00')).toBe(false);
    //     expect(tcfTypes.TcfisTime('00-00:00')).toBe(false);
    //     expect(tcfTypes.TcfisTime('00-00-00')).toBe(false);

    //     expect(tcfTypes.TcfisTime('00:00:60')).toBe(false);
    //     expect(tcfTypes.TcfisTime('00:60:00')).toBe(false);
    //     expect(tcfTypes.TcfisTime('24:00:00')).toBe(false);
    //     expect(tcfTypes.TcfisTime('24:60:60')).toBe(false);

    //     expect(tcfTypes.TcfisTime('00:00:00')).toBe(true);
    //     expect(tcfTypes.TcfisTime('00:00:01')).toBe(true);
    //     expect(tcfTypes.TcfisTime('00:00:59')).toBe(true);
    //     expect(tcfTypes.TcfisTime('00:01:00')).toBe(true);
    //     expect(tcfTypes.TcfisTime('00:59:00')).toBe(true);
    //     expect(tcfTypes.TcfisTime('01:00:00')).toBe(true);
    //     expect(tcfTypes.TcfisTime('10:00:00')).toBe(true);
    //     expect(tcfTypes.TcfisTime('20:00:00')).toBe(true);
    //     expect(tcfTypes.TcfisTime('23:00:00')).toBe(true);
    //     expect(tcfTypes.TcfisTime('23:59:59')).toBe(true);
    // });
});

describe('rowsetUtil', () => {
    beforeEach(() => {
        // @ts-ignore
        jasmine.addMatchers(customMatchers);
    });

    const rowset1 = new Rowset({
        _TCF_Rowset: 'version=1',
        mode: 0,
        header: [
            { name: 'col-null-1', type: '10' },
            { name: 'col-null-2', type: '10' },
            { name: 'col-empty-str-1', type: '10' },
            { name: 'col-empty-str-2', type: '10' },
            { name: 'col-1', type: '10' },
            { name: 'col-2', type: '10' },
        ],
        defaults: [null, null, null],
        data: [[null, null, '', '', 'cell-1:1', 'cell-1:2'], [null, null, '', '', 'cell-2:1', 'cell-2:2']],
    });

    const rowset2 = new Rowset({
        _TCF_Rowset: 'version=1',
        mode: 0,
        header: [
            { name: 'boolean', type: '1' },
            { name: 'wholeNumber', type: '6' },
            { name: 'realNumber', type: 'C' },
            { name: 'string', type: '10' },
            { name: 'time', type: '140009' },
        ],
        defaults: [null, null, null, null, null],
        data: [[false, 0, 0.0, '', 0], [true, 1, 1.1, 'a', 43200], [true, 2, 2.2, 'b', 64800]],
    });

    const rowset3 = new Rowset({
        _TCF_Rowset: 'version=1',
        mode: 0,
        header: [{ name: 'col-1', type: '1' }, { name: 'col-2', type: '1' }, { name: 'col-3', type: '1' }],
        defaults: [null, null, null, null],
        data: [],
    });

    const rowset4 = new Rowset({
        _TCF_Rowset: 'version=1',
        mode: 0,
        header: [],
        defaults: [null, null, null, null],
        data: [],
    });

    it('_is_TCF_Rowset', () => {
        expect(() => {
            rowsetUtil.is_TCF_Rowset(null);
        }).toThrowError();

        expect(rowsetUtil.is_TCF_Rowset(true)).toBe(false);
        expect(rowsetUtil.is_TCF_Rowset(false)).toBe(false);
        expect(rowsetUtil.is_TCF_Rowset(0)).toBe(false);
        expect(rowsetUtil.is_TCF_Rowset(1)).toBe(false);
        expect(rowsetUtil.is_TCF_Rowset('')).toBe(false);
        expect(rowsetUtil.is_TCF_Rowset('0')).toBe(false);
        expect(rowsetUtil.is_TCF_Rowset('1')).toBe(false);
        expect(rowsetUtil.is_TCF_Rowset([])).toBe(false);
        expect(rowsetUtil.is_TCF_Rowset({})).toBe(false);
        expect(rowsetUtil.is_TCF_Rowset({ _TCF_Rowset: undefined })).toBe(false);

        expect(rowsetUtil.is_TCF_Rowset({ _TCF_Rowset: null })).toBe(true);
        expect(rowsetUtil.is_TCF_Rowset({ _TCF_Rowset: 'version=1' })).toBe(true);
    });

    it('RowsetToHtml', () => {
        // eslint-disable-next-line prettier/prettier
        expect(rowsetUtil.rowsetToHtml(rowset4).outerHTML).toEqual(`<table><thead><tr></tr></thead><tbody></tbody></table>`);

        // eslint-disable-next-line prettier/prettier
        expect(rowsetUtil.rowsetToHtml(rowset3).outerHTML).toEqual(`<table><thead><tr><th>col-1 (1)</th><th>col-2 (1)</th><th>col-3 (1)</th></tr></thead><tbody></tbody></table>`);

        expect(rowsetUtil.rowsetToHtml(rowset3, { includeHeaderRow: false }).outerHTML).toEqual(
            `<table><tbody></tbody></table>`,
        );

        // eslint-disable-next-line prettier/prettier
        expect(rowsetUtil.rowsetToHtml(rowset2).outerHTML).toEqual(`<table><thead><tr><th>boolean (1)</th><th>wholeNumber (6)</th><th>realNumber (C)</th><th>string (10)</th><th>time (140009)</th></tr></thead><tbody><tr><td>false</td><td>0</td><td>0</td><td></td><td>0</td></tr><tr><td>true</td><td>1</td><td>1.1</td><td>a</td><td>43200</td></tr><tr><td>true</td><td>2</td><td>2.2</td><td>b</td><td>64800</td></tr></tbody></table>`);
    });

    it('RowsetToCsv', () => {
        expect(rowsetUtil.rowsetToCsv(rowset2))
            .toEqual(`"boolean (1)","wholeNumber (6)","realNumber (C)","string (10)","time (140009)"
"false","0","0","","0"
"true","1","1.1","a","43200"
"true","2","2.2","b","64800"
`);
    });

    it('RowsetToText', () => {
        expect(rowsetUtil.rowsetToText(rowset4)).toEqual('\n');
        expect(rowsetUtil.rowsetToText(rowset3)).toEqual('col-1 (1) col-2 (1) col-3 (1)\n');
        expect(rowsetUtil.rowsetToText(rowset3, { includeHeaderRow: false })).toEqual('');
        expect(rowsetUtil.rowsetToText(rowset2))
            .toEqual(`boolean (1) wholeNumber (6) realNumber (C) string (10) time (140009)
false       0               0                          0            
true        1               1.1            a           43200        
true        2               2.2            b           64800        
`);

        // Test option: fieldDelimiter
        expect(rowsetUtil.rowsetToText(rowset2, { fieldDelimiter: ',' }))
            .toEqual(`boolean (1),wholeNumber (6),realNumber (C),string (10),time (140009)
false,      0,              0,             ,           0            
true,       1,              1.1,           a,          43200        
true,       2,              2.2,           b,          64800        
`);

        // Test option: fieldEnclosure
        expect(rowsetUtil.rowsetToText(rowset2, { fieldEnclosure: "'" }))
            .toEqual(`'boolean (1)' 'wholeNumber (6)' 'realNumber (C)' 'string (10)' 'time (140009)'
'false'       '0'               '0'              ''            '0'            
'true'        '1'               '1.1'            'a'           '43200'        
'true'        '2'               '2.2'            'b'           '64800'        
`);

        // Test option: prettyPrint
        expect(rowsetUtil.rowsetToText(rowset2, { prettyPrint: false }))
            .toEqual(`boolean (1) wholeNumber (6) realNumber (C) string (10) time (140009)
false 0 0  0
true 1 1.1 a 43200
true 2 2.2 b 64800
`);

        // Test option: rowDelimiter
        //         expect(rowsetUtil.rowsetToText(rowset2, { rowDelimiter: '\r\n' })).toEqual(`boolean (1) wholeNumber (6) realNumber (C) string (10) time (140009)
        // false       0               0                          0
        // true        1               1.1            a           43200
        // true        2               2.2            b           64800
        // `);
    });

    it('RowsetToArray', () => {
        expect([]).toEqual(rowsetUtil.rowsetToArray(rowset4));
        expect([]).toEqual(rowsetUtil.rowsetToArray(rowset3));
        expect([]).toEqual(rowsetUtil.rowsetToArray(rowset3, { includeHeaderRow: false }));
        expect([
            {
                'boolean (1)': false,
                'wholeNumber (6)': 0,
                'realNumber (C)': 0.0,
                'string (10)': '',
                'time (140009)': 0,
            },
            {
                'boolean (1)': true,
                'wholeNumber (6)': 1,
                'realNumber (C)': 1.1,
                'string (10)': 'a',
                'time (140009)': 43200,
            },
            {
                'boolean (1)': true,
                'wholeNumber (6)': 2,
                'realNumber (C)': 2.2,
                'string (10)': 'b',
                'time (140009)': 64800,
            },
            // @ts-ignore
        ]).toEqual(rowsetUtil.rowsetToArray(rowset2));
    });

    it('RowsetTo2DArray', () => {
        expect(rowsetUtil.rowsetTo2DArray(rowset4)).toEqual([[]]);
        expect(rowsetUtil.rowsetTo2DArray(rowset3)).toEqual([['col-1 (1)', 'col-2 (1)', 'col-3 (1)']]);

        // Test option: none
        expect(rowsetUtil.rowsetTo2DArray(rowset2)).toEqual([
            ['boolean (1)', 'wholeNumber (6)', 'realNumber (C)', 'string (10)', 'time (140009)'],
            [false, 0, 0.0, '', 0],
            [true, 1, 1.1, 'a', 43200],
            [true, 2, 2.2, 'b', 64800],
        ]);

        // Test option: localizeValue
        document.body.setAttribute('localeFormatTime', '8');
        expect(rowsetUtil.rowsetTo2DArray(rowset2, { localizeValue: true })).toEqual([
            ['boolean (1)', 'wholeNumber (6)', 'realNumber (C)', 'string (10)', 'time (140009)'],
            ['0', '0', '0', '', '00:00'],
            ['1', '1', '1.1', 'a', '12:00'],
            ['1', '2', '2.2', 'b', '18:00'],
        ]);
        document.body.removeAttribute('localeFormatTime');

        const node = createElement('div', { localeFormatTime: 8 });
        assertEquals(
            [
                ['boolean (1)', 'wholeNumber (6)', 'realNumber (C)', 'string (10)', 'time (140009)'],
                ['0', '0', '0', '', '00:00'],
                ['1', '1', '1.1', 'a', '12:00'],
                ['1', '2', '2.2', 'b', '18:00'],
            ],
            rowsetUtil.rowsetTo2DArray(rowset2, { localizeValue: node }),
        );

        // Test option: includeColumnType
        assertEquals(
            [
                ['boolean', 'wholeNumber', 'realNumber', 'string', 'time'],
                [false, 0, 0.0, '', 0],
                [true, 1, 1.1, 'a', 43200],
                [true, 2, 2.2, 'b', 64800],
            ],
            rowsetUtil.rowsetTo2DArray(rowset2, { includeColumnType: false }),
        );

        // Test option: includeHeaderRow
        assertEquals(
            [[false, 0, 0.0, '', 0], [true, 1, 1.1, 'a', 43200], [true, 2, 2.2, 'b', 64800]],
            rowsetUtil.rowsetTo2DArray(rowset2, { includeHeaderRow: false }),
        );

        // Test option: columns

        assertEquals(
            [['boolean (1)'], [false], [true], [true]],
            rowsetUtil.rowsetTo2DArray(rowset2, { columns: 'boolean' }),
        );

        assertEquals(
            [['wholeNumber (6)', 'realNumber (C)'], [0, 0.0], [1, 1.1], [2, 2.2]],
            rowsetUtil.rowsetTo2DArray(rowset2, { columns: 'wholeNumber,realNumber' }),
        );

        assertEquals(
            [['boolean (1)'], [false], [true], [true]],
            rowsetUtil.rowsetTo2DArray(rowset2, { columns: ['boolean'] }),
        );

        assertEquals(
            [['wholeNumber (6)', 'realNumber (C)'], [0, 0.0], [1, 1.1], [2, 2.2]],
            rowsetUtil.rowsetTo2DArray(rowset2, { columns: ['wholeNumber', 'realNumber'] }),
        );

        // Test option: rows
        assertEquals(
            [
                ['boolean (1)', 'wholeNumber (6)', 'realNumber (C)', 'string (10)', 'time (140009)'],
                [false, 0, 0.0, '', 0],
            ],
            rowsetUtil.rowsetTo2DArray(rowset2, { rows: '0' }),
        );

        assertEquals(
            [
                ['boolean (1)', 'wholeNumber (6)', 'realNumber (C)', 'string (10)', 'time (140009)'],
                [true, 1, 1.1, 'a', 43200],
            ],
            rowsetUtil.rowsetTo2DArray(rowset2, { rows: '1' }),
        );

        assertEquals(
            [
                ['boolean (1)', 'wholeNumber (6)', 'realNumber (C)', 'string (10)', 'time (140009)'],
                [true, 2, 2.2, 'b', 64800],
            ],
            rowsetUtil.rowsetTo2DArray(rowset2, { rows: '2' }),
        );

        assertEquals(
            [
                ['boolean (1)', 'wholeNumber (6)', 'realNumber (C)', 'string (10)', 'time (140009)'],
                [false, 0, 0.0, '', 0],
                [true, 1, 1.1, 'a', 43200],
            ],
            rowsetUtil.rowsetTo2DArray(rowset2, { rows: '0-1' }),
        );

        assertEquals(
            [
                ['boolean (1)', 'wholeNumber (6)', 'realNumber (C)', 'string (10)', 'time (140009)'],
                [true, 1, 1.1, 'a', 43200],
                [true, 2, 2.2, 'b', 64800],
            ],
            rowsetUtil.rowsetTo2DArray(rowset2, { rows: '1-2' }),
        );

        assertEquals(
            [
                ['boolean (1)', 'wholeNumber (6)', 'realNumber (C)', 'string (10)', 'time (140009)'],
                [false, 0, 0.0, '', 0],
                [true, 2, 2.2, 'b', 64800],
            ],
            rowsetUtil.rowsetTo2DArray(rowset2, { rows: '0,2' }),
        );

        assertEquals(
            [
                ['boolean (1)', 'wholeNumber (6)', 'realNumber (C)', 'string (10)', 'time (140009)'],
                [false, 0, 0.0, '', 0],
                [true, 1, 1.1, 'a', 43200],
                [true, 2, 2.2, 'b', 64800],
            ],
            rowsetUtil.rowsetTo2DArray(rowset2, { rows: '0-2' }),
        );

        assertEquals(
            [
                ['boolean (1)', 'wholeNumber (6)', 'realNumber (C)', 'string (10)', 'time (140009)'],
                [false, 0, 0.0, '', 0],
                [true, 1, 1.1, 'a', 43200],
                [true, 2, 2.2, 'b', 64800],
            ],
            rowsetUtil.rowsetTo2DArray(rowset2, { rows: [0, 1, 2] }),
        );
    });

    it('Template', () => {
        // Reserved Sequences
        // expect('\n', rowsetUtil.template(document.body, '<br>', rowset1, 0)). toEqual(<br>', 'reserved sequence);
        // Placeholders
        expect(rowsetUtil.template(document.body, '<col-1>', rowset1, 0)).toEqual('cell-1:1', '1 placeholder');
        expect(rowsetUtil.template(document.body, '<col-1> <col-1>', rowset1, 0)).toEqual(
            'cell-1:1 cell-1:1',
            '2 same placeholder',
        );
        expect(rowsetUtil.template(document.body, '<col-1> <col-2>', rowset1, 0)).toEqual(
            'cell-1:1 cell-1:2',
            '2 different placeholder',
        );
        expect(rowsetUtil.template(document.body, '<col-1>', rowset1, 1)).toEqual(
            'cell-2:1',
            '1 placeholder different row',
        );
        expect(rowsetUtil.template(document.body, '<col-1> <col-1>', rowset1, 1)).toEqual(
            'cell-2:1 cell-2:1',
            '2 same placeholder different row',
        );
        expect(rowsetUtil.template(document.body, '<col-1> <col-2>', rowset1, 1)).toEqual(
            'cell-2:1 cell-2:2',
            '2 different placeholder different row',
        );
        expect(rowsetUtil.template(document.body, '<col-4>', rowset1, 0)).toEqual('', "1 doesn't exists");
        expect(rowsetUtil.template(document.body, '<col-4> <col-4>', rowset1, 0)).toEqual(' ', "2 same doesn't exists");
        expect(rowsetUtil.template(document.body, '<col-4> <col-5>', rowset1, 0)).toEqual(
            ' ',
            "2 different doesn't exists",
        );
        expect(rowsetUtil.template(document.body, '<col-4>', rowset1, 0)).toEqual('', '1 empty string');
        expect(rowsetUtil.template(document.body, '<col-empty-str-1> <col-empty-str-1>', rowset1, 0)).toEqual(
            ' ',
            '2 same empty string',
        );
        expect(rowsetUtil.template(document.body, '<col-empty-str-1> <col-empty-str-2>', rowset1, 0)).toEqual(
            ' ',
            '2 different empty string',
        );
        expect(rowsetUtil.template(document.body, '<col-null-1>', rowset1, 0)).toEqual('', '1 null');
        expect(rowsetUtil.template(document.body, '<col-null-1> <col-null-1>', rowset1, 0)).toEqual(' ', '2 same null');
        expect(rowsetUtil.template(document.body, '<col-null-1> <col-null-2>', rowset1, 0)).toEqual(
            ' ',
            '2 diffrent null',
        );
        // Groups
        expect(rowsetUtil.template(document.body, '[<col-1>]', rowset1, 0)).toEqual(
            'cell-1:1',
            '1 group 1 placeholder with data',
        );
        expect(rowsetUtil.template(document.body, '[<col-null-1>]', rowset1, 0)).toEqual(
            '',
            '1 group 1 placeholder with null data',
        );
        expect(rowsetUtil.template(document.body, '[<col-empoty-str-1>]', rowset1, 0)).toEqual(
            '',
            '1 group 1 placeholder with empty str data',
        );
        expect(rowsetUtil.template(document.body, '[<col-1> <col-1>]', rowset1, 0)).toEqual(
            'cell-1:1 cell-1:1',
            '1 group 2 placeholder with same data',
        );
        expect(rowsetUtil.template(document.body, '[<col-1> <col-2>]', rowset1, 0)).toEqual(
            'cell-1:1 cell-1:2',
            '1 group 2 placeholder with different data',
        );
        expect(rowsetUtil.template(document.body, '[<col-1> <col-null-1>]', rowset1, 0)).toEqual(
            'cell-1:1 ',
            '1 group 2 placeholder with data and null data',
        );
        expect(rowsetUtil.template(document.body, '[<col-null-1> <col-null-2>]', rowset1, 0)).toEqual(
            '',
            '1 group 2 placeholder with null data and null data',
        );
        expect(rowsetUtil.template(document.body, '[<col-empoty-str-1> <col-empoty-str-2>]', rowset1, 0)).toEqual(
            '',
            '1 group 2 placeholder with empty str data and empty str data',
        );
        expect(rowsetUtil.template(document.body, '[<col-null-1> <col-empty-str-1>]', rowset1, 0)).toEqual(
            '',
            '1 group 2 placeholder with null data and empty str data',
        );
        expect(rowsetUtil.template(document.body, '[<col-empty-str-1> <col-null-1>]', rowset1, 0)).toEqual(
            '',
            '1 group 2 placeholder with empty str data and null data',
        );
        // TODO test nested groups...
        // Escape Characters
        expect(rowsetUtil.template(document.body, '\\<\\[\\<<col-1>\\>\\]\\>', rowset1, 0)).toEqual(
            '<[<cell-1:1>]>',
            '6 escape characters',
        );
        // TODO test break and prefix parameters when implemented...
    });
});

describe('TypeInfo', () => {
    beforeEach(() => {
        // @ts-ignore
        jasmine.addMatchers(customMatchers);
    });

    it('IsString', () => {
        expect(new TypeInfo(TCFType.TCF_Single).isString()).toBe(false);
        expect(new TypeInfo(TCFType.TCF_Rowset).isString()).toBe(false);
        expect(new TypeInfo(TCFType.TCF_STR).isString()).toBe(true);
        expect(new TypeInfo(TCFType.TCF_WSTR).isString()).toBe(true);
        expect(new TypeInfo(TCFType.TCF_String).isString()).toBe(true);
    });

    it('IsNumber', () => {
        expect(new TypeInfo(TCFType.TCF_Boolean).isNumber()).toBe(false);
        expect(new TypeInfo(TCFType.TCF_STR).isNumber()).toBe(false);
        expect(new TypeInfo(TCFType.TCF_Byte).isNumber()).toBe(true);
        expect(new TypeInfo(TCFType.TCF_SByte).isNumber()).toBe(true);
        expect(new TypeInfo(TCFType.TCF_Char).isNumber()).toBe(true);
        expect(new TypeInfo(TCFType.TCF_WChar).isNumber()).toBe(true);
        expect(new TypeInfo(TCFType.TCF_Int16).isNumber()).toBe(true);
        expect(new TypeInfo(TCFType.TCF_UInt16).isNumber()).toBe(true);
        expect(new TypeInfo(TCFType.TCF_Int32).isNumber()).toBe(true);
        expect(new TypeInfo(TCFType.TCF_UInt32).isNumber()).toBe(true);
        expect(new TypeInfo(TCFType.TCF_Int64).isNumber()).toBe(true);
        expect(new TypeInfo(TCFType.TCF_UInt64).isNumber()).toBe(true);
        expect(new TypeInfo(TCFType.TCF_Double).isNumber()).toBe(true);
        expect(new TypeInfo(TCFType.TCF_Single).isNumber()).toBe(true);
    });

    it('IsIntegral', () => {
        expect(new TypeInfo(TCFType.TCF_Boolean).isIntegral()).toBe(false);
        expect(new TypeInfo(TCFType.TCF_Double).isIntegral()).toBe(false);
        expect(new TypeInfo(TCFType.TCF_Byte).isIntegral()).toBe(true);
        expect(new TypeInfo(TCFType.TCF_SByte).isIntegral()).toBe(true);
        expect(new TypeInfo(TCFType.TCF_Char).isIntegral()).toBe(true);
        expect(new TypeInfo(TCFType.TCF_WChar).isIntegral()).toBe(true);
        expect(new TypeInfo(TCFType.TCF_Int16).isIntegral()).toBe(true);
        expect(new TypeInfo(TCFType.TCF_UInt16).isIntegral()).toBe(true);
        expect(new TypeInfo(TCFType.TCF_Int32).isIntegral()).toBe(true);
        expect(new TypeInfo(TCFType.TCF_UInt32).isIntegral()).toBe(true);
        expect(new TypeInfo(TCFType.TCF_Int64).isIntegral()).toBe(true);
        expect(new TypeInfo(TCFType.TCF_UInt64).isIntegral()).toBe(true);
    });

    it('IsReal', () => {
        expect(new TypeInfo(TCFType.TCF_UInt64).isReal()).toBe(false);
        expect(new TypeInfo(TCFType.TCF_STR).isReal()).toBe(false);
        expect(new TypeInfo(TCFType.TCF_Double).isReal()).toBe(true);
        expect(new TypeInfo(TCFType.TCF_Single).isReal()).toBe(true);
    });

    it('Initialize', () => {
        const types = getTypesInstances();
        // expectAsserts(getTypesLength());
        for (const type in types) {
            expect(type).toEqual(types[type].getType());
        }
    });

    it('Set', () => {
        // Test all combinations of type switching
        // expectAsserts(getTypesLength() * getTypesLength() + 6);
        const types = getTypesInstances();
        for (const fromType in types) {
            for (const toType in TCFType) {
                types[fromType].set(TCFType[toType]);
                expect(TCFType[toType]).toEqual(types[fromType].getType());
            }
        }

        // Test setting type to null, undefined, invalid values
        // TODO Test setting type to null, undefined, invalid values

        let info = new TypeInfo();
        info.set(0x140009);
        expect(0x0).toEqual(info.getType());
        expect(0x0).toEqual(info.getFormat());
        expect(0x0).toEqual(info.getExt());

        info = new TypeInfo();
        info.set(0x09, 0x14, 0x0);
        expect(0x09).toEqual(info.getType());
        expect(0x0).toEqual(info.getFormat());
        expect(0x14).toEqual(info.getExt());
    });

    it('Clear', () => {
        const info = new TypeInfo();

        info.set(0x09, 0x14, 0x0);
        expect(0x09).toEqual(info.getType());
        expect(0x0).toEqual(info.getFormat());
        expect(0x14).toEqual(info.getExt());

        info.clear();
        expect(0x0).toEqual(info.getType());
        expect(0x0).toEqual(info.getFormat());
        expect(0x0).toEqual(info.getExt());
    });

    it('FormatStyle', () => {
        expect(new TypeInfo('C240C').getFormatStyle()).toEqual(2, 'format precision 2');
        expect(new TypeInfo('C3A0C').getFormatStyle()).toEqual(3, 'format precision 3');
    });

    it('FormatPrecision', () => {
        expect(new TypeInfo('C240C').getFormatPrecision()).toEqual(4, 'format precision 4');
        expect(new TypeInfo('C2A0C').getFormatPrecision()).toEqual(10, 'format precision 10');
    });
});

const getTypesInstances = function() {
    const instances = {};
    for (const type in TCFType) instances[TCFType[type]] = new TypeInfo(TCFType[type]);
    return instances;
};

// const getTypesLength = function()
//     {
//         if(Unit.TypeInfo.Helpers.TypesLength)
//             return Unit.TypeInfo.Helpers.TypesLength;
//         let i = 0,
//             type;
//         for(type in TCFType)
//             i++
//         return Unit.TypeInfo.Helpers.TypesLength = i;
//     }

describe('tcfTypes.TcfDataTypesMap', () => {
    beforeEach(() => {
        // @ts-ignore
        jasmine.addMatchers(customMatchers);
    });

    beforeAll(() => {
        // let dataTypes = this.dataTypes = {};
        // let types = [tcfTypes];
        // let abstractType = tcfTypes.AbstractType;
        // for(let i = 0, iLen = types.length; i < iLen; i++)
        // {
        //     let subTypes = types[i];
        //     for(let name in subTypes)
        //     {
        //         let c = subTypes[name];
        //         let className = c._coreClass_className;
        //         if(className && name.indexOf('Abstract') === -1 && className != 'tcfTypes.TcfCsv' && Core.Class.extendsClass(c, abstractType))
        //             dataTypes[className] = 1;
        //     }
        // }
    });

    // it('GetDataType', () =>
    // {
    //     let dataTypes = this.dataTypes;
    //     let dtmap = tcfTypes.TcfDataTypesMap;
    //     for(let dt in dataTypes)
    //         expect(dtmap.getDataType(dtmap.getHex(dt))._coreClass_className).toEqual(dt);
    // });

    /* it('GetHex', () =>
    {
        Tested with testGetDataType
    } */
});

describe('tcfTypes.TcfJSON', () => {
    beforeEach(() => {
        // @ts-ignore
        jasmine.addMatchers(customMatchers);
    });

    // beforeAll(() =>
    // {
    //     //TODO Add Rowset
    //     let dataTypes = this.json = {};
    //     let types = [tcfTypes];
    //     let abstractType = tcfTypes.AbstractType;
    //     for(let i = 0, iLen = types.length; i < iLen; i++)
    //     {
    //         let subTypes = types[i];
    //         for(let name in subTypes)
    //         {
    //             let c = subTypes[name];
    //             let className = name;
    //             switch(className)
    //             {
    //                 case 'String': dataTypes[className] = new c('string'); break;
    //                 case 'Boolean': dataTypes[className] = new c(true); break;
    //                 case 'Byte': dataTypes[className] = new c(126); break;
    //                 case 'SByte': dataTypes[className] = new c(64); break;
    //                 case 'Char': dataTypes[className] = new c('c'); break;
    //                 case 'Int16':
    //                 case 'UInt16':
    //                 case 'Int32':
    //                 case 'UInt32':
    //                 case 'Int64':
    //                 case 'UInt64':
    //                 case 'Double':
    //                 case 'Single': dataTypes[className] = new c(123); break;
    //                 case 'WeekdaysStr': dataTypes[className] = new c('0101010'); break;
    //                 case 'WeekdaysInt': dataTypes[className] = new c(127); break;
    //                 case 'Time': dataTypes[className] = new c(123); break;
    //                 case 'TimeSpan': dataTypes[className] = new c(124); break;
    //                 case 'BigTimeSpan': dataTypes[className] = new c(123); break;
    //                 case 'Date': dataTypes[className] = new c(20090102); break;
    //                 case 'DateTime': dataTypes[className] = new c(123); break;
    //                 case 'Distance': dataTypes[className] = new c(123); break;
    //                 case 'DistanceInt': dataTypes[className] = new c(123); break;
    //                 case 'Speed': dataTypes[className] = new c(123); break;
    //                 case 'Volume': dataTypes[className] = new c(123); break;
    //                 case 'Pressure': dataTypes[className] = new c(123); break;
    //                 case 'Acceleration': dataTypes[className] = new c(123); break;
    //                 case 'Temperature': dataTypes[className] = new c(123); break;
    //                 case 'FuelEconomy': dataTypes[className] = new c(123); break;
    //                 case 'ColorRef': dataTypes[className] = new c(0x11111111); break;
    //                 case 'Color': dataTypes[className] = new c(0x11111111); break;
    //                 case 'ColorAlpha': dataTypes[className] = new c(0x11111111); break;
    //             }

    //         }
    //     }
    // });

    // it('Reviver', () =>
    // {
    //     let firstStringified = JSON.stringify(this.json, tcfTypes.TcfJSON.replacer);
    //     expect(JSON.stringify(JSON.parse(firstStringified, tcfTypes.TcfJSON.reviver), tcfTypes.TcfJSON.replacer)). toEqual(firstStringified, 'stringify to parse to stringify');
    // });
    /* ,
    
    it('Replacer', () =>
    {
        Tested with testReviver
    } */
});

describe('tcfTypes.TcfString', () => {
    beforeEach(() => {
        // @ts-ignore
        jasmine.addMatchers(customMatchers);
    });

    // tcfTypes.TcfAbstractType

    it('ToString', () => {
        expect(new tcfTypes.TcfString().toString()).toEqual('');
        expect(new tcfTypes.TcfString(null).toString()).toEqual('');
        expect(new tcfTypes.TcfString('').toString()).toEqual('');
        expect(new tcfTypes.TcfString('0').toString()).toEqual('0');
        expect(new tcfTypes.TcfString('1').toString()).toEqual('1');
        expect(new tcfTypes.TcfString('a').toString()).toEqual('a');
    });

    it('FromString', () => {
        expect(new tcfTypes.TcfString().fromString(null).getValue()).toEqual(null);
        expect(new tcfTypes.TcfString().fromString('').getValue()).toEqual('');
        expect(new tcfTypes.TcfString().fromString('0').getValue()).toEqual('0');
        expect(new tcfTypes.TcfString().fromString('1').getValue()).toEqual('1');
        expect(new tcfTypes.TcfString().fromString('a').getValue()).toEqual('a');

        const obj = new tcfTypes.TcfString();
        expect(obj.fromString('')).toEqual(obj);
    });

    // tcfTypes.TcfString

    it('Validate', () => {
        expect(new tcfTypes.TcfString().validate(undefined)).toBe(false);
        expect(new tcfTypes.TcfString().validate(null)).toBe(false);
        // @ts-ignore
        expect(new tcfTypes.TcfString().validate(false)).toBe(false);
        // @ts-ignore
        expect(new tcfTypes.TcfString().validate(0)).toBe(false);

        expect(new tcfTypes.TcfString().validate('')).toBe(true);
        expect(new tcfTypes.TcfString().validate('1')).toBe(true);
    });

    it('GetComparator', () => {
        assertFunction(new tcfTypes.TcfString().getComparator());
        expect(new tcfTypes.TcfString().getComparator()).toEqual(tcfTypes.stringComparator);
    });
});

describe('tcfTypes.TcfCsv', () => {
    beforeEach(() => {
        // @ts-ignore
        jasmine.addMatchers(customMatchers);
    });

    it('Validate', () => {
        expect(new tcfTypes.TcfCsv().validate(null)).toBe(false);
        // @ts-ignore
        expect(new tcfTypes.TcfCsv().validate(false)).toBe(false);
        // @ts-ignore
        expect(new tcfTypes.TcfCsv().validate(true)).toBe(false);
        // @ts-ignore
        expect(new tcfTypes.TcfCsv().validate(0)).toBe(false);
        // @ts-ignore
        expect(new tcfTypes.TcfCsv().validate(1)).toBe(false);

        expect(new tcfTypes.TcfCsv().validate('')).toBe(true);
        expect(new tcfTypes.TcfCsv().validate('a')).toBe(true);
        expect(new tcfTypes.TcfCsv().validate('a,b')).toBe(true);
    });

    it('GetSeperator', () => {
        expect(typeof new tcfTypes.TcfCsv().getSeperator()).toBe('string');
        expect(new tcfTypes.TcfCsv().getSeperator()).toEqual(',');
    });
});

describe('tcfTypes.TcfBoolean', () => {
    beforeEach(() => {
        // @ts-ignore
        jasmine.addMatchers(customMatchers);
    });

    let localeNode;
    let defaultLocaleContext;
    beforeAll(() => {
        defaultLocaleContext = {
            localeBooleanYesNoShort: null,
            localeBooleanYesNoLong: null,
            localeBooleanTrueFalseShort: null,
            localeBooleanTrueFalseLong: null,
            localeBooleanOnOffShort: null,
            localeBooleanOnOffLong: null,
            localeBooleanMark: null,
        };

        localeNode = document.body.appendChild(
            createElement('div', {
                localeFormatBoolean: 2,
                localeBooleanYesNoShort: 'O,N',
                localeBooleanYesNoLong: '',
            }),
        );
    });

    afterAll(() => {
        localeNode.remove();
        localeNode = null;
    });

    // tcfTypes.TcfAbstractType

    // it('GetClass', () =>
    // {
    //     assertFunction(new tcfTypes.TcfBoolean().getClass());
    //     // @ts-ignore
    //     expect(new tcfTypes.TcfBoolean().getClass()).toEqual(tcfTypes.TcfBoolean);
    // });

    it('GetValue', () => {
        expect(new tcfTypes.TcfBoolean().getValue()).toBeUndefined(); // Inconsistent
        expect(new tcfTypes.TcfBoolean().setValue(null).getValue()).toBeNull();

        expect(new tcfTypes.TcfBoolean().setValue(false).getValue()).toEqual(false);
        expect(new tcfTypes.TcfBoolean().setValue(true).getValue()).toEqual(true);
        expect(new tcfTypes.TcfBoolean().setValue(1).getValue()).toEqual(true);
        expect(new tcfTypes.TcfBoolean().setValue(1).getValue()).toEqual(true);
    });

    it('SetLocaleContext', () => {
        // @ts-ignore
        expect(new tcfTypes.TcfBoolean().setLocaleContext().getLocaleContext()).toEqual(defaultLocaleContext);

        // @ts-ignore
        expect(new tcfTypes.TcfBoolean().setLocaleContext({}).getLocaleContext()).toEqual({});
        // @ts-ignore
        expect(new tcfTypes.TcfBoolean().setLocaleContext({ localeContext: {} }).getLocaleContext()).toEqual({});

        const obj = new tcfTypes.TcfBoolean();
        // @ts-ignore
        expect(obj.setLocaleContext()).toEqual(obj);
        const result = Object.assign(clone(defaultLocaleContext), {
            localeBooleanYesNoShort: 'O,N',
            localeBooleanYesNoLong: null,
        });
        expect(new tcfTypes.TcfBoolean().setLocaleContext(localeNode).getLocaleContext()).toEqual(result);
    });

    it('GetLocaleContext', () => {
        expect(new tcfTypes.TcfBoolean().getLocaleContext()).toEqual(defaultLocaleContext);

        // @ts-ignore
        expect(new tcfTypes.TcfBoolean().getLocaleContext({})).toEqual({});
        // @ts-ignore
        expect(new tcfTypes.TcfBoolean().getLocaleContext({ localeContext: {} })).toEqual({});
    });

    it('SetLocaleKey', () => {
        const obj = new tcfTypes.TcfBoolean();
        expect(obj.setLocaleKey(1)).toEqual(obj);

        expect(new tcfTypes.TcfBoolean().setLocaleKey().getLocaleKey()).toEqual(255);
        expect(new tcfTypes.TcfBoolean().setLocaleKey({ localKey: 0 }).getLocaleKey()).toEqual(255);
        expect(new tcfTypes.TcfBoolean().setLocaleKey({ localKey: 2 }).getLocaleKey()).toEqual(2);
        expect(new tcfTypes.TcfBoolean().setLocaleKey(localeNode).getLocaleKey()).toEqual(2);
    });

    it('GetLocaleKey', () => {
        expect(new tcfTypes.TcfBoolean().getLocaleKey()).toEqual(255);
        expect(new tcfTypes.TcfBoolean().getLocaleKey({ localKey: 0 })).toEqual(255);
        expect(new tcfTypes.TcfBoolean().getLocaleKey({ localKey: 2 })).toEqual(2);
        expect(new tcfTypes.TcfBoolean().getLocaleKey(localeNode)).toEqual(2);
    });

    // tcfTypes.TcfBoolean

    it('Validate', () => {
        // expect(new tcfTypes.TcfBoolean().validate()).toBe(false);
        expect(new tcfTypes.TcfBoolean().validate('')).toBe(false);
        expect(new tcfTypes.TcfBoolean().validate('0')).toBe(false);
        expect(new tcfTypes.TcfBoolean().validate('1')).toBe(false);

        expect(new tcfTypes.TcfBoolean().validate(null)).toBe(true);
        // @ts-ignore
        expect(new tcfTypes.TcfBoolean().validate(0)).toBe(true);
        // @ts-ignore
        expect(new tcfTypes.TcfBoolean().validate(1)).toBe(true);
        // @ts-ignore
        expect(new tcfTypes.TcfBoolean().validate(false)).toBe(true);
        // @ts-ignore
        expect(new tcfTypes.TcfBoolean().validate(true)).toBe(true);
    });

    it('GetLocalizationKey', () => {
        expect(typeof new tcfTypes.TcfBoolean().getLocalizationKey()).toEqual('string');
        expect(new tcfTypes.TcfBoolean().getLocalizationKey()).toEqual('localeFormatBoolean');
    });

    it('SetValue', () => {
        expect(new tcfTypes.TcfBoolean().setValue(undefined).getValue()).toBeNull();
        expect(new tcfTypes.TcfBoolean().setValue(null).getValue()).toBeNull();
        expect(new tcfTypes.TcfBoolean().setValue('a').getValue()).toBeNull();
        expect(new tcfTypes.TcfBoolean().setValue('b').getValue()).toBeNull();

        // Inconsistent
        expect(new tcfTypes.TcfBoolean().setValue('').getValue()).toBeUndefined();
        expect(new tcfTypes.TcfBoolean().setValue('0').getValue()).toBeUndefined();
        expect(new tcfTypes.TcfBoolean().setValue('1').getValue()).toBeUndefined();
        expect(new tcfTypes.TcfBoolean().setValue('1.1').getValue()).toBeUndefined();

        expect(new tcfTypes.TcfBoolean().setValue(false).getValue()).toBe(false);
        expect(new tcfTypes.TcfBoolean().setValue(0).getValue()).toBe(false);

        expect(new tcfTypes.TcfBoolean().setValue(true).getValue()).toBe(true);
        expect(new tcfTypes.TcfBoolean().setValue(1).getValue()).toBe(true);
        expect(new tcfTypes.TcfBoolean().setValue(1.1).getValue()).toBe(true);

        const obj = new tcfTypes.TcfBoolean();
        expect(obj.setValue(null)).toEqual(obj);
    });

    it('ToString', () => {
        expect(new tcfTypes.TcfBoolean().toString()).toEqual('');
        expect(new tcfTypes.TcfBoolean(null).toString()).toEqual('');
        expect(new tcfTypes.TcfBoolean(false).toString()).toEqual('0');
        expect(new tcfTypes.TcfBoolean(true).toString()).toEqual('1');
    });

    it('FromString', () => {
        expect(new tcfTypes.TcfBoolean().fromString('').getValue()).toBe(false);
        expect(new tcfTypes.TcfBoolean().fromString('false').getValue()).toBe(false);
        expect(new tcfTypes.TcfBoolean().fromString('0').getValue()).toBe(false);
        expect(new tcfTypes.TcfBoolean().fromString('a').getValue()).toBe(false);

        expect(new tcfTypes.TcfBoolean().fromString('true').getValue()).toBe(true);
        expect(new tcfTypes.TcfBoolean().fromString('1').getValue()).toBe(true);

        const obj = new tcfTypes.TcfBoolean();
        expect(obj.fromString(null)).toEqual(obj);
    });

    it('GetComparator', () => {
        assertFunction(new tcfTypes.TcfBoolean().getComparator());
        expect(tcfTypes.booleanComparator).toBe(new tcfTypes.TcfBoolean().getComparator());
    });
});

describe('tcfTypes.TcfDouble', () => {
    beforeEach(() => {
        // @ts-ignore
        jasmine.addMatchers(customMatchers);
    });

    it('ToString', () => {
        // Padding whole numbers
        let localeNode = createElement('div', { localeFormatDouble: '#.###' });
        expect(new tcfTypes.TcfDouble(4, localeNode).toString()).toEqual(
            '4.000',
            'format #.###: positive whole number padding',
        );
        expect(new tcfTypes.TcfDouble(4, localeNode).toString()).toEqual(
            '4.000',
            'format #.###: positive whole number padding',
        );
        expect(new tcfTypes.TcfDouble(4, localeNode).toString()).toEqual(
            '4.000',
            'format #.###: positive whole number padding',
        );

        // Padding decimal numbers
        localeNode = createElement('div', { localeFormatDouble: '#.###' });
        expect(new tcfTypes.TcfDouble(4.4, localeNode).toString()).toEqual(
            '4.400',
            'format #.###: positive decimal number padding',
        );
        expect(new tcfTypes.TcfDouble(4.5, localeNode).toString()).toEqual(
            '4.500',
            'format #.###: positive decimal number padding',
        );
        expect(new tcfTypes.TcfDouble(4.6, localeNode).toString()).toEqual(
            '4.600',
            'format #.###: positive decimal number padding',
        );

        // Rounding whole numbers
        localeNode = createElement('div', { localeFormatDouble: '#' });
        expect(new tcfTypes.TcfDouble(4.4, localeNode).toString()).toEqual(
            '4',
            'format #: positive whole number round down',
        );
        expect(new tcfTypes.TcfDouble(4.5, localeNode).toString()).toEqual(
            '5',
            'format #: positive whole number round up',
        );
        expect(new tcfTypes.TcfDouble(4.6, localeNode).toString()).toEqual(
            '5',
            'format #: positive whole number round up',
        );

        expect(new tcfTypes.TcfDouble(-4.4, localeNode).toString()).toEqual(
            '4',
            'format #: negative whole number round up',
        );
        expect(new tcfTypes.TcfDouble(-4.5, localeNode).toString()).toEqual(
            '4',
            'format #: negative whole number round up',
        );
        expect(new tcfTypes.TcfDouble(-4.6, localeNode).toString()).toEqual(
            '5',
            'format #: negative whole number round down',
        );

        localeNode = createElement('div', { localeFormatDouble: '-#' });
        expect(new tcfTypes.TcfDouble(4.4, localeNode).toString()).toEqual(
            '4',
            'format -#: positive whole number round down',
        );
        expect(new tcfTypes.TcfDouble(4.5, localeNode).toString()).toEqual(
            '5',
            'format -#: positive whole number round up',
        );
        expect(new tcfTypes.TcfDouble(4.6, localeNode).toString()).toEqual(
            '5',
            'format -#: positive whole number round up',
        );

        expect(new tcfTypes.TcfDouble(-4.4, localeNode).toString()).toEqual(
            '-4',
            'format -#: negative whole number round up',
        );
        expect(new tcfTypes.TcfDouble(-4.5, localeNode).toString()).toEqual(
            '-4',
            'format -#: negative whole number round up',
        );
        expect(new tcfTypes.TcfDouble(-4.6, localeNode).toString()).toEqual(
            '-5',
            'format -#: negative whole number round down',
        );

        // Rounding decimal numbers
        localeNode = createElement('div', { localeFormatDouble: '#.##' });
        expect(new tcfTypes.TcfDouble(0.004, localeNode).toString()).toEqual(
            '0.00',
            'format #.##: positive decimal number round down',
        );
        expect(new tcfTypes.TcfDouble(0.005, localeNode).toString()).toEqual(
            '0.01',
            'format #.##: positive decimal number round down',
        );
        expect(new tcfTypes.TcfDouble(0.006, localeNode).toString()).toEqual(
            '0.01',
            'format #.##: positive decimal number round down',
        );

        expect(new tcfTypes.TcfDouble(1.004, localeNode).toString()).toEqual(
            '1.00',
            'format #.##: positive decimal number round down',
        );
        expect(new tcfTypes.TcfDouble(1.005, localeNode).toString()).toEqual(
            '1.01',
            'format #.##: positive decimal number round down',
        );
        expect(new tcfTypes.TcfDouble(1.006, localeNode).toString()).toEqual(
            '1.01',
            'format #.##: positive decimal number round down',
        );

        expect(new tcfTypes.TcfDouble(4.994, localeNode).toString()).toEqual(
            '4.99',
            'format #.##: positive decimal number round down',
        );
        expect(new tcfTypes.TcfDouble(4.995, localeNode).toString()).toEqual(
            '5.00',
            'format #.##: positive decimal number round up',
        );
        expect(new tcfTypes.TcfDouble(4.996, localeNode).toString()).toEqual(
            '5.00',
            'format #.##: positive decimal number round up',
        );

        expect(new tcfTypes.TcfDouble(-4.994, localeNode).toString()).toEqual(
            '4.99',
            'format #.##: negative decimal number round up',
        );
        expect(new tcfTypes.TcfDouble(-4.995, localeNode).toString()).toEqual(
            '4.99',
            'format #.##: negative decimal number round up',
        );
        expect(new tcfTypes.TcfDouble(-4.996, localeNode).toString()).toEqual(
            '5.00',
            'format #.##: negative decimal number round down',
        );

        localeNode = createElement('div', { localeFormatDouble: '-#.##' });
        expect(new tcfTypes.TcfDouble(4.994, localeNode).toString()).toEqual(
            '4.99',
            'format -#.##: positive decimal number round up',
        );
        expect(new tcfTypes.TcfDouble(4.995, localeNode).toString()).toEqual(
            '5.00',
            'format -#.##: positive decimal number round down',
        );
        expect(new tcfTypes.TcfDouble(4.996, localeNode).toString()).toEqual(
            '5.00',
            'format -#.##: positive decimal number round down',
        );

        expect(new tcfTypes.TcfDouble(-4.994, localeNode).toString()).toEqual(
            '-4.99',
            'format -#.##: negative round up',
        );
        expect(new tcfTypes.TcfDouble(-4.995, localeNode).toString()).toEqual(
            '-4.99',
            'format -#.##: negative round up',
        );
        expect(new tcfTypes.TcfDouble(-4.996, localeNode).toString()).toEqual(
            '-5.00',
            'format -#.##: negative round down',
        );

        // Trailing decimal place
        localeNode = createElement('div', { localeFormatDouble: '-#.' });
        expect(new tcfTypes.TcfDouble(4.4, localeNode).toString()).toEqual(
            '4.',
            'format -#.: positive decimal number round down',
        );
        expect(new tcfTypes.TcfDouble(4.5, localeNode).toString()).toEqual(
            '5.',
            'format -#.: positive decimal number round down',
        );
        expect(new tcfTypes.TcfDouble(4.6, localeNode).toString()).toEqual(
            '5.',
            'format -#.: positive decimal number round down',
        );
    });
});

describe('tcfTypes.TcfWeekdaysStr', () => {
    beforeEach(() => {
        // @ts-ignore
        jasmine.addMatchers(customMatchers);
    });

    let node;

    const weekdays = new tcfTypes.TcfWeekdaysStr();

    const testValues = [
        {
            value: '1001010',
            binary: '1001010',
            map: { 1: '1--4-6-', 2: 'S--W-F-', 3: '1001010', 0x11: '--3-5-7', 0x12: '--W-F-S' },
        },
        {
            value: '0000000',
            binary: '0000000',
            map: { 1: '-------', 2: '-------', 3: '0000000', 0x11: '-------', 0x12: '-------' },
        },
        {
            value: '1111111',
            binary: '1111111',
            map: { 1: '1234567', 2: 'SMTWTFS', 3: '1111111', 0x11: '1234567', 0x12: 'MTWTFSS' },
        },
    ];

    beforeAll(() => {
        node = document.createElement('DIV');
        document.body.appendChild(node);
        node.setAttribute('localeFormatWeekdays', '1');
        node.setAttribute('localeweekdaysshort', 'S,M,T,W,T,F,S');
    });

    // //Tested in toString and fromString
    // _it('GetValue', () =>
    // {

    // });
    // //Tested in toString and fromString
    // _it('SetValue', () =>
    // {
    // });

    it('ToString', () => {
        for (const i in testValues[0].map) {
            node.setAttribute('localeFormatWeekdays', `${i}`);
            weekdays.initLocale(node);
            for (let j = 0; j < testValues.length; j++) {
                weekdays.setValue(testValues[j].value);
                expect(weekdays.toString()).toEqual(testValues[j].map[i]);
            }
        }
    });

    it('FromString', () => {
        for (const i in testValues[0].map) {
            node.setAttribute('localeFormatWeekdays', `${i}`);
            weekdays.initLocale(node);
            for (let j = 0; j < testValues.length; j++) {
                weekdays.fromString(testValues[j].map[i]);
                expect(weekdays.getValue()).toEqual(testValues[j].value, 'fromString');
            }
        }
    });

    it('GetBinaryValue', () => {
        for (const i in testValues[0].map) {
            node.setAttribute('localeFormatWeekdays', `${i}`);
            weekdays.initLocale(node);
            for (let j = 0; j < testValues.length; j++) {
                weekdays.fromString(testValues[j].map[i]);
                expect(weekdays.getBinaryValue()).toEqual(testValues[j].value, 'fromString');
            }
        }
    });

    it('SetBinaryValue', () => {
        for (const i in testValues[0].map) {
            node.setAttribute('localeFormatWeekdays', `${i}`);
            weekdays.initLocale(node);
            for (let j = 0; j < testValues.length; j++) {
                weekdays.setBinaryValue(testValues[j].binary);
                expect(weekdays.toString()).toEqual(testValues[j].map[i]);
            }
        }
    });

    afterAll(() => {
        node.parentNode.removeChild(node);
    });
});

describe('tcfTypes.TcfWeekdaysInt', () => {
    beforeEach(() => {
        // @ts-ignore
        jasmine.addMatchers(customMatchers);
    });

    let node;

    const weekdays = new tcfTypes.TcfWeekdaysInt();
    const testValues = [
        {
            value: 41,
            binary: '1001010',
            map: { 1: '1--4-6-', 2: 'S--W-F-', 3: '1001010', 0x11: '--3-5-7', 0x12: '--W-F-S' },
        },
        {
            value: 0,
            binary: '0000000',
            map: { 1: '-------', 2: '-------', 3: '0000000', 0x11: '-------', 0x12: '-------' },
        },
        {
            value: 127,
            binary: '1111111',
            map: { 1: '1234567', 2: 'SMTWTFS', 3: '1111111', 0x11: '1234567', 0x12: 'MTWTFSS' },
        },
    ];

    beforeAll(() => {
        node = document.createElement('DIV');
        document.body.appendChild(node);
        node.setAttribute('localeFormatWeekdays', '1');
        node.setAttribute('localeweekdaysshort', 'S,M,T,W,T,F,S');
    });

    // //Tested in toString and fromString
    // _it('GetValue', () =>
    // {

    // });
    // //Tested in toString and fromString
    // _it('SetValue', () =>
    // {
    // });

    it('ToString', () => {
        for (const i in testValues[0].map) {
            node.setAttribute('localeFormatWeekdays', `${i}`);
            weekdays.initLocale(node);
            for (let j = 0; j < testValues.length; j++) {
                weekdays.setValue(testValues[j].value);
                expect(weekdays.toString()).toEqual(testValues[j].map[i]);
            }
        }
    });

    it('FromString', () => {
        for (const i in testValues[0].map) {
            node.setAttribute('localeFormatWeekdays', `${i}`);
            weekdays.initLocale(node);
            for (let j = 0; j < testValues.length; j++) {
                weekdays.fromString(testValues[j].map[i]);
                expect(weekdays.getValue()).toEqual(testValues[j].value, 'fromString');
            }
        }
    });

    it('GetBinaryValue', () => {
        for (const i in testValues[0].map) {
            node.setAttribute('localeFormatWeekdays', `${i}`);
            weekdays.initLocale(node);
            for (let j = 0; j < testValues.length; j++) {
                weekdays.fromString(testValues[j].map[i]);
                expect(weekdays.getBinaryValue()).toEqual(testValues[j].binary, 'fromString');
            }
        }
    });

    it('SetBinaryValue', () => {
        for (const i in testValues[0].map) {
            node.setAttribute('localeFormatWeekdays', `${i}`);
            weekdays.initLocale(node);
            for (let j = 0; j < testValues.length; j++) {
                weekdays.setBinaryValue(testValues[j].binary);
                expect(weekdays.toString()).toEqual(testValues[j].map[i]);
            }
        }
    });

    afterAll(() => {
        node.parentNode.removeChild(node);
    });
});

describe('tcfTypes.TcfTime', () => {
    beforeEach(() => {
        // @ts-ignore
        jasmine.addMatchers(customMatchers);
    });

    let localeNode8;

    // Convenient helper method to return obj after invoking a method
    const invoke = function(obj, method) {
        obj[method](...Array.prototype.slice.call(arguments, 2));
        return obj;
    };

    const runCommonTests = function(method) {
        expect(invoke(new tcfTypes.TcfTime(), method, -1).getValue()).toEqual(null);
        expect(invoke(new tcfTypes.TcfTime(), method, 0).getValue()).toEqual(null);
        expect(invoke(new tcfTypes.TcfTime(), method, 1).getValue()).toEqual(null);
    };

    beforeAll(() => {
        localeNode8 = createElement('div', { localeFormatTime: 8 });
    });

    afterAll(() => {
        localeNode8 = null;
    });

    it('AddSeconds', () => {
        runCommonTests('addSeconds');

        expect(invoke(new tcfTypes.TcfTime(0), 'addSeconds', -1).getValue()).toEqual(-1);
        expect(invoke(new tcfTypes.TcfTime(0), 'addSeconds', 0).getValue()).toEqual(0);
        expect(invoke(new tcfTypes.TcfTime(0), 'addSeconds', 1).getValue()).toEqual(1);

        expect(invoke(new tcfTypes.TcfTime(0), 'addSeconds', 86400).getValue()).toEqual(86400);

        const obj = new tcfTypes.TcfTime(0);
        expect(invoke(obj, 'addSeconds', 1).getValue()).toEqual(1);
        expect(invoke(obj, 'addSeconds', 1).getValue()).toEqual(2);
        expect(invoke(obj, 'addSeconds', 0).getValue()).toEqual(2);
        expect(invoke(obj, 'addSeconds', -1).getValue()).toEqual(1);
        expect(invoke(obj, 'addSeconds', -1).getValue()).toEqual(0);
        expect(invoke(obj, 'addSeconds', 60).getValue()).toEqual(60);
        expect(invoke(obj, 'addSeconds', 60).getValue()).toEqual(120);
    });

    it('AddMinutes', () => {
        runCommonTests('addMinutes');

        expect(invoke(new tcfTypes.TcfTime(0), 'addMinutes', -1).getValue()).toEqual(-60);
        expect(invoke(new tcfTypes.TcfTime(0), 'addMinutes', 0).getValue()).toEqual(0);
        expect(invoke(new tcfTypes.TcfTime(0), 'addMinutes', 1).getValue()).toEqual(60);

        expect(invoke(new tcfTypes.TcfTime(0), 'addMinutes', 1440).getValue()).toEqual(86400);

        const obj = new tcfTypes.TcfTime(0);
        expect(invoke(obj, 'addMinutes', 0).getValue()).toEqual(0);
        expect(invoke(obj, 'addMinutes', 1).getValue()).toEqual(60);
        expect(invoke(obj, 'addMinutes', 1).getValue()).toEqual(120);
        expect(invoke(obj, 'addMinutes', 2).getValue()).toEqual(240);
        expect(invoke(obj, 'addMinutes', 2).getValue()).toEqual(360);
        expect(invoke(obj, 'addMinutes', -6).getValue()).toEqual(0);
    });

    it('AddHours', () => {
        runCommonTests('addHours');

        expect(invoke(new tcfTypes.TcfTime(0), 'addHours', -1).getValue()).toEqual(-3600);
        expect(invoke(new tcfTypes.TcfTime(0), 'addHours', 0).getValue()).toEqual(0);
        expect(invoke(new tcfTypes.TcfTime(0), 'addHours', 1).getValue()).toEqual(3600);

        expect(invoke(new tcfTypes.TcfTime(0), 'addHours', 24).getValue()).toEqual(86400);

        const obj = new tcfTypes.TcfTime(0);
        expect(invoke(obj, 'addHours', 0).getValue()).toEqual(0);
        expect(invoke(obj, 'addHours', 1).getValue()).toEqual(3600);
        expect(invoke(obj, 'addHours', 1).getValue()).toEqual(7200);
        expect(invoke(obj, 'addHours', 2).getValue()).toEqual(14400);
        expect(invoke(obj, 'addHours', 2).getValue()).toEqual(21600);
        expect(invoke(obj, 'addHours', -6).getValue()).toEqual(0);
    });

    it('SubtractSeconds', () => {
        runCommonTests('subtractSeconds');

        expect(invoke(new tcfTypes.TcfTime(0), 'subtractSeconds', -1).getValue()).toEqual(1);
        expect(invoke(new tcfTypes.TcfTime(0), 'subtractSeconds', 0).getValue()).toEqual(0);
        expect(invoke(new tcfTypes.TcfTime(0), 'subtractSeconds', 1).getValue()).toEqual(-1);

        expect(invoke(new tcfTypes.TcfTime(0), 'subtractSeconds', 86400).getValue()).toEqual(-86400);

        const obj = new tcfTypes.TcfTime(0);
        expect(invoke(obj, 'subtractSeconds', 1).getValue()).toEqual(-1);
        expect(invoke(obj, 'subtractSeconds', 1).getValue()).toEqual(-2);
        expect(invoke(obj, 'subtractSeconds', 0).getValue()).toEqual(-2);
        expect(invoke(obj, 'subtractSeconds', -1).getValue()).toEqual(-1);
        expect(invoke(obj, 'subtractSeconds', -1).getValue()).toEqual(-0);
        expect(invoke(obj, 'subtractSeconds', 60).getValue()).toEqual(-60);
        expect(invoke(obj, 'subtractSeconds', 60).getValue()).toEqual(-120);
    });

    it('SubtractMinutes', () => {
        runCommonTests('subtractMinutes');

        expect(invoke(new tcfTypes.TcfTime(0), 'subtractMinutes', -1).getValue()).toEqual(60);
        expect(invoke(new tcfTypes.TcfTime(0), 'subtractMinutes', 0).getValue()).toEqual(0);
        expect(invoke(new tcfTypes.TcfTime(0), 'subtractMinutes', 1).getValue()).toEqual(-60);

        expect(invoke(new tcfTypes.TcfTime(0), 'subtractMinutes', 1440).getValue()).toEqual(-86400);

        const obj = new tcfTypes.TcfTime(0);
        expect(invoke(obj, 'subtractMinutes', 0).getValue()).toEqual(0);
        expect(invoke(obj, 'subtractMinutes', 1).getValue()).toEqual(-60);
        expect(invoke(obj, 'subtractMinutes', 1).getValue()).toEqual(-120);
        expect(invoke(obj, 'subtractMinutes', 2).getValue()).toEqual(-240);
        expect(invoke(obj, 'subtractMinutes', 2).getValue()).toEqual(-360);
        expect(invoke(obj, 'subtractMinutes', -6).getValue()).toEqual(0);
    });

    it('SubtractHours', () => {
        runCommonTests('subtractHours');

        expect(invoke(new tcfTypes.TcfTime(0), 'subtractHours', -1).getValue()).toEqual(3600);
        expect(invoke(new tcfTypes.TcfTime(0), 'subtractHours', 0).getValue()).toEqual(0);
        expect(invoke(new tcfTypes.TcfTime(0), 'subtractHours', 1).getValue()).toEqual(-3600);

        expect(invoke(new tcfTypes.TcfTime(0), 'subtractHours', 24).getValue()).toEqual(-86400);

        const obj = new tcfTypes.TcfTime(0);
        expect(invoke(obj, 'subtractHours', 0).getValue()).toEqual(0);
        expect(invoke(obj, 'subtractHours', 1).getValue()).toEqual(-3600);
        expect(invoke(obj, 'subtractHours', 1).getValue()).toEqual(-7200);
        expect(invoke(obj, 'subtractHours', 2).getValue()).toEqual(-14400);
        expect(invoke(obj, 'subtractHours', 2).getValue()).toEqual(-21600);
        expect(invoke(obj, 'subtractHours', -6).getValue()).toEqual(0);
    });

    it('GetHours', () => {
        expect(new tcfTypes.TcfTime(3599).getHours()).toEqual(0);
        expect(new tcfTypes.TcfTime(3600).getHours()).toEqual(1);
        expect(new tcfTypes.TcfTime(3601).getHours()).toEqual(1);

        expect(new tcfTypes.TcfTime(7199).getHours()).toEqual(1);
        expect(new tcfTypes.TcfTime(7200).getHours()).toEqual(2);
        expect(new tcfTypes.TcfTime(7201).getHours()).toEqual(2);
    });

    it('GetMinutes', () => {
        expect(new tcfTypes.TcfTime(59).getMinutes()).toEqual(0);
        expect(new tcfTypes.TcfTime(60).getMinutes()).toEqual(1);
        expect(new tcfTypes.TcfTime(61).getMinutes()).toEqual(1);

        expect(new tcfTypes.TcfTime(119).getMinutes()).toEqual(1);
        expect(new tcfTypes.TcfTime(120).getMinutes()).toEqual(2);
        expect(new tcfTypes.TcfTime(121).getMinutes()).toEqual(2);

        expect(new tcfTypes.TcfTime(3659).getMinutes()).toEqual(0);
        expect(new tcfTypes.TcfTime(3660).getMinutes()).toEqual(1);
        expect(new tcfTypes.TcfTime(3661).getMinutes()).toEqual(1);

        expect(new tcfTypes.TcfTime(3719).getMinutes()).toEqual(1);
        expect(new tcfTypes.TcfTime(3720).getMinutes()).toEqual(2);
        expect(new tcfTypes.TcfTime(3721).getMinutes()).toEqual(2);
    });

    it('GetSeconds', () => {
        expect(new tcfTypes.TcfTime(0).getSeconds()).toEqual(0);
        expect(new tcfTypes.TcfTime(1).getSeconds()).toEqual(1);

        expect(new tcfTypes.TcfTime(59).getSeconds()).toEqual(59);
        expect(new tcfTypes.TcfTime(60).getSeconds()).toEqual(0);
        expect(new tcfTypes.TcfTime(61).getSeconds()).toEqual(1);

        expect(new tcfTypes.TcfTime(119).getSeconds()).toEqual(59);
        expect(new tcfTypes.TcfTime(120).getSeconds()).toEqual(0);
        expect(new tcfTypes.TcfTime(121).getSeconds()).toEqual(1);

        expect(new tcfTypes.TcfTime(3599).getSeconds()).toEqual(59);
        expect(new tcfTypes.TcfTime(3600).getSeconds()).toEqual(0);
        expect(new tcfTypes.TcfTime(3601).getSeconds()).toEqual(1);

        expect(new tcfTypes.TcfTime(3719).getSeconds()).toEqual(59);
        expect(new tcfTypes.TcfTime(3720).getSeconds()).toEqual(0);
        expect(new tcfTypes.TcfTime(3721).getSeconds()).toEqual(1);
    });

    it('Validate', () => {
        // @ts-ignore
        expect(new tcfTypes.TcfTime().validate()).toBe(true); // Inconsistent
        expect(new tcfTypes.TcfTime().validate(false)).toBe(false);
        expect(new tcfTypes.TcfTime().validate(true)).toBe(false);
        expect(new tcfTypes.TcfTime().validate(0.1)).toBe(false);
        expect(new tcfTypes.TcfTime().validate(1.1)).toBe(false);

        expect(new tcfTypes.TcfTime().validate(null)).toBe(true);
        expect(new tcfTypes.TcfTime().validate(0)).toBe(true);
        expect(new tcfTypes.TcfTime().validate(1)).toBe(true);
        expect(new tcfTypes.TcfTime().validate('')).toBe(true);
        expect(new tcfTypes.TcfTime().validate('0')).toBe(true);
        expect(new tcfTypes.TcfTime().validate('1')).toBe(true);
    });

    it('SetValue', () => {
        expect(
            new tcfTypes.TcfTime(null, localeNode8).setValue(new Date(Date.UTC(2001, 0, 1, 12, 30, 30))).toString(),
        ).toEqual('12:30');
        expect(
            new tcfTypes.TcfTime(null, localeNode8).setValue(new Date(Date.UTC(2001, 0, 1, 13, 30, 30))).toString(),
        ).toEqual('13:30');

        const localeNode = createElement('div', { localeformatdatetime: 9 });
        let datetime = new tcfTypes.TcfDateTime(13085542800000, localeNode);
        expect(new tcfTypes.TcfTime(datetime, localeNode).getValue()).toEqual(3600, '09/01/2015 01:00:00');
        datetime = new tcfTypes.TcfDateTime(null, localeNode).fromString('09/01/2015 01:00:00');
        expect(new tcfTypes.TcfTime(datetime, localeNode).getValue()).toEqual(3600, '09/01/2015 01:00:00');
        datetime = new tcfTypes.TcfDateTime(new Date('2019 12 30 1:01'));
        expect(new tcfTypes.TcfTime(null, localeNode8).setValue(datetime).toString()).toEqual('01:01');

        expect(new tcfTypes.TcfTime().setValue(null).getValue()).toBeNull();
        // @ts-ignore
        expect(new tcfTypes.TcfTime().setValue('a').getValue()).toBeNull();

        // @ts-ignore
        expect(new tcfTypes.TcfTime(null, localeNode8).setValue('').toString()).toEqual('');
        // @ts-ignore
        expect(new tcfTypes.TcfTime(null, localeNode8).setValue('0').toString()).toEqual('');
        // @ts-ignore
        expect(new tcfTypes.TcfTime(null, localeNode8).setValue('59').toString()).toEqual('');
        // @ts-ignore
        expect(new tcfTypes.TcfTime(null, localeNode8).setValue('60').toString()).toEqual('');
        // @ts-ignore
        expect(new tcfTypes.TcfTime(null, localeNode8).setValue('61').toString()).toEqual('');

        expect(new tcfTypes.TcfTime(null, localeNode8).setValue(0).toString()).toEqual('00:00');
        expect(new tcfTypes.TcfTime(null, localeNode8).setValue(59).toString()).toEqual('00:00');
        expect(new tcfTypes.TcfTime(null, localeNode8).setValue(60).toString()).toEqual('00:01');
        expect(new tcfTypes.TcfTime(null, localeNode8).setValue(61).toString()).toEqual('00:01');
        expect(new tcfTypes.TcfTime(null, localeNode8).setValue(3599).toString()).toEqual('00:59');
        expect(new tcfTypes.TcfTime(null, localeNode8).setValue(3600).toString()).toEqual('01:00');
        expect(new tcfTypes.TcfTime(null, localeNode8).setValue(3601).toString()).toEqual('01:00');
        expect(new tcfTypes.TcfTime(null, localeNode8).setValue(3659).toString()).toEqual('01:00');
        expect(new tcfTypes.TcfTime(null, localeNode8).setValue(3660).toString()).toEqual('01:01');
        expect(new tcfTypes.TcfTime(null, localeNode8).setValue(3661).toString()).toEqual('01:01');
    });

    it('ToString', () => {
        expect(new tcfTypes.TcfTime(-1, createElement('div', { localeFormatTime: 1 })).toString()).toEqual('');
        expect(new tcfTypes.TcfTime(-1, createElement('div', { localeFormatTime: 2 })).toString()).toEqual('');
        expect(new tcfTypes.TcfTime(-1, createElement('div', { localeFormatTime: 3 })).toString()).toEqual('');
        expect(new tcfTypes.TcfTime(-1, createElement('div', { localeFormatTime: 4 })).toString()).toEqual('');
        expect(new tcfTypes.TcfTime(-1, createElement('div', { localeFormatTime: 5 })).toString()).toEqual('');
        expect(new tcfTypes.TcfTime(-1, createElement('div', { localeFormatTime: 6 })).toString()).toEqual('');
        expect(new tcfTypes.TcfTime(-1, createElement('div', { localeFormatTime: 7 })).toString()).toEqual('');
        expect(new tcfTypes.TcfTime(-1, createElement('div', { localeFormatTime: 8 })).toString()).toEqual('');
        expect(new tcfTypes.TcfTime(-1, createElement('div', { localeFormatTime: 9 })).toString()).toEqual('');
        expect(new tcfTypes.TcfTime(-1, createElement('div', { localeFormatTime: 10 })).toString()).toEqual('');
        expect(new tcfTypes.TcfTime(-1, createElement('div', { localeFormatTime: 11 })).toString()).toEqual('');
        expect(new tcfTypes.TcfTime(-1, createElement('div', { localeFormatTime: 255 })).toString()).toEqual('');

        expect(new tcfTypes.TcfTime(-2, createElement('div', { localeFormatTime: 1 })).toString()).toEqual('00:00:02');
        expect(new tcfTypes.TcfTime(-3, createElement('div', { localeFormatTime: 1 })).toString()).toEqual('00:00:03');
        expect(new tcfTypes.TcfTime(-4, createElement('div', { localeFormatTime: 1 })).toString()).toEqual('00:00:04');

        expect(new tcfTypes.TcfTime(7350, createElement('div', { localeFormatTime: 1 })).toString()).toEqual(
            '02:02:30',
        );
        expect(new tcfTypes.TcfTime(7350, createElement('div', { localeFormatTime: 2 })).toString()).toEqual('0202');
        expect(new tcfTypes.TcfTime(7350, createElement('div', { localeFormatTime: 3 })).toString()).toEqual('2:02a');
        expect(new tcfTypes.TcfTime(7350, createElement('div', { localeFormatTime: 4 })).toString()).toEqual(
            '2:02:30a',
        );
        expect(new tcfTypes.TcfTime(7350, createElement('div', { localeFormatTime: 5 })).toString()).toEqual('202a');
        expect(new tcfTypes.TcfTime(7350, createElement('div', { localeFormatTime: 6 })).toString()).toEqual('02:02+');
        expect(new tcfTypes.TcfTime(7350, createElement('div', { localeFormatTime: 7 })).toString()).toEqual('2:02a+');
        expect(new tcfTypes.TcfTime(7350, createElement('div', { localeFormatTime: 8 })).toString()).toEqual('02:02');
        expect(new tcfTypes.TcfTime(7350, createElement('div', { localeFormatTime: 9 })).toString()).toEqual('122');
        expect(new tcfTypes.TcfTime(7350, createElement('div', { localeFormatTime: 10 })).toString()).toEqual('7350');
        expect(new tcfTypes.TcfTime(7350, createElement('div', { localeFormatTime: 11 })).toString()).toEqual('2');
        expect(new tcfTypes.TcfTime(7350, createElement('div', { localeFormatTime: 255 })).toString()).toEqual(
            'T020230',
        );
    });

    it('FromString', () => {
        expect(
            new tcfTypes.TcfTime(null, createElement('div', { localeFormatTime: 1 })).fromString('').getValue(),
        ).toBeNull();
        expect(
            new tcfTypes.TcfTime(null, createElement('div', { localeFormatTime: 2 })).fromString('').getValue(),
        ).toBeNull();
        expect(
            new tcfTypes.TcfTime(null, createElement('div', { localeFormatTime: 3 })).fromString('').getValue(),
        ).toBeNull();
        expect(
            new tcfTypes.TcfTime(null, createElement('div', { localeFormatTime: 4 })).fromString('').getValue(),
        ).toBeNull();
        expect(
            new tcfTypes.TcfTime(null, createElement('div', { localeFormatTime: 5 })).fromString('').getValue(),
        ).toBeNull();
        expect(
            new tcfTypes.TcfTime(null, createElement('div', { localeFormatTime: 6 })).fromString('').getValue(),
        ).toBeNull();
        expect(
            new tcfTypes.TcfTime(null, createElement('div', { localeFormatTime: 7 })).fromString('').getValue(),
        ).toBeNull();
        expect(
            new tcfTypes.TcfTime(null, createElement('div', { localeFormatTime: 8 })).fromString('').getValue(),
        ).toBeNull();
        expect(
            new tcfTypes.TcfTime(null, createElement('div', { localeFormatTime: 9 })).fromString('').getValue(),
        ).toBeNull();
        expect(
            new tcfTypes.TcfTime(null, createElement('div', { localeFormatTime: 10 })).fromString('').getValue(),
        ).toBeNull();
        expect(
            new tcfTypes.TcfTime(null, createElement('div', { localeFormatTime: 11 })).fromString('').getValue(),
        ).toBeNull();
        expect(
            new tcfTypes.TcfTime(null, createElement('div', { localeFormatTime: 255 })).fromString('').getValue(),
        ).toBeNull();

        expect(
            new tcfTypes.TcfTime(null, createElement('div', { localeFormatTime: 1 })).fromString('02:02:30').getValue(),
        ).toEqual(7350);
        expect(
            new tcfTypes.TcfTime(null, createElement('div', { localeFormatTime: 2 })).fromString('0202').getValue(),
        ).toEqual(7320);
        expect(
            new tcfTypes.TcfTime(null, createElement('div', { localeFormatTime: 3 })).fromString('2:02a').getValue(),
        ).toEqual(7320);
        expect(
            new tcfTypes.TcfTime(null, createElement('div', { localeFormatTime: 4 })).fromString('2:02:30a').getValue(),
        ).toEqual(7350);
        expect(
            new tcfTypes.TcfTime(null, createElement('div', { localeFormatTime: 5 })).fromString('202a').getValue(),
        ).toEqual(7320);
        expect(
            new tcfTypes.TcfTime(null, createElement('div', { localeFormatTime: 6 })).fromString('02:02+').getValue(),
        ).toEqual(7320);
        expect(
            new tcfTypes.TcfTime(null, createElement('div', { localeFormatTime: 7 })).fromString('2:02a+').getValue(),
        ).toEqual(7320);
        expect(
            new tcfTypes.TcfTime(null, createElement('div', { localeFormatTime: 8 })).fromString('02:02').getValue(),
        ).toEqual(7320);
        expect(
            new tcfTypes.TcfTime(null, createElement('div', { localeFormatTime: 9 })).fromString('122').getValue(),
        ).toEqual(7320);
        expect(
            new tcfTypes.TcfTime(null, createElement('div', { localeFormatTime: 10 })).fromString('7350').getValue(),
        ).toEqual(7350);
        expect(
            new tcfTypes.TcfTime(null, createElement('div', { localeFormatTime: 11 })).fromString('2').getValue(),
        ).toEqual(7200);
        // This was added as a test but is nt supported at the moment.
        // expect(new tcfTypes.TcfTime(null, createElement('div', { localeFormatTime: 255 })).fromString('T020230').getValue()).toEqual(7350);
    });

    it('FromDate', () => {
        expect(invoke(new tcfTypes.TcfTime(), 'fromDate', new Date(Date.UTC(2001, 0, 1, 2, 2, 30))).getValue()).toEqual(
            7350,
        );
    });

    it('GetLocalizationKey', () => {
        expect(typeof new tcfTypes.TcfTime().getLocalizationKey()).toEqual('string');
        expect(new tcfTypes.TcfTime().getLocalizationKey()).toEqual('localeFormatTime');
    });
});

describe('tcfTypes.TcfDateTime', () => {
    beforeEach(() => {
        // @ts-ignore
        jasmine.addMatchers(customMatchers);
    });

    it('SetValue', () => {
        const test1 = new Date('2019 12 30 2:00');
        const datetime = new tcfTypes.TcfDateTime();
        datetime.setValue(test1);
        expect(datetime.toDate().getTime()).toEqual(test1.getTime());
    });

    it('FromString', () => {
        // let localeNode = createElement('div', { localeformatdatetime: 1 });
        // let date = new Date('2015/03/08, 07:46:00');
        // let coreDateTime = new tcfTypes.TcfDateTime(13085542800000, localeNode).fromString('2015/03/08, 07:46:00');
        // let coreDate = coreDateTime.toDate();
        // expect(07:46:00', date.getTime(), coreDate.getTime()).toEqual('2015/03/08);
    });

    it('SetTime', () => {
        const tests = [{ datetime: '2011-12-15 03:00', newTime: 7200, expected: '2011/12/15, 02:00:00:000' }];

        const localeNode = createElement('div', { localeformatdatetime: 1 });

        for (let i = 0, iLen = tests.length; i < iLen; i++) {
            const test = tests[i];
            const time = new tcfTypes.TcfTime(test.newTime);
            const datetime = new tcfTypes.TcfDateTime(null, localeNode).fromString(test.datetime);
            datetime.setTime(time);
            expect(datetime.toString()).toEqual(test.expected, `datetime: ${test.datetime}; setTime: ${test.newTime}`);
        }
    });

    it('SetDate', () => {});

    it('GetTime', () => {
        const localeNode = createElement('div', { localeformatdatetime: 1 });
        const datetime = new tcfTypes.TcfDateTime(13085542800000, localeNode).fromString('2015/03/08, 07:46:00');
        const time = datetime.getTime();
        expect(time.getValue()).toEqual(27960);
    });

    it('GetDate', () => {
        const localeNode = createElement('div', { localeformatdatetime: 1 });
        const datetime = new tcfTypes.TcfDateTime(13085542800000, localeNode).fromString('2015/03/08, 01:46:00');
        const date = datetime.getDate();
        expect(date.getValue()).toEqual(20150308);
    });

    it('ToDate', () => {});
});

describe('tcfTypes.TcfTimeSpan', () => {
    beforeEach(() => {
        // @ts-ignore
        jasmine.addMatchers(customMatchers);
    });

    let node;
    const timespan = new tcfTypes.TcfTimeSpan();
    // The Server values where compiled using http://localhost:8081/App/core/ui/test/process/types/formats
    const testValues = [
        {
            value: 0,
            map: {
                1: '0',
                2: '0',
                3: ':00',
                4: '0s',
                5: '0',
                6: ':00',
                7: '0.00',
                8: 'PT0H0M0S',
                9: '0h00:00:000',
                10: '0ms',
                11: '0',
                12: '0min',
                255: '0',
            },
        },
        {
            value: null,
            map: { 1: '', 2: '', 3: '', 4: '', 5: '', 6: '', 7: '', 8: '', 9: '', 10: '', 11: '', 12: '', 255: '' },
        },
        {
            value: 1,
            map: {
                1: '0',
                2: '0',
                3: ':01',
                4: '1s',
                5: '0+',
                6: ':01',
                7: '0.00',
                8: 'PT0H0M1S',
                9: '0h00:01:000',
                10: '1000ms',
                11: '00:01',
                12: '0min',
                255: '1',
            },
        },
        {
            value: 59,
            map: {
                1: '0',
                2: '0',
                3: ':59',
                4: '59s',
                5: '0+',
                6: ':59',
                7: '0.02',
                8: 'PT0H0M59S',
                9: '0h00:59:000',
                10: '59000ms',
                11: '00:59',
                12: '0min',
                255: '59',
            },
        },
        {
            value: 60,
            map: {
                1: '1',
                2: '1',
                3: '1:00',
                4: '60s',
                5: '1 ',
                6: '1:00',
                7: '0.02',
                8: 'PT0H1M0S',
                9: '0h01:00:000',
                10: '60000ms',
                11: '01:00',
                12: '1min',
                255: '60',
            },
        },
        {
            value: 61,
            map: {
                1: '1',
                2: '1',
                3: '1:01',
                4: '61s',
                5: '1+',
                6: '1:01',
                7: '0.02',
                8: 'PT0H1M1S',
                9: '0h01:01:000',
                10: '61000ms',
                11: '01:01',
                12: '1min',
                255: '61',
            },
        },
        {
            value: 119,
            map: {
                1: '1',
                2: '1',
                3: '1:59',
                4: '119s',
                5: '1+',
                6: '1:59',
                7: '0.03',
                8: 'PT0H1M59S',
                9: '0h01:59:000',
                10: '119000ms',
                11: '01:59',
                12: '1min',
                255: '119',
            },
        },
        {
            value: 120,
            map: {
                1: '2',
                2: '2',
                3: '2:00',
                4: '120s',
                5: '2 ',
                6: '2:00',
                7: '0.03',
                8: 'PT0H2M0S',
                9: '0h02:00:000',
                10: '120000ms',
                11: '02:00',
                12: '2min',
                255: '120',
            },
        },
        {
            value: 599,
            map: {
                1: '9',
                2: '9',
                3: '9:59',
                4: '599s',
                5: '9+',
                6: '9:59',
                7: '0.17',
                8: 'PT0H9M59S',
                9: '0h09:59:000',
                10: '599000ms',
                11: '09:59',
                12: '9min',
                255: '599',
            },
        },
        {
            value: 600,
            map: {
                1: '10',
                2: '10',
                3: '10:00',
                4: '600s',
                5: '10 ',
                6: '10:00',
                7: '0.17',
                8: 'PT0H10M0S',
                9: '0h10:00:000',
                10: '600000ms',
                11: '10:00',
                12: '10min',
                255: '600',
            },
        },
        {
            value: 3599,
            map: {
                1: '59',
                2: '59',
                3: '59:59',
                4: '3599s',
                5: '59+',
                6: '59:59',
                7: '1.00',
                8: 'PT0H59M59S',
                9: '0h59:59:000',
                10: '3599000ms',
                11: '59:59',
                12: '59min',
                255: '3599',
            },
        },
        {
            value: 3600,
            map: {
                1: '1h00',
                2: '60',
                3: '60:00',
                4: '3600s',
                5: '60 ',
                6: '1h00:00',
                7: '1.00',
                8: 'PT1H0M0S',
                9: '1h00:00:000',
                10: '3600000ms',
                11: '1h',
                12: '1h 00min',
                255: '3600',
            },
        },
        {
            value: 40000,
            map: {
                1: '11h06',
                2: '666',
                3: '666:40',
                4: '40000s',
                5: '666+',
                6: '11h06:40',
                7: '11.11',
                8: 'PT11H6M40S',
                9: '11h06:40:000',
                10: '40000000ms',
                11: '11h06:40',
                12: '11h 06min',
                255: '40000',
            },
        },
        {
            value: 400000,
            map: {
                1: '111h06',
                2: '6666',
                3: '6666:40',
                4: '400000s',
                5: '6666+',
                6: '111h06:40',
                7: '111.11',
                8: 'PT111H6M40S',
                9: '111h06:40:000',
                10: '400000000ms',
                11: '4d15h06:40',
                12: '111h 06min',
                255: '400000',
            },
        },
        {
            value: -400000,
            map: {
                1: '-111h06',
                2: '-6666',
                3: '-6666:40',
                4: '-400000s',
                5: '-6666+',
                6: '-111h06:40',
                7: '-111.11',
                8: '-PT111H6M40S',
                9: '-111h06:40:000',
                10: '-400000000ms',
                11: '-4d15h06:40',
                12: '-111h 06min',
                255: '-400000',
            },
        },
        {
            value: -40000,
            map: {
                1: '-11h06',
                2: '-666',
                3: '-666:40',
                4: '-40000s',
                5: '-666+',
                6: '-11h06:40',
                7: '-11.11',
                8: '-PT11H6M40S',
                9: '-11h06:40:000',
                10: '-40000000ms',
                11: '-11h06:40',
                12: '-11h 06min',
                255: '-40000',
            },
        },
        {
            value: -3600,
            map: {
                1: '-1h00',
                2: '-60',
                3: '-60:00',
                4: '-3600s',
                5: '-60 ',
                6: '-1h00:00',
                7: '-1.00',
                8: '-PT1H0M0S',
                9: '-1h00:00:000',
                10: '-3600000ms',
                11: '-1h',
                12: '-1h 00min',
                255: '-3600',
            },
        },
        {
            value: -3599,
            map: {
                1: '-59',
                2: '-59',
                3: '-59:59',
                4: '-3599s',
                5: '-59+',
                6: '-59:59',
                7: '-1.00',
                8: '-PT0H59M59S',
                9: '-0h59:59:000',
                10: '-3599000ms',
                11: '-59:59',
                12: '-59min',
                255: '-3599',
            },
        },
        {
            value: -600,
            map: {
                1: '-10',
                2: '-10',
                3: '-10:00',
                4: '-600s',
                5: '-10 ',
                6: '-10:00',
                7: '-0.17',
                8: '-PT0H10M0S',
                9: '-0h10:00:000',
                10: '-600000ms',
                11: '-10:00',
                12: '-10min',
                255: '-600',
            },
        },
        {
            value: -599,
            map: {
                1: '-9',
                2: '-9',
                3: '-9:59',
                4: '-599s',
                5: '-9+',
                6: '-9:59',
                7: '-0.17',
                8: '-PT0H9M59S',
                9: '-0h09:59:000',
                10: '-599000ms',
                11: '-09:59',
                12: '-9min',
                255: '-599',
            },
        },
        {
            value: -120,
            map: {
                1: '-2',
                2: '-2',
                3: '-2:00',
                4: '-120s',
                5: '-2 ',
                6: '-2:00',
                7: '-0.03',
                8: '-PT0H2M0S',
                9: '-0h02:00:000',
                10: '-120000ms',
                11: '-02:00',
                12: '-2min',
                255: '-120',
            },
        },
        {
            value: -119,
            map: {
                1: '-1',
                2: '-1',
                3: '-1:59',
                4: '-119s',
                5: '-1+',
                6: '-1:59',
                7: '-0.03',
                8: '-PT0H1M59S',
                9: '-0h01:59:000',
                10: '-119000ms',
                11: '-01:59',
                12: '-1min',
                255: '-119',
            },
        },
        {
            value: -61,
            map: {
                1: '-1',
                2: '-1',
                3: '-1:01',
                4: '-61s',
                5: '-1+',
                6: '-1:01',
                7: '-0.02',
                8: '-PT0H1M1S',
                9: '-0h01:01:000',
                10: '-61000ms',
                11: '-01:01',
                12: '-1min',
                255: '-61',
            },
        },
        {
            value: -60,
            map: {
                1: '-1',
                2: '-1',
                3: '-1:00',
                4: '-60s',
                5: '-1 ',
                6: '-1:00',
                7: '-0.02',
                8: '-PT0H1M0S',
                9: '-0h01:00:000',
                10: '-60000ms',
                11: '-01:00',
                12: '-1min',
                255: '-60',
            },
        },
        {
            value: -59,
            map: {
                1: '0',
                2: '0',
                3: '-:59',
                4: '-59s',
                5: '-0+',
                6: '-:59',
                7: '-0.02',
                8: '-PT0H0M59S',
                9: '-0h00:59:000',
                10: '-59000ms',
                11: '-00:59',
                12: '0min',
                255: '-59',
            },
        },
        {
            value: -1,
            map: {
                1: '0',
                2: '0',
                3: '-:01',
                4: '-1s',
                5: '-0+',
                6: '-:01',
                7: '0.00',
                8: '-PT0H0M1S',
                9: '-0h00:01:000',
                10: '-1000ms',
                11: '-00:01',
                12: '0min',
                255: '-1',
            },
        },
    ];

    beforeAll(() => {
        node = document.createElement('DIV');
        document.body.appendChild(node);
    });

    afterAll(() => {
        node.parentNode.removeChild(node);
    });

    it('ToString', () => {
        for (let i = 0, iLen = testValues.length; i < iLen; i++) {
            const v = testValues[i].value;
            const map = testValues[i].map;
            for (const format in map) {
                node.setAttribute('localeFormatTimespan', `${format}`);
                timespan.initLocale(node);
                timespan.setValue(v);
                expect(timespan.toString().trim()).toEqual(map[format].trim(), `value: ${v} formated as: ${format}`);
            }
        }

        expect(new tcfTypes.TcfTimeSpan().setValue(-2147483647).toString()).toEqual('');
    });
});

describe('tcfTypes.TcfDate', () => {
    beforeEach(() => {
        // @ts-ignore
        jasmine.addMatchers(customMatchers);
    });

    let node;

    const date = new tcfTypes.TcfDate();
    const testValues = [
        {
            value: 19251223,
            toStr: {
                1: '25-12-23', // yy-MM-dd
                2: '12-23-1925', // MM-dd-yyyy
                3: '12-23-25', // MM-dd-yy
                4: '23-12-1925', // dd-MM-yyyy
                5: '23-12-25', // dd-MM-yy
                6: 'Dec 23, 1925', // MMM dd, yyyy
                7: 'Dec 23, 25', // MMM dd, yy
                8: '1925-12-23', // yyyy-MM-dd
                255: '19251223', // yyyyMMdd
            },
            fromStr: {
                1: ['25-12-23', '251223', '19251223'], // yMd
                2: ['12-23-1925', '122325', '12231925'], // Mdy
                3: ['12-23-25', '122325', '12231925'], // Mdy
                4: ['23-12-1925', '231225', '23121925'], // dMy
                5: ['23-12-25', '231225', '23121925'], // dMy
                // 'Dec 23, 25' creates a value of NULL. Jira DEVCORE3-3967
                // 6: ['Dec 23, 1925', '122325',    '12231925'], // Mdy
                6: ['122325', '12231925'], // Mdy
                // 7: ['Dec 23, 25',    '122325',    '12231925'], // Mdy
                7: ['122325', '12231925'], // Mdy
                8: ['1925-12-23', '251223', '19251223'], // yMd
                255: ['19251223'], // yMd
            },
        },
        {
            value: 20150120,
            toStr: {
                1: '15-01-20', // yy-MM-dd
                2: '01-20-2015', // MM-dd-yyyy
                3: '01-20-15', // MM-dd-yy
                4: '20-01-2015', // dd-MM-yyyy
                5: '20-01-15', // dd-MM-yy
                6: 'Jan 20, 2015', // MMM dd, yyyy,
                7: 'Jan 20, 15', // MMM dd, yy
                8: '2015-01-20', // yyyy-MM-dd
                255: '20150120', // yyyyMMdd
            },
            fromStr: {
                1: ['15-01-20', '150120', '20150120'], // yMd
                2: ['01-20-2015', '012015', '01202015'], // Mdy
                3: ['01-20-15', '012015', '01202015'], // Mdy
                4: ['20-01-2015', '200115', '20012015'], // dMy
                5: ['20-01-15', '200115', '20012015'], // dMy
                // 'Dec 23, 25' creates a value of NULL. Jira DEVCORE3-3967
                // 6: ['Jan 20, 2015', '012015', '01202015'], // Mdy
                6: ['012015', '01202015'], // Mdy
                // 7: ['Jan 20, 10',    '012015', '01202015'], // Mdy
                7: ['012015', '01202015'], // Mdy
                8: ['2015-01-20', '150120', '20150120'], // yMd
                255: ['20150120'], // yMd
            },
        },
    ];

    beforeAll(() => {
        node = document.createElement('DIV');
        document.body.appendChild(node);
        node.setAttribute('localeFormatDate', '1');
        node.setAttribute('localeFormatDateYYPivotYear', '1920');
        node.setAttribute('localeMonthsMedium', 'Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec');
    });

    // //Tested in toString and fromString
    // _it('GetValue', () =>
    // {

    // });
    // //Tested in toString and fromString
    // _it('SetValue', () =>
    // {
    // });

    it('ToString', () => {
        for (const format in testValues[0].toStr) {
            node.setAttribute('localeFormatDate', `${format}`);
            date.initLocale(node);
            for (let j = 0; j < testValues.length; j++) {
                date.setValue(testValues[j].value);
                expect(date.toString()).toEqual(
                    testValues[j].toStr[format],
                    `Value is: ${testValues[j].value}; format is: ${format}`,
                );
            }
        }
    });

    it('FromString', () => {
        for (const format in testValues[0].fromStr) {
            node.setAttribute('localeFormatDate', `${format}`);
            date.initLocale(node);
            for (let j = 0; j < testValues.length; j++) {
                const test = testValues[j];
                for (let k = 0, kLen = test.fromStr[format].length; k < kLen; k++) {
                    date.fromString(test.fromStr[format][k]);
                    expect(date.getValue()).toEqual(
                        test.value,
                        `Value is: ${testValues[j].value}; format is: ${format}`,
                    );
                }
            }
        }
    });

    afterAll(() => {
        node.parentNode.removeChild(node);
    });
});

describe('tcfTypes.TcfDistance', () => {
    beforeEach(() => {
        // @ts-ignore
        jasmine.addMatchers(customMatchers);
    });

    it('ToString', () => {
        let localeNode = createElement('div', { localeFormatDistance: '2' });
        expect(new tcfTypes.TcfDistance(null, localeNode).fromString('0.94mi').toString()).toEqual(
            '0.9mi',
            'format 2: positive whole number; padding',
        );
        expect(new tcfTypes.TcfDistance(null, localeNode).fromString('0.95mi').toString()).toEqual(
            '1.0mi',
            'format 2: positive whole number; padding',
        );
        expect(new tcfTypes.TcfDistance(null, localeNode).fromString('0.96mi').toString()).toEqual(
            '1.0mi',
            'format 2: positive whole number; padding',
        );

        localeNode = createElement('div', { localeFormatDistance: '2' });
        expect(new tcfTypes.TcfDistance(null, localeNode).fromString('1.94mi').toString()).toEqual(
            '1.9mi',
            'format 2: positive whole number; padding',
        );
        // expect(new tcfTypes.TcfDistance(null, localeNode).fromString('1.95mi').toString()).toEqual('2.0mi', 'format 2: positive whole number; padding'); // TODO failing due to rounding error
        expect(new tcfTypes.TcfDistance(null, localeNode).fromString('1.96mi').toString()).toEqual(
            '2.0mi',
            'format 2: positive whole number; padding',
        );
    });
});

describe('tcfTypes.TcfColorRef', () => {
    beforeEach(() => {
        // @ts-ignore
        jasmine.addMatchers(customMatchers);
    });

    const setLocale = function(value) {
        localeNode.setAttribute('localeFormatColorRef', value);
    };
    let localeNode;

    beforeAll(() => {
        document.body.setAttribute('localeFormatColorRef', '1');
        localeNode = document.body.appendChild(document.createElement('div'));
    });

    afterAll(() => {
        document.body.removeAttribute('localeFormatColorRef');
    });

    it('Initialize', () => {
        // 'invalid color: by type, boolean'
        expect(() => {
            new tcfTypes.TcfColorRef(false);
        }).toThrowError();
        // 'invalid color: by type, boolean'
        expect(() => {
            new tcfTypes.TcfColorRef(true);
        }).toThrowError();
        // 'invalid color: by type, string'
        expect(() => {
            new tcfTypes.TcfColorRef('');
        }).toThrowError();
        // 'invalid color: by type, string'
        expect(() => {
            new tcfTypes.TcfColorRef('1');
        }).toThrowError();
        // 'invalid color: by value'
        expect(() => {
            new tcfTypes.TcfColorRef(-1);
        }).toThrowError();
        // 'invalid color: by value'
        expect(() => {
            new tcfTypes.TcfColorRef(0xffffffff + 1);
        }).toThrowError();

        assertNoException('valid color: not specified', () => {
            new tcfTypes.TcfColorRef();
        });
        assertNoException('valid color: black', () => {
            new tcfTypes.TcfColorRef(0);
        });
        assertNoException('valid color: gray', () => {
            new tcfTypes.TcfColorRef(0x888888);
        });
        assertNoException('valid color: white', () => {
            new tcfTypes.TcfColorRef(0xffffff);
        });
    });

    it('SetValue', () => {
        expect(new tcfTypes.TcfColorRef().setValue(null).getValue()).toEqual(null, 'color: null');
        expect(new tcfTypes.TcfColorRef().setValue(0x0080ff).getValue()).toEqual(0x0080ff, 'color: 0x0080FF');
    });

    it('GetLocalizationKey', () => {
        expect(new tcfTypes.TcfColorRef().getLocalizationKey()).toEqual('localeFormatColorRef');
    });

    // TODO
    it('ToString', () => {
        expect(new tcfTypes.TcfColorRef(undefined, localeNode).toString()).toEqual('', 'format: default; undefined');
        expect(new tcfTypes.TcfColorRef(null, localeNode).toString()).toEqual('', 'format: default; null');

        setLocale(1),
            assertEquals(
                'format: TF_COLOR_CSS_AUTO',
                new tcfTypes.TcfColorRef(0xff8000, localeNode).toString(),
                'rgb(0,128,255)',
            );
        setLocale(2),
            assertMatch(
                'format: TF_COLOR_COLORREF_HEX',
                /0xFF8000/i,
                new tcfTypes.TcfColorRef(0xff8000, localeNode).toString(),
            );
        setLocale(3),
            expect(new tcfTypes.TcfColorRef(0xff8000, localeNode).toString()).toEqual(
                0xff8000,
                'format: TF_COLOR_COLORREF',
            );
        setLocale(4),
            assertMatch(
                'format: TF_COLOR_ARGB',
                /0xFF0080FF/i,
                new tcfTypes.TcfColorRef(0xff8000, localeNode).toString(),
            );
        setLocale(5),
            expect(new tcfTypes.TcfColorRef(0xff8000, localeNode).toString()).toEqual(
                0xffff8000,
                'format: TF_COLOR_ARGB',
            );
        setLocale(6),
            assertMatch(
                'format: TF_COLOR_CSS_HEX',
                /#0080FF/i,
                new tcfTypes.TcfColorRef(0xff8000, localeNode).toString(),
            );
        setLocale(7),
            assertMatch(
                'format: TF_COLOR_CSS_HEXA',
                /#FF0080FF/i,
                new tcfTypes.TcfColorRef(0xff8000, localeNode).toString(),
            );
        setLocale(8),
            assertEquals(
                'format: TF_COLOR_CSS_RGB',
                new tcfTypes.TcfColorRef(0xff8000, localeNode).toString(),
                'rgb(0,128,255)',
            );
        setLocale(9),
            assertEquals(
                'format: TF_COLOR_CSS_RGBA',
                new tcfTypes.TcfColorRef(0xff8000, localeNode).toString(),
                'rgba(0,128,255,1.0)',
            );
        setLocale(10),
            assertEquals(
                'format: TF_COLOR_CSS_HSL',
                new tcfTypes.TcfColorRef(0xff0000, localeNode).toString(),
                'hsl(240,100%,50%)',
            );
        setLocale(11),
            assertEquals(
                'format: TF_COLOR_CSS_HSLA',
                new tcfTypes.TcfColorRef(0xff0000, localeNode).toString(),
                'hsla(240,100%,50%,1.0)',
            );
        setLocale(255),
            expect(new tcfTypes.TcfColorRef(0xff8000, localeNode).toString()).toEqual(0xff8000, 'format: TF_RAW');
    });

    it('FromString', () => {
        expect(null).toEqual(new tcfTypes.TcfColorRef().fromString(null).getValue(), 'undefined');
        // @ts-ignore
        expect(0xff8000).toEqual(new tcfTypes.TcfColorRef().fromString(0xff8000).getValue(), 'keyword');
        expect(0xff8000).toEqual(new tcfTypes.TcfColorRef().fromString('16744448').getValue(), 'keyword');
        // @ts-ignore
        expect(0xff8000).toEqual(new tcfTypes.TcfColorRef().fromString(new String('16744448')).getValue(), 'keyword');
        expect(0x0000ff).toEqual(new tcfTypes.TcfColorRef().fromString('red').getValue(), 'keyword');
        expect(0xff8800).toEqual(new tcfTypes.TcfColorRef().fromString('#08F').getValue(), 'shortHex');
        expect(0xff8000).toEqual(new tcfTypes.TcfColorRef().fromString('#0080FF').getValue(), 'longHex');
        expect(0xff8000).toEqual(new tcfTypes.TcfColorRef().fromString('rgb(0,128,255)').getValue(), 'rgbDecimal');
        // expect(0xFF8000).toEqual((new tcfTypes.TcfColorRef).fromString('rgb(0,50%,100%)').getValue(), 'rgbPercentage');       // TODO update Core.Color to support percentage
        expect(0xff8000).toEqual(
            new tcfTypes.TcfColorRef().fromString('rgba(0,128,255,0.5)').getValue(),
            'rgbaDecimal',
        );
        // expect(0xFF8000).toEqual((new tcfTypes.TcfColorRef).fromString('rgba(0,50%,100%,0.5)').getValue(), 'rgbaPercentage'); // TODO update Core.Color to support percentage
        expect(0xff8000).toEqual(new tcfTypes.TcfColorRef().fromString('hsl(210,100%,50%)').getValue(), 'hsl');
        expect(0xff8000).toEqual(new tcfTypes.TcfColorRef().fromString('hsla(210,100%,50%,0.5)').getValue(), 'hsla');
    });
});

describe('tcfTypes.TcfColor', () => {
    beforeEach(() => {
        // @ts-ignore
        jasmine.addMatchers(customMatchers);
    });

    let setLocale;
    let localeNode;
    beforeAll(() => {
        document.body.setAttribute('localeFormatColor', '1');

        localeNode = document.body.appendChild(document.createElement('div'));
        setLocale = function(value) {
            localeNode.setAttribute('localeFormatColor', value);
        };
    });

    afterAll(() => {
        document.body.removeAttribute('localeFormatColor');
    });

    it('Initialize', () => {
        assertException('invalid color: by type, boolean', () => {
            new tcfTypes.TcfColor(false);
        });
        assertException('invalid color: by type, boolean', () => {
            new tcfTypes.TcfColor(true);
        });
        assertException('invalid color: by type, string', () => {
            new tcfTypes.TcfColor('');
        });
        assertException('invalid color: by type, string', () => {
            new tcfTypes.TcfColor('1');
        });
        assertException('invalid color: by value', () => {
            new tcfTypes.TcfColor(-1);
        });
        assertException('invalid color: by value', () => {
            new tcfTypes.TcfColor(0xffffffff + 1);
        });

        assertNoException('valid color: not specified', () => {
            new tcfTypes.TcfColor();
        });
        assertNoException('valid color: black', () => {
            new tcfTypes.TcfColor(0);
        });
        assertNoException('valid color: gray', () => {
            new tcfTypes.TcfColor(0x888888);
        });
        assertNoException('valid color: white', () => {
            new tcfTypes.TcfColor(0xffffff);
        });
    });

    it('SetValue', () => {
        expect(new tcfTypes.TcfColor().setValue(null).getValue()).toEqual(null, 'color: null');
        expect(new tcfTypes.TcfColor().setValue(0x0080ff).getValue()).toEqual(0x0080ff, 'color: 0x0080FF');
        expect(new tcfTypes.TcfColor().setValue(0xff0080ff).getValue()).toEqual(0xff0080ff, 'color: 0xFF0080FF');
    });

    it('GetLocalizationKey', () => {
        expect(new tcfTypes.TcfColor().getLocalizationKey()).toEqual('localeFormatColor');
    });

    it('ToString', () => {
        expect(new tcfTypes.TcfColor(undefined, localeNode).toString()).toEqual('', 'format: default undefined');
        expect(new tcfTypes.TcfColor(null, localeNode).toString()).toEqual('', 'format: default null');

        setLocale(1);
        assertEquals(
            'format: TF_COLOR_CSS_AUTO',
            'rgb(0,128,255)',
            new tcfTypes.TcfColor(0x0080ff, localeNode).toString(),
        );
        assertEquals(
            'format: TF_COLOR_CSS_AUTO',
            'rgb(0,128,255)',
            new tcfTypes.TcfColor(0xff0080ff, localeNode).toString(),
        );

        // setLocale(2);
        // setLocale(3);

        setLocale(4);
        assertMatch('format: TF_COLOR_ARGB', /0xFF0080FF/i, new tcfTypes.TcfColor(0x0080ff, localeNode).toString());
        assertMatch('format: TF_COLOR_ARGB', /0xFF0080FF/i, new tcfTypes.TcfColor(0xff0080ff, localeNode).toString());

        setLocale(5);
        expect(new tcfTypes.TcfColor(0x0080ff, localeNode).toString()).toEqual(0xff0080ff, 'format: TF_COLOR_ARGB');
        expect(new tcfTypes.TcfColor(0xff0080ff, localeNode).toString()).toEqual(0xff0080ff, 'format: TF_COLOR_ARGB');

        setLocale(6);
        assertMatch('format: TF_COLOR_CSS_HEX', /#0080FF/i, new tcfTypes.TcfColor(0x0080ff, localeNode).toString());
        assertMatch('format: TF_COLOR_CSS_HEX', /#0080FF/i, new tcfTypes.TcfColor(0xff0080ff, localeNode).toString());

        setLocale(7);
        assertMatch('format: TF_COLOR_CSS_HEXA', /#FF0080FF/i, new tcfTypes.TcfColor(0x0080ff, localeNode).toString());
        assertMatch(
            'format: TF_COLOR_CSS_HEXA',
            /#FF0080FF/i,
            new tcfTypes.TcfColor(0xff0080ff, localeNode).toString(),
        );

        setLocale(8);
        assertEquals(
            'format: TF_COLOR_CSS_RGB',
            'rgb(0,128,255)',
            new tcfTypes.TcfColor(0x0080ff, localeNode).toString(),
        );
        assertEquals(
            'format: TF_COLOR_CSS_RGB',
            'rgb(0,128,255)',
            new tcfTypes.TcfColor(0xff0080ff, localeNode).toString(),
        );

        setLocale(9);
        assertEquals(
            'format: TF_COLOR_CSS_RGBA',
            'rgba(0,128,255,1.0)',
            new tcfTypes.TcfColor(0x0080ff, localeNode).toString(),
        );
        assertEquals(
            'format: TF_COLOR_CSS_RGBA',
            'rgba(0,128,255,1.0)',
            new tcfTypes.TcfColor(0xff0080ff, localeNode).toString(),
        );

        setLocale(10);
        assertEquals(
            'format: TF_COLOR_CSS_HSL',
            'hsl(120,100%,50%)',
            new tcfTypes.TcfColor(0x00ff00, localeNode).toString(),
        );
        assertEquals(
            'format: TF_COLOR_CSS_HSL',
            'hsl(120,100%,50%)',
            new tcfTypes.TcfColor(0xff00ff00, localeNode).toString(),
        );

        setLocale(11);
        assertEquals(
            'format: TF_COLOR_CSS_HSLA',
            'hsla(120,100%,50%,1.0)',
            new tcfTypes.TcfColor(0x00ff00, localeNode).toString(),
        );
        assertEquals(
            'format: TF_COLOR_CSS_HSLA',
            'hsla(120,100%,50%,1.0)',
            new tcfTypes.TcfColor(0xff00ff00, localeNode).toString(),
        );

        setLocale(255);
        expect(new tcfTypes.TcfColor(0x0080ff, localeNode).toString()).toEqual(0x0080ff, 'format: TF_RAW');
        expect(new tcfTypes.TcfColor(0xff0080ff, localeNode).toString()).toEqual(0xff0080ff, 'format: TF_RAW');
    });

    it('FromString', () => {
        expect(null).toEqual(new tcfTypes.TcfColor().fromString(null).getValue(), 'undefined');
        expect(0xff0080ff).toEqual(new tcfTypes.TcfColor().fromString(0x0080ff).getValue(), 'keyword');
        expect(0xff0080ff).toEqual(new tcfTypes.TcfColor().fromString('33023').getValue(), 'keyword');
        // @ts-ignore
        expect(0xff0080ff).toEqual(new tcfTypes.TcfColor().fromString(new String('33023')).getValue(), 'keyword');

        expect(0xffff0000).toEqual(new tcfTypes.TcfColor().fromString('red').getValue(), 'keyword');
        expect(0xff0088ff).toEqual(new tcfTypes.TcfColor().fromString('#08F').getValue(), 'shortHex');
        expect(0xff0080ff).toEqual(new tcfTypes.TcfColor().fromString('#0080FF').getValue(), 'longHex');
        expect(0xff0080ff).toEqual(new tcfTypes.TcfColor().fromString('rgb(0,128,255)').getValue(), 'rgbDecimal');
        // expect(0xFF0080FF).toEqual((new tcfTypes.TcfColor).fromString('rgb(0,50%,100%)').getValue(), 'rgbPercentage');       // TODO update Core.Color to support percentage
        expect(0xff0080ff).toEqual(new tcfTypes.TcfColor().fromString('rgba(0,128,255,0.5)').getValue(), 'rgbaDecimal');
        // expect(0xFF0080FF).toEqual((new tcfTypes.TcfColor).fromString('rgba(0,50%,100%,0.5)').getValue(), 'rgbaPercentage'); // TODO update Core.Color to support percentage
        expect(0xff0080ff).toEqual(new tcfTypes.TcfColor().fromString('hsl(210,100%,50%)').getValue(), 'hsl');
        expect(0xff0080ff).toEqual(new tcfTypes.TcfColor().fromString('hsla(210,100%,50%,0.5)').getValue(), 'hsla');
    });
});

describe('tcfTypes.TcfColorAlpha', () => {
    beforeEach(() => {
        // @ts-ignore
        jasmine.addMatchers(customMatchers);
    });

    let localeNode;
    let setLocale;
    beforeAll(() => {
        document.body.setAttribute('localeFormatColorAlpha', '1');

        localeNode = document.body.appendChild(document.createElement('div'));
        setLocale = function(value) {
            localeNode.setAttribute('localeFormatColorAlpha', value);
        };
    });

    afterAll(() => {
        document.body.removeAttribute('localeFormatColorAlpha');
    });

    it('SetValue', () => {
        expect(new tcfTypes.TcfColorAlpha().setValue(null).getValue()).toEqual(null, 'color: null');
        expect(new tcfTypes.TcfColorAlpha().setValue(0x0080ff).getValue()).toEqual(0x0080ff, 'color: 0x0080FF');
        expect(new tcfTypes.TcfColorAlpha().setValue(0xff0080ff).getValue()).toEqual(0xff0080ff, 'color: 0xFF0080FF');
    });

    it('GetLocalizationKey', () => {
        expect(new tcfTypes.TcfColorAlpha().getLocalizationKey()).toEqual('localeFormatColorAlpha');
    });

    it('ToString', () => {
        expect(new tcfTypes.TcfColorAlpha(undefined, localeNode).toString()).toEqual('', 'format: default undefined');
        expect(new tcfTypes.TcfColorAlpha(null, localeNode).toString()).toEqual('', 'format: default null');

        setLocale(1);
        assertEquals(
            'format: TF_COLOR_CSS_AUTO',
            'rgb(0,128,255)',
            new tcfTypes.TcfColorAlpha(0x0080ff, localeNode).toString(),
        );
        assertEquals(
            'format: TF_COLOR_CSS_AUTO',
            'rgb(0,128,255)',
            new tcfTypes.TcfColorAlpha(0xff0080ff, localeNode).toString(),
        );
        assertEquals(
            'format: TF_COLOR_CSS_AUTO',
            'rgb(0,128,255)',
            new tcfTypes.TcfColorAlpha(0xff0080ff, localeNode).toString(),
        );

        // setLocale(2);
        // setLocale(3);

        setLocale(4);
        assertMatch(
            'format: TF_COLOR_ARGB',
            /0xFF0080FF/i,
            new tcfTypes.TcfColorAlpha(0x0080ff, localeNode).toString(),
        );
        assertMatch(
            'format: TF_COLOR_ARGB',
            /0xFF0080FF/i,
            new tcfTypes.TcfColorAlpha(0xff0080ff, localeNode).toString(),
        );

        setLocale(5);
        expect(new tcfTypes.TcfColorAlpha(0x0080ff, localeNode).toString()).toEqual(
            0xff0080ff,
            'format: TF_COLOR_ARGB',
        );
        expect(new tcfTypes.TcfColorAlpha(0xff0080ff, localeNode).toString()).toEqual(
            0xff0080ff,
            'format: TF_COLOR_ARGB',
        );

        setLocale(6);
        assertMatch(
            'format: TF_COLOR_CSS_HEX',
            /#0080FF/i,
            new tcfTypes.TcfColorAlpha(0x0080ff, localeNode).toString(),
        );
        assertMatch(
            'format: TF_COLOR_CSS_HEX',
            /#0080FF/i,
            new tcfTypes.TcfColorAlpha(0xff0080ff, localeNode).toString(),
        );

        setLocale(7);
        assertMatch(
            'format: TF_COLOR_CSS_HEXA',
            /#FF0080FF/i,
            new tcfTypes.TcfColorAlpha(0x0080ff, localeNode).toString(),
        );
        assertMatch(
            'format: TF_COLOR_CSS_HEXA',
            /#FF0080FF/i,
            new tcfTypes.TcfColorAlpha(0xff0080ff, localeNode).toString(),
        );

        setLocale(8);
        assertEquals(
            'format: TF_COLOR_CSS_RGB',
            'rgb(0,128,255)',
            new tcfTypes.TcfColorAlpha(0x0080ff, localeNode).toString(),
        );
        assertEquals(
            'format: TF_COLOR_CSS_RGB',
            'rgb(0,128,255)',
            new tcfTypes.TcfColorAlpha(0xff0080ff, localeNode).toString(),
        );

        setLocale(9);
        assertEquals(
            'format: TF_COLOR_CSS_RGBA',
            'rgba(0,128,255,1.0)',
            new tcfTypes.TcfColorAlpha(0x0080ff, localeNode).toString(),
        );
        assertEquals(
            'format: TF_COLOR_CSS_RGBA',
            'rgba(0,128,255,1.0)',
            new tcfTypes.TcfColorAlpha(0xff0080ff, localeNode).toString(),
        );

        setLocale(10);
        assertEquals(
            'format: TF_COLOR_CSS_HSL',
            'hsl(120,100%,50%)',
            new tcfTypes.TcfColorAlpha(0x00ff00, localeNode).toString(),
        );
        assertEquals(
            'format: TF_COLOR_CSS_HSL',
            'hsl(120,100%,50%)',
            new tcfTypes.TcfColorAlpha(0xff00ff00, localeNode).toString(),
        );

        setLocale(11);
        assertEquals(
            'format: TF_COLOR_CSS_HSLA',
            'hsla(120,100%,50%,1.0)',
            new tcfTypes.TcfColorAlpha(0x00ff00, localeNode).toString(),
        );
        assertEquals(
            'format: TF_COLOR_CSS_HSLA',
            'hsla(120,100%,50%,1.0)',
            new tcfTypes.TcfColorAlpha(0xff00ff00, localeNode).toString(),
        );

        setLocale(255);
        expect(new tcfTypes.TcfColorAlpha(0x0080ff, localeNode).toString()).toEqual(0x0080ff, 'format: TF_RAW');
        expect(new tcfTypes.TcfColorAlpha(0xff0080ff, localeNode).toString()).toEqual(0xff0080ff, 'format: TF_RAW');
    });

    it('FromString', () => {
        expect(null).toEqual(new tcfTypes.TcfColorAlpha().fromString(null).getValue(), 'undefined');
        expect(0xff0080ff).toEqual(new tcfTypes.TcfColorAlpha().fromString(0xff0080ff).getValue(), 'keyword');
        expect(0xff0080ff).toEqual(new tcfTypes.TcfColorAlpha().fromString('4278223103').getValue(), 'keyword');
        // @ts-ignore
        expect(0xff0080ff).toEqual(new tcfTypes.TcfColorAlpha().fromString(String('4278223103')).getValue(), 'keyword');
        expect(0xffff0000).toEqual(new tcfTypes.TcfColorAlpha().fromString('red').getValue(), 'keyword');
        expect(0xff0088ff).toEqual(new tcfTypes.TcfColorAlpha().fromString('#08F').getValue(), 'shortHex');
        expect(0xff0080ff).toEqual(new tcfTypes.TcfColorAlpha().fromString('#0080FF').getValue(), 'longHex');
        expect(0xff0080ff).toEqual(new tcfTypes.TcfColorAlpha().fromString('rgb(0,128,255)').getValue(), 'rgbDecimal');
        // expect(0xFF0080FF).toEqual((new tcfTypes.TcfColorAlpha).fromString('rgb(0,50%,100%)').getValue(), 'rgbPercentage');       // TODO update Core.Color to support percentage
        expect(0x800080ff).toEqual(
            new tcfTypes.TcfColorAlpha().fromString('rgba(0,128,255,0.5)').getValue(),
            'rgbaDecimal',
        );
        // expect(0xFF0080FF).toEqual((new tcfTypes.TcfColorAlpha).fromString('rgba(0,50%,100%,0.5)').getValue(), 'rgbaPercentage'); // TODO update Core.Color to support percentage
        expect(0xff0080ff).toEqual(new tcfTypes.TcfColorAlpha().fromString('hsl(210,100%,50%)').getValue(), 'hsl');
        expect(0x800080ff).toEqual(
            new tcfTypes.TcfColorAlpha().fromString('hsla(210,100%,50%,0.5)').getValue(),
            'hsla',
        );
    });
});

describe('Rowset', () => {
    beforeEach(() => {
        // @ts-ignore
        jasmine.addMatchers(customMatchers);
    });

    const rowset1Json = {
        _TCF_Rowset: 'version=1',
        mode: 0,
        header: [
            { name: 'description', type: '10' },
            { name: '_Boolean', type: '1' },
            { name: '_Byte', type: '2' },
            { name: '_SByte', type: '3' },
            { name: '_Int16', type: '6' },
            { name: '_UInt16', type: '7' },
            { name: '_Int32', type: '8' },
            { name: '_UInt32', type: '9' },
            { name: '_Int64', type: 'A' },
            { name: '_UInt64', type: 'B' },
            { name: '_Double', type: 'C' },
            { name: '_Single', type: 'D' },
            { name: '_String', type: '10' },
            { name: '_TimeSpan', type: 'A0008' },
            { name: '_BigTimeSpan', type: 'C000A' },
            { name: '_Time', type: '140008' },
            { name: '_Date', type: '1E0008' },
            { name: '_WeekdaysStr', type: '460010' },
            { name: '_WeekdaysInt', type: '460008' },
            { name: '_Distance', type: '28000C' },
            { name: '_DistanceInt', type: '280008' },
            { name: '_Speed', type: '32000C' },
            { name: '_Volume', type: '82000C' },
            { name: '_Pressure', type: '8C000C' },
            { name: '_Acceleration', type: '96000C' },
            { name: '_Datetime', type: '23000A' },
            { name: '_Datetime2', type: '23000A' },
            { name: '_FuelEconomy', type: 'AA000C' },
            { name: '11', type: '6' },
            { name: '99', type: '6' },
            { name: '0', type: '6' },
            { name: '-2', type: '6' },
        ],
        defaults: [
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
        ],
        data: [
            [
                'Min',
                false,
                0,
                -127,
                -32767,
                0,
                -2147483647,
                0,
                -9007199254740992,
                0,
                -1.79769313486232e308,
                -3.402823e38,
                'minimum',
                -2147483646,
                -9007199254740992,
                0,
                0,
                '0000000',
                0,
                -1e308,
                -2147483646,
                -1e308,
                -1e308,
                -1e308,
                -1e308,
                0,
                0,
                -1e308,
                -500,
                -43,
                -231,
                -7324,
            ],
            [
                'Max',
                true,
                255,
                127,
                32767,
                65535,
                2147483647,
                4294967295,
                9007199254740992,
                9007199254740992,
                1.79769313486232e308,
                3.402823e38,
                'maximum',
                2147483647,
                9007199254740992,
                2147483647,
                99991231,
                '1111111',
                127,
                1.79769313486232e308,
                2147483647,
                1.79769313486232e308,
                1.79769313486232e308,
                1.79769313486232e308,
                1.79769313486232e308,
                1.79769313486232e308,
                1.79769313486232e308,
                1.79769313486232e308,
                1,
                4,
                7,
                3,
            ],
            [
                'Sample',
                true,
                50,
                -50,
                -1000,
                1000,
                -111000,
                111000,
                -333222111000,
                333222111000,
                0.0,
                0.0,
                'sample',
                5432,
                5432,
                5432,
                20100125,
                '1010101',
                85,
                12345.67,
                12345,
                43.21,
                123.45,
                101.325,
                9.8,
                12739553120000,
                12844473600000,
                100.345,
                12334,
                123412,
                43211,
                987,
            ],
            [
                'Zero',
                false,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0.0,
                0.0,
                'zero',
                0,
                0,
                0,
                0,
                '0',
                0.0,
                0,
                0.0,
                0.0,
                0.0,
                0.0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
            ],
            [
                'Null',
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
            ],
        ],
    };

    const rowset1 = new Rowset(rowset1Json);

    const rowset2 = new Rowset({
        _TCF_Rowset: 'version=1',
        mode: 0,
        header: [
            { name: '_Boolean_1', type: '1' },
            { name: '_Boolean_2', type: '1' },
            { name: '_Boolean_3', type: '1' },
            { name: '_Int32_1', type: '8' },
            { name: '_Int32_2', type: '8' },
            { name: '_Double_1', type: 'C' },
            { name: '_Double_2', type: 'C' },
            { name: '_String_1', type: '10' },
            { name: '_String_2', type: '10' },
            { name: '_Duplicate', type: '10' },
            { name: '_NaN', type: '10' },
        ],
        defaults: [null, null, null, null, null, null, null, null, null, null, null],
        data: [
            [false, true, false, -1, 10, -1.1, 10.1, '-1', '10', -5, 'a'],
            [false, true, true, 0, 20, -1.2, 10.01, '0', '20', -5, 'b'],
            [false, true, true, 0, 20, -1.2, 10.01, '0', '20', 5, 'c'],
            [false, true, false, 1, 30, -1.3, 10.001, '1', '30', 5, 'd'],
        ],
    });

    const rowset3 = new Rowset({
        _TCF_Rowset: 'version=1',
        mode: 0,
        header: [{ name: '_Int32_0', type: '8' }, { name: '_Int32_1', type: '8' }, { name: '_Int32_2', type: '8' }],
        defaults: [null, null],
        data: [
            [null, null, null],
            [0, 10, 11],
            [0, 20, 21],
            [0, 20, 22],
            [0, 30, 31],
            [0, 30, 32],
            [0, 30, 33],
            [0, 40, 41],
            [0, 40, 42],
            [0, 40, 43],
            [0, 40, 44],
        ],
    });

    // tcfTypes.TcfAbstractMatrix

    it('GetValue', () => {
        assertObject(rowset1.getValue());
        expect(rowset1Json).toBe(rowset1.getValue());
    });

    it('SetValue', () => {
        const rowset = new Rowset(clone(rowset1.getValue()));
        expect(rowset).toBe(rowset.setValue(null));
        // @ts-ignore
        assertNoException('', () => {
            // @ts-ignore
            rowset.setValue(rowset1Json);
        });
        // @ts-ignore
        expect(() => {
            rowset.setValue({});
        }).toThrowError();
    });

    it('GetCell', () => {
        expect(() => {
            rowset1.getCell(-1, 0);
        }).toThrowError();
        expect(() => {
            rowset1.getCell(5, 0);
        }).toThrowError();
        // @ts-ignore
        expect(() => {
            // @ts-ignore
            rowset1.getCell('-1', '0');
        }).toThrowError();
        // @ts-ignore
        expect(() => {
            // @ts-ignore
            rowset1.getCell('5', '0');
        }).toThrowError();

        expect(rowset1.getCell(0, -1)).toBeUndefined();
        expect(rowset1.getCell(0, 32)).toBeUndefined();
        // @ts-ignore
        expect(rowset1.getCell('0', '-1')).toBeUndefined();
        // @ts-ignore
        expect(rowset1.getCell('0', '32')).toBeUndefined();

        expect(rowset1.getCell(0, 0)).toEqual('Min');
        expect(rowset1.getCell(1, 0)).toEqual('Max');
        expect(rowset1.getCell(0, 1)).toEqual(false);
        expect(rowset1.getCell(1, 1)).toEqual(true);
        // @ts-ignore
        expect(rowset1.getCell('0', '0')).toEqual('Min');
        // @ts-ignore
        expect(rowset1.getCell('1', '0')).toEqual('Max');
        // @ts-ignore
        expect(rowset1.getCell('0', '1')).toEqual(false);
        // @ts-ignore
        expect(rowset1.getCell('1', '1')).toEqual(true);

        expect(rowset1.getCell(4, 4)).toEqual(null);
    });

    it('SetCell', () => {
        const rowset = new Rowset(clone(rowset1.getValue()));
        expect(() => {
            rowset.setCell(-1, 0, null);
        }).toThrowError();
        expect(() => {
            rowset.setCell(5, 0, null);
        }).toThrowError();
        // @ts-ignore
        expect(() => {
            rowset.setCell('-1', '0', null);
        }).toThrowError();
        // @ts-ignore
        expect(() => {
            // @ts-ignore
            rowset.setCell('5', '0', null);
        }).toThrowError();

        expect(rowset.setCell(0, 0, rowset.getCell(0, 0))).toBeUndefined();

        expect((rowset.setCell(0, -1, -1), rowset.getCell(0, -1))).toEqual(-1);
        expect((rowset.setCell(0, 32, -2), rowset.getCell(0, 32))).toEqual(-2);
        // @ts-ignore
        expect((rowset.setCell('0', '-1', -3), rowset.getCell('0', '-1'))).toEqual(-3);
        // @ts-ignore
        expect((rowset.setCell('0', '32', -4), rowset.getCell('0', '32'))).toEqual(-4);
    });

    it('HasData', () => {
        expect(new Rowset().hasData()).toBe(false);
        expect(new Rowset().setValue(null).hasData()).toBe(false);

        // @ts-ignore
        expect(new Rowset().setValue(rowset1Json).hasData()).toBe(true);
    });

    it('GetRowCount', () => {
        expect(typeof rowset1.getRowCount()).toBe('number');
        expect(5).toEqual(rowset1.getRowCount());
    });

    it('GetColCount', () => {
        expect(typeof rowset1.getColCount()).toBe('number');
        expect(32).toEqual(rowset1.getColCount());
    });

    it('HasRow', () => {
        expect(new Rowset().hasRow(-2)).toBe(false);
        expect(new Rowset().hasRow(0)).toBe(false);
        expect(new Rowset().hasRow(1)).toBe(false);
        // @ts-ignore
        expect(new Rowset().hasRow('-2')).toBe(false);
        // @ts-ignore
        expect(new Rowset().hasRow('-1')).toBe(false); // Inconsistent
        // @ts-ignore
        expect(new Rowset().hasRow('0')).toBe(false);
        // @ts-ignore
        expect(new Rowset().hasRow('1')).toBe(false);

        expect(new Rowset().hasRow(-1)).toBe(true);

        expect(rowset1.hasRow(0)).toBe(true);
        expect(rowset1.hasRow(1)).toBe(true);
        expect(rowset1.hasRow(2)).toBe(true);
        expect(rowset1.hasRow(3)).toBe(true);
        expect(rowset1.hasRow(4)).toBe(true);
    });

    it('IndexOf', () => {
        expect(rowset1.indexOf('Min')).toEqual(0);
        expect(rowset1.indexOf('Max')).toEqual(1);
        expect(rowset1.indexOf('Sample')).toEqual(2);
        expect(rowset1.indexOf('Zero')).toEqual(3);
        expect(rowset1.indexOf('Null')).toEqual(4);
        expect(rowset1.indexOf('Min', 1)).toEqual(-1);
        expect(rowset1.indexOf('Max', 1)).toEqual(1);
        expect(rowset1.indexOf('Sample', 1)).toEqual(2);
        expect(rowset1.indexOf('Zero', 1)).toEqual(3);
        expect(rowset1.indexOf('Null', 1)).toEqual(4);
        expect(rowset1.indexOf('Min', 1, 1)).toEqual(-1);
        expect(rowset1.indexOf('Max', 1, 1)).toEqual(-1);
        expect(rowset1.indexOf('Sample', 1, 1)).toEqual(-1);
        expect(rowset1.indexOf('Zero', 1, 1)).toEqual(-1);
        expect(rowset1.indexOf('Null', 1, 1)).toEqual(-1);

        expect(rowset1.indexOf(false, 0, 0)).toEqual(-1);
        expect(rowset1.indexOf(true, 0, 0)).toEqual(-1);
        expect(rowset1.indexOf(false, 1, 0)).toEqual(-1);
        expect(rowset1.indexOf(true, 1, 0)).toEqual(-1);
        expect(rowset1.indexOf(false, 0, 1)).toEqual(0);
        expect(rowset1.indexOf(true, 0, 1)).toEqual(1);
        expect(rowset1.indexOf(false, 1, 1)).toEqual(3);
        expect(rowset1.indexOf(true, 1, 1)).toEqual(1);

        const param = [].concat(
            'Null',
            ' '
                .repeat(31)
                .split('')
                .map(() => null),
        );
        expect(rowset1.indexOf(param)).toEqual(4);

        expect(rowset1.indexOf([])).toEqual(-1);
    });

    // Rowset

    it('InstanceOf', () => {
        expect(Rowset.instanceOf([])).toBe(false);
        expect(Rowset.instanceOf({})).toBe(false);
        expect(Rowset.instanceOf(new tcfTypes.TcfBoolean())).toBe(false);

        expect(Rowset.instanceOf(new Rowset())).toBe(true);
    });

    it('FromArray', () => {
        const rowsetArray = [
            { null: null, boolean: false, number: 0, string: '', array: [], object: {} },
            { null: null, boolean: true, number: 1, string: 'a', array: [], object: {} },
            { null: null, boolean: null, number: null, string: null, array: null, object: null },
        ];

        assertObject(Rowset.fromArray(rowsetArray));
        expect(Rowset.fromArray(rowsetArray) instanceof Rowset).toBe(true);

        expect(Rowset.fromArray(rowsetArray).getColumnName(0)).toEqual('null');
        expect(Rowset.fromArray(rowsetArray).getColumnName(1)).toEqual('boolean');
        expect(Rowset.fromArray(rowsetArray).getColumnName(2)).toEqual('number');
        expect(Rowset.fromArray(rowsetArray).getColumnName(3)).toEqual('string');
        expect(Rowset.fromArray(rowsetArray).getColumnName(4)).toEqual('array');
        expect(Rowset.fromArray(rowsetArray).getColumnName(5)).toEqual('object');

        // @ts-ignore
        expect(Rowset.fromArray(rowsetArray).getCellDataType(0)).toEqual(
            TCFType.TCF_Variant.toString(16).toUpperCase(),
        );
        // @ts-ignore
        expect(Rowset.fromArray(rowsetArray).getCellDataType(1)).toEqual(
            TCFType.TCF_Boolean.toString(16).toUpperCase(),
        );
        // @ts-ignore
        expect(Rowset.fromArray(rowsetArray).getCellDataType(2)).toEqual(TCFType.TCF_Double.toString(16).toUpperCase());
        // @ts-ignore
        expect(Rowset.fromArray(rowsetArray).getCellDataType(3)).toEqual(TCFType.TCF_String.toString(16).toUpperCase());
        // @ts-ignore
        expect(Rowset.fromArray(rowsetArray).getCellDataType(4)).toEqual(TCFType.TCF_Rowset.toString(16).toUpperCase());
        // @ts-ignore
        expect(Rowset.fromArray(rowsetArray).getCellDataType(5)).toEqual(
            TCFType.TCF_Variant.toString(16).toUpperCase(),
        );

        expect(Rowset.fromArray(rowsetArray).getCell(0, 0)).toEqual(null);
        expect(Rowset.fromArray(rowsetArray).getCell(0, 1)).toEqual(false);
        expect(Rowset.fromArray(rowsetArray).getCell(0, 2)).toEqual(0);
        expect(Rowset.fromArray(rowsetArray).getCell(0, 3)).toEqual('');
        expect(Rowset.fromArray(rowsetArray).getCell(0, 4) instanceof Rowset).toBe(true);
        expect(Rowset.fromArray(rowsetArray).getCell(0, 5)).toEqual({});

        expect(Rowset.fromArray(rowsetArray).getCell(1, 0)).toEqual(null);
        expect(Rowset.fromArray(rowsetArray).getCell(1, 1)).toEqual(true);
        expect(Rowset.fromArray(rowsetArray).getCell(1, 2)).toEqual(1);
        expect(Rowset.fromArray(rowsetArray).getCell(1, 3)).toEqual('a');
        expect(Rowset.fromArray(rowsetArray).getCell(1, 4) instanceof Rowset).toBe(true);
        expect(Rowset.fromArray(rowsetArray).getCell(1, 5)).toEqual({});
    });

    it('NormalizeColumnName', () => {
        expect(Rowset.normalizeColumnName(undefined)).toBeNull();
        expect(Rowset.normalizeColumnName(null)).toBeNull();

        expect(Rowset.normalizeColumnName('a')).toEqual('A');
        expect(Rowset.normalizeColumnName('A')).toEqual('A');
        expect(Rowset.normalizeColumnName('abc')).toEqual('ABC');
        expect(Rowset.normalizeColumnName('ABC')).toEqual('ABC');
    });

    it('NormalizeColumnNames', () => {
        assertObject(Rowset.normalizeColumnNames([]));
        expect(Rowset.normalizeColumnNames([])).toEqual({});

        const colNames = ['a', 'B', 'cd', 'EF', 'ghIJkl'];
        const colNameMap = Rowset.normalizeColumnNames(colNames);

        expect(colNames[0]).toEqual('A');
        expect(colNames[1]).toEqual('B');
        expect(colNames[2]).toEqual('CD');
        expect(colNames[3]).toEqual('EF');
        expect(colNames[4]).toEqual('GHIJKL');

        expect(colNameMap[colNames[0]]).toEqual('a');
        expect(colNameMap[colNames[1]]).toEqual('B');
        expect(colNameMap[colNames[2]]).toEqual('cd');
        expect(colNameMap[colNames[3]]).toEqual('EF');
        expect(colNameMap[colNames[4]]).toEqual('ghIJkl');
    });

    it('SetName', () => {
        expect(new Rowset().setName('a').getName()).toEqual('a');
    });

    it('GetName', () => {
        expect(new Rowset().getName()).toEqual('');
        expect(new Rowset().setName('a').getName()).toEqual('a');
    });

    it('SetRowset', () => {
        let rs = new Rowset();
        rs.setRowset(undefined);
        expect(rs.toJSON()).toEqual({
            _TCF_Rowset: 'version=1',
            name: '',
            mode: 0,
            attributes: {},
            header: [],
            defaults: [],
            data: [],
        });

        rs = new Rowset();
        rs.setRowset(rowset2);
        expect(rs.toJSON()).toEqual(rowset2.toJSON());
    });

    it('GetField', () => {
        const testRowset = new Rowset({
            _TCF_Rowset: 'version=1',
            mode: 0,
            header: [
                { name: 'noCaption', type: '10' },
                { name: 'headerCaption', type: '10', caption: 'HeaderCaption' },
                { name: 'attrCaption', type: '10', attributes: { caption: 'AttributeCaption' } },
            ],
            data: [[null, null, null], ['10', '20', '30']],
        });

        expect(new Rowset().getField(0, 0)).toBeNull();
        expect(new Rowset().getField(-1, 0)).toBeNull();
        expect(rowset2.getField(0, -1)).toBeNull();
        expect(rowset2.getField(-2, 0)).toEqual('');

        expect(testRowset.getField(-1, 0)).toEqual('noCaption');
        expect(testRowset.getField(-1, 1)).toEqual('HeaderCaption');
        expect(testRowset.getField(-1, 2)).toEqual('AttributeCaption');

        expect(testRowset.getField(0, 0)).toBeNull();
        expect(testRowset.getField(0, 1)).toBeNull();
        expect(testRowset.getField(0, 2)).toBeNull();
        expect(testRowset.getField(1, 0)).toEqual('10');
        expect(testRowset.getField(1, 1)).toEqual('20');
        expect(testRowset.getField(1, 2)).toEqual('30');

        expect(rowset2.getField(0, 4)).toEqual(10);
        expect(rowset2.getField(1, 4)).toEqual(20);
        expect(rowset2.getField(1, '_Int32_2')).toEqual(20);
    });

    it('SetField', () => {
        const testRowset = new Rowset({
            _TCF_Rowset: 'version=1',
            mode: 0,
            header: [
                { name: 'ColNameTest', type: '10' },
                { name: 'Editable_1', type: '10' },
                { name: 'Editable_2', type: '10', displayMode: 0 },
                { name: 'ReadOnly_1', type: '10', displayMode: 1 },
            ],
            data: [['0', '10', '20', '30']],
        });

        expect((testRowset.setField(0, 0, '1'), testRowset.getField(0, 0))).toEqual('1');
        expect((testRowset.setField(0, 'ColNameTest', '2'), testRowset.getField(0, 'ColNameTest'))).toEqual('2');

        expect(testRowset.getField(0, 1)).toEqual('10');
        expect((testRowset.setField(0, 1, '11'), testRowset.getField(0, 1))).toEqual('11');

        expect(testRowset.getField(0, 2)).toEqual('20');
        expect((testRowset.setField(0, 2, '21'), testRowset.getField(0, 2))).toEqual('21');

        expect(testRowset.getField(0, 3)).toEqual('30');
        expect((testRowset.setField(0, 3, '31'), testRowset.getField(0, 3))).toEqual('30');
    });

    it('GetHeader', () => {
        expect(rowset1.getHeader('_Date')).toEqual({ name: '_Date', type: '1E0008' }, '_Date');
        expect(rowset1.getHeader(11)).toEqual({ name: '_Single', type: 'D' }, '11 Number');
        expect({ name: '11', type: '6' }).toEqual(rowset1.getHeader('11'), '11');
        expect(rowset1.getHeader(0)).toEqual({ name: 'description', type: '10' }, '0 Number');
        expect({ name: '0', type: '6' }).toEqual(rowset1.getHeader('0'), '0');
        // '-2 Number'
        expect(rowset1.getHeader(-2)).toBeNull();
        expect(rowset1.getHeader('-2')).toEqual({ name: '-2', type: '6' }, '-2');
        // @ts-ignore
        expect(rowset1.json.header).toBe(rowset1.getHeader(), 'Nothing');
        // '99 Number'
        expect(rowset1.getHeader(99)).toBeNull();
        // 'ABC'
        expect(rowset1.getHeader('ABC')).toBeNull();
    });

    it('GetCellDataType', () => {
        expect(new Rowset().getCellDataType(null, -1)).toEqual('string');
        expect(new Rowset().getCellDataType(null, -10)).toEqual('string');
        expect(new Rowset().getCellDataType(null, -100)).toEqual('string');

        expect(rowset1.getCellDataType(null, 0)).toEqual('10');
        expect(rowset1.getCellDataType(null, 1)).toEqual('1');
        expect(rowset1.getCellDataType(null, 2)).toEqual('2');
        expect(rowset1.getCellDataType(null, 3)).toEqual('3');
        expect(rowset1.getCellDataType(null, 4)).toEqual('6');
        expect(rowset1.getCellDataType(null, 5)).toEqual('7');
        expect(rowset1.getCellDataType(null, 6)).toEqual('8');
        expect(rowset1.getCellDataType(null, 7)).toEqual('9');
        expect(rowset1.getCellDataType(null, 8)).toEqual('A');
        expect(rowset1.getCellDataType(null, 9)).toEqual('B');
        expect(rowset1.getCellDataType(null, 10)).toEqual('C');
        expect(rowset1.getCellDataType(null, 11)).toEqual('D');
        expect(rowset1.getCellDataType(null, 12)).toEqual('10');
        expect(rowset1.getCellDataType(null, 13)).toEqual('A0008');
        expect(rowset1.getCellDataType(null, 14)).toEqual('C000A');
    });

    it('GetColumnName', () => {
        // @ts-ignore
        expect(new Rowset().getColumnName()).toBeUndefined();

        expect(rowset1.getColumnName(0)).toEqual('description');
        expect(rowset1.getColumnName(1)).toEqual('_Boolean');
        expect(rowset1.getColumnName(0, 0)).toEqual('description');
        expect(rowset1.getColumnName(0, 1)).toEqual('_Boolean');
        expect(rowset1.getColumnName(1, 0)).toEqual('description');
        expect(rowset1.getColumnName(1, 1)).toEqual('_Boolean');
    });

    it('GetColumnNames', () => {
        expect(new Rowset().getColumnNames()).toEqual([]);
        expect(rowset1.getColumnNames()).toEqual([
            'description',
            '_Boolean',
            '_Byte',
            '_SByte',
            '_Int16',
            '_UInt16',
            '_Int32',
            '_UInt32',
            '_Int64',
            '_UInt64',
            '_Double',
            '_Single',
            '_String',
            '_TimeSpan',
            '_BigTimeSpan',
            '_Time',
            '_Date',
            '_WeekdaysStr',
            '_WeekdaysInt',
            '_Distance',
            '_DistanceInt',
            '_Speed',
            '_Volume',
            '_Pressure',
            '_Acceleration',
            '_Datetime',
            '_Datetime2',
            '_FuelEconomy',
            '11',
            '99',
            '0',
            '-2',
        ]);
    });

    it('AddAttribute', () => {
        // 'value1'
        const rowset = new Rowset(clone(rowset1.getValue()));
        expect(rowset).toBe(rowset.addAttribute('name1', 'value1'));
        expect(rowset.getAttribute('name1')).toEqual('value1');
        expect(rowset.addAttribute('name2', 'value2').getAttribute('name2')).toEqual('value2');
        expect(rowset.addAttribute('name2', 'value22').getAttribute('name2')).toEqual('value22');
    });

    it('GetAttribute', () => {
        const rowset = new Rowset(clone(rowset1.getValue()));
        expect(rowset.getAttribute('doesNotExists')).toBeUndefined();
        expect(rowset.addAttribute('name1', undefined).getAttribute('name1')).toBeUndefined();
        expect(rowset.addAttribute('name1', 'value1').getAttribute('name1')).toEqual('value1');
    });

    it('HasAttribute', () => {
        const rowset = new Rowset(clone(rowset1.getValue()));
        expect(rowset.hasAttribute('doesNotExists')).toBe(false);
        expect(rowset.addAttribute('name1', undefined).hasAttribute('name1')).toBe(true);
    });

    it('DeleteAttribute', () => {
        const rowset = new Rowset(clone(rowset1.getValue()));
        expect(rowset.hasAttribute('name1')).toBe(false);
        expect(rowset.addAttribute('name1', undefined).hasAttribute('name1')).toBe(true);
        expect(rowset.deleteAttribute('name1')).toBeUndefined();
        expect(rowset.hasAttribute('name1')).toBe(false);
        expect(rowset.deleteAttribute('name1')).toBeUndefined();
        expect(rowset.hasAttribute('name1')).toBe(false);
    });

    it('GetCellDefault', () => {
        expect(rowset1.getCellDefault()).toEqual([
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
        ]);

        expect(rowset1.getCellDefault(0, -1)).toEqual(null);
        expect(rowset1.getCellDefault(0, 32)).toEqual(null);

        expect(rowset1.getCellDefault(0, 0)).toEqual(null);
        expect(rowset1.getCellDefault(0, 1)).toEqual(null);
        expect(rowset1.getCellDefault(0, 3)).toEqual(null);
    });

    it('GetColIndex', () => {
        expect(30).toEqual(rowset1.getColIndex('0'), '0');
        expect(0).toEqual(rowset1.getColIndex(0), '0 Number');
        expect(31).toEqual(rowset1.getColIndex('-2'), '-2');
        expect(-1).toEqual(rowset1.getColIndex(-2), '-2 Number');
        expect(28).toEqual(rowset1.getColIndex('11'), '11');
        expect(14).toEqual(rowset1.getColIndex('_BigTimeSpan'), '_BigTimeSpan');
        expect(12).toEqual(rowset1.getColIndex('12'), '12');
        expect(-1).toEqual(rowset1.getColIndex('ABC'), 'ABC');
        expect(11).toEqual(rowset1.getColIndex(11), 'Number 11');
        expect(-1).toEqual(rowset1.getColIndex(99), 'Number 99');
        expect(-1).toEqual(rowset1.getColIndex('-1'), 'String -1');
    });

    it('GetRow', () => {
        expect(() => {
            rowset1.getRow(-1);
        }).toThrowError();
        expect(() => {
            rowset1.getRow(rowset1.getRowCount());
        }).toThrowError();

        expect(rowset1.getRow(0) instanceof RowsetRow).toBe(true);
        expect(rowset1.getRow(rowset1.getRowCount() - 1) instanceof RowsetRow).toBe(true);

        expect(rowset1.getRow(0).rowIndex).toEqual(0);
        expect(rowset1.getRow(1).rowIndex).toEqual(1);
        expect(rowset1.getRow(2).rowIndex).toEqual(2);
    });

    it('GetRowByFieldValue', () => {
        expect(rowset2.getRowByFieldValue(null, 4)).toBeNull();
        expect(rowset2.getRowByFieldValue(10, 4) instanceof RowsetRow).toBe(true);
        expect(rowset2.getRowByFieldValue(10, '4') instanceof RowsetRow).toBe(true);
        expect(rowset2.getRowByFieldValue(10, '4') instanceof RowsetRow).toBe(true);
        expect(rowset2.getRowByFieldValue(10, '_Int32_2') instanceof RowsetRow).toBe(true);

        expect(rowset2.getRowByFieldValue(10, 4).rowIndex).toEqual(0);
        expect(rowset2.getRowByFieldValue(20, 4).rowIndex).toEqual(1);
        expect(rowset2.getRowByFieldValue(30, 4).rowIndex).toEqual(3);
    });

    it('Find', () => {
        expect(rowset1.find('Min', 'description')).toEqual(0, 'Column Name');
        expect(rowset1.find('Zero', 0)).toEqual(3, 'Column Index');
        expect(rowset1.find('Min', 1)).toEqual(-1, 'Not Found');
        expect(rowset1.find(false, '_Boolean')).toEqual(0, 'startIndex default');
        expect(rowset1.find(false, '_Boolean', 0)).toEqual(0, 'startIndex specified default');
        expect(rowset1.find(false, '_Boolean', 1)).toEqual(3, 'startIndex specified not default');
        expect(rowset1.find(false, '_Byte', 0, (testValue, value) => testValue === !!value)).toEqual(0, 'comparator');
        expect(rowset1.find(true, '_Byte', 0, (testValue, value) => testValue === !!value)).toEqual(1, 'comparator');
    });

    it('FindValues', () => {
        // STUB: To clarify implementation logic...
    });

    it('FindAll', () => {
        // STUB
    });

    it('FindAllValues', () => {
        expect(rowset1.findAllValues(['Min', false, 0], ['description', '_Boolean', '_Byte'])).toEqual(
            [0],
            'Column Name ',
        );
        expect(rowset1.findAllValues(['Min', false, 0], [0, 1, 2])).toEqual([0], 'Column Index ');
        expect(rowset1.findAllValues([false, 0], [1, 2])).toEqual([0, 3], 'Multiple Result: ');
        expect(rowset1.findAllValues([false, 1], [1, 2])).toEqual([], 'Not Found Second Value: ');
        expect(rowset1.findAllValues([true, 0], [1, 2])).toEqual([], 'Not Found First: ');
    });

    it('Filter', () => {
        const expected = [{ _Int32_0: null, _Int32_1: null, _Int32_2: null }];
        expect(rowset3.filter(0, undefined).toArray()).toEqual([]);
        expect(rowset3.filter(0, null).toArray()).toEqual(expected);
        expect(rowset3.filter(0, null, true).toArray()).toEqual(expected);
        expect(rowset3.filter(0, 0, false).toArray()).toEqual(expected);
        expect(rowset3.filter('_Int32_0', undefined).toArray()).toEqual([]);
        expect(rowset3.filter('_Int32_0', null).toArray()).toEqual(expected);
        expect(rowset3.filter('_Int32_0', null, true).toArray()).toEqual(expected);
        expect(rowset3.filter('_Int32_0', 0, false).toArray()).toEqual(expected);

        expect(rowset3.filter('_Int32_1', 10).toArray()).toEqual([{ _Int32_0: 0, _Int32_1: 10, _Int32_2: 11 }]);
        expect(rowset3.filter('_Int32_1', 20).toArray()).toEqual([
            { _Int32_0: 0, _Int32_1: 20, _Int32_2: 21 },
            { _Int32_0: 0, _Int32_1: 20, _Int32_2: 22 },
        ]);
        expect(rowset3.filter('_Int32_1', 30).toArray()).toEqual([
            { _Int32_0: 0, _Int32_1: 30, _Int32_2: 31 },
            { _Int32_0: 0, _Int32_1: 30, _Int32_2: 32 },
            { _Int32_0: 0, _Int32_1: 30, _Int32_2: 33 },
        ]);
        expect(rowset3.filter('_Int32_1', 40).toArray()).toEqual([
            { _Int32_0: 0, _Int32_1: 40, _Int32_2: 41 },
            { _Int32_0: 0, _Int32_1: 40, _Int32_2: 42 },
            { _Int32_0: 0, _Int32_1: 40, _Int32_2: 43 },
            { _Int32_0: 0, _Int32_1: 40, _Int32_2: 44 },
        ]);

        expect(rowset3.filter('_Int32_2', value => value % 10 === 0).toArray()).toEqual([
            { _Int32_0: null, _Int32_1: null, _Int32_2: null },
        ]);
        expect(rowset3.filter('_Int32_2', value => value % 10 === 1).toArray()).toEqual([
            { _Int32_0: 0, _Int32_1: 10, _Int32_2: 11 },
            { _Int32_0: 0, _Int32_1: 20, _Int32_2: 21 },
            { _Int32_0: 0, _Int32_1: 30, _Int32_2: 31 },
            { _Int32_0: 0, _Int32_1: 40, _Int32_2: 41 },
        ]);
        expect(rowset3.filter('_Int32_2', value => value % 10 === 2).toArray()).toEqual([
            { _Int32_0: 0, _Int32_1: 20, _Int32_2: 22 },
            { _Int32_0: 0, _Int32_1: 30, _Int32_2: 32 },
            { _Int32_0: 0, _Int32_1: 40, _Int32_2: 42 },
        ]);
        expect(rowset3.filter('_Int32_2', value => value % 10 === 3).toArray()).toEqual([
            { _Int32_0: 0, _Int32_1: 30, _Int32_2: 33 },
            { _Int32_0: 0, _Int32_1: 40, _Int32_2: 43 },
        ]);
        expect(rowset3.filter('_Int32_2', value => value % 10 === 4).toArray()).toEqual([
            { _Int32_0: 0, _Int32_1: 40, _Int32_2: 44 },
        ]);
    });

    it('GetMinValue', () => {
        // @ts-ignore
        expect(new Rowset().getMinValue()).toBeNull();
        expect(isNaN(rowset2.getMinValue(10))).toBe(true);

        expect(rowset2.getMinValue(4)).toEqual(10);
        expect(rowset2.getMinValue('4')).toEqual(10);
        expect(rowset2.getMinValue('_Int32_2')).toEqual(10);

        expect(rowset2.getMinValue(0)).toEqual(false);
        expect(rowset2.getMinValue(1)).toEqual(true);
        expect(rowset2.getMinValue(2)).toEqual(false);
        expect(rowset2.getMinValue(3)).toEqual(-1);
        expect(rowset2.getMinValue(4)).toEqual(10);
        expect(rowset2.getMinValue(5)).toEqual(-1.3);
        expect(rowset2.getMinValue(6)).toEqual(10.001);
        expect(rowset2.getMinValue(7)).toEqual('-1');
        expect(rowset2.getMinValue(8)).toEqual('10');
        expect(rowset2.getMinValue(9)).toEqual(-5);
    });

    it('GetMaxValue', () => {
        // @ts-ignore
        expect(new Rowset().getMaxValue()).toBeNull();
        expect(isNaN(rowset2.getMaxValue(10))).toBe(true);

        expect(rowset2.getMaxValue(4)).toEqual(30);
        expect(rowset2.getMaxValue('4')).toEqual(30);
        expect(rowset2.getMaxValue('_Int32_2')).toEqual(30);

        expect(rowset2.getMaxValue(0)).toEqual(false);
        expect(rowset2.getMaxValue(1)).toEqual(true);
        expect(rowset2.getMaxValue(2)).toEqual(true);
        expect(rowset2.getMaxValue(3)).toEqual(1);
        expect(rowset2.getMaxValue(4)).toEqual(30);
        expect(rowset2.getMaxValue(5)).toEqual(-1.1);
        expect(rowset2.getMaxValue(6)).toEqual(10.1);
        expect(rowset2.getMaxValue(7)).toEqual('1');
        expect(rowset2.getMaxValue(8)).toEqual('30');
        expect(rowset2.getMaxValue(9)).toEqual(5);
    });

    it('GetDistinctValues', () => {
        expect({ '0': 2, '20100125': 1, '99991231': 1, null: 1 }).toEqual(rowset1.getDistinctValues('_Date'), 'Dates');
        expect(rowset1.getDistinctValues('_Date', true)).toEqual([null, 0, 20100125, 99991231], 'Dates Sorted');
        expect(rowset1.getDistinctValues('11')).toEqual({ '0': 1, '1': 1, '12334': 1, '-500': 1, null: 1 }, '11');
        expect(rowset1.getDistinctValues('11', true)).toEqual([null, -500, 0, 1, 12334], '11 Sorted');
        expect({ '0': 2, '-3.402823e+38': 1, '3.402823e+38': 1, null: 1 }).toEqual(
            rowset1.getDistinctValues(11),
            '11 Number',
        );
        expect(rowset1.getDistinctValues(11, true)).toEqual([null, -3.402823e38, 0, 3.402823e38], '11 Number Sorted');
        expect(rowset1.getDistinctValues('0')).toEqual({ '0': 1, '7': 1, '43211': 1, '-231': 1, null: 1 }, '0');
        expect(rowset1.getDistinctValues(0)).toEqual({ Min: 1, Max: 1, Sample: 1, Zero: 1, Null: 1 }, '0 Number');
        expect(rowset1.getDistinctValues('-2')).toEqual({ null: 1, '-7324': 1, '0': 1, '3': 1, '987': 1 }, '-2');
        expect(rowset1.getDistinctValues(-2)).toEqual({}, '-2 Number');

        expect({ '0000000': 1, '1111111': 1, '1010101': 1, '0': 1, null: 1 }).toEqual(
            rowset1.getDistinctValues('_WeekdaysStr'),
            'Weekdays',
        );
        expect(rowset1.getDistinctValues('_WeekdaysStr', true)).toEqual(
            [null, '0000000', '0', '1010101', '1111111'],
            'Weekdays Sorted',
        );

        expect(rowset1.getDistinctValues(['_Date', 11, '11', '_WeekdaysStr', '_Single', '_Double'])).toEqual(
            {
                '0': 10,
                '1': 1,
                '12334': 1,
                '1010101': 1,
                '1111111': 1,
                '20100125': 1,
                '99991231': 1,
                null: 6,
                '-3.402823e+38': 2,
                '3.402823e+38': 2,
                '-500': 1,
                '0000000': 1,
                '-Infinity': 1,
                Infinity: 1,
            },
            'Dates, 11, Weekdays, Single, Double',
        );
    });

    it('GetRowIndex', () => {
        expect(rowset1.getRowIndex(-1)).toEqual(-1);
        expect(rowset1.getRowIndex(0)).toEqual(0);
        expect(rowset1.getRowIndex(1)).toEqual(1);
    });

    it('AddRow', () => {
        // STUB
    });

    it('InsertRowAt', () => {
        // STUB
    });

    it('InsertRow', () => {
        // STUB
    });

    it('RemoveRow', () => {
        // STUB
    });

    it('RemoveColumn', () => {
        // STUB
    });

    it('IsRowDefault', () => {
        const rowset = new Rowset({
            _TCF_Rowset: 'version=1',
            mode: 0,
            header: [{ name: 'Col1', type: '10' }, { name: 'Col2', type: '10' }, { name: 'Col3', type: '10' }],
            defaults: ['C1A', 'C2B', 'C3C'],
            data: [['C', 'C', 'C'], ['C1A', 'C2B', 'C3C'], ['1', '2', '3'], ['C1A', 'C2B', 'C3C'], ['A', 'B', 'C']],
        });

        expect(rowset.isRowDefault(0)).toBe(false);
        expect(rowset.isRowDefault(2)).toBe(false);
        expect(rowset.isRowDefault(4)).toBe(false);

        expect(rowset.isRowDefault(1)).toBe(true);
        expect(rowset.isRowDefault(3)).toBe(true);
    });

    it('ToString', () => {
        expect(rowset2.toString()).toEqual(
            'Rows: 4 Columns: 11 Column Names: _Boolean_1,_Boolean_2,_Boolean_3,_Int32_1,_Int32_2,_Double_1,_Double_2,_String_1,_String_2,_Duplicate,_NaN',
        );
    });

    it('ToArray', () => {
        expect(rowset2.toArray()).toEqual([
            {
                _Boolean_1: false,
                _Boolean_2: true,
                _Boolean_3: false,
                _Int32_1: -1,
                _Int32_2: 10,
                _Double_1: -1.1,
                _Double_2: 10.1,
                _String_1: '-1',
                _String_2: '10',
                _Duplicate: -5,
                _NaN: 'a',
            },
            {
                _Boolean_1: false,
                _Boolean_2: true,
                _Boolean_3: true,
                _Int32_1: 0,
                _Int32_2: 20,
                _Double_1: -1.2,
                _Double_2: 10.01,
                _String_1: '0',
                _String_2: '20',
                _Duplicate: -5,
                _NaN: 'b',
            },
            {
                _Boolean_1: false,
                _Boolean_2: true,
                _Boolean_3: true,
                _Int32_1: 0,
                _Int32_2: 20,
                _Double_1: -1.2,
                _Double_2: 10.01,
                _String_1: '0',
                _String_2: '20',
                _Duplicate: 5,
                _NaN: 'c',
            },
            {
                _Boolean_1: false,
                _Boolean_2: true,
                _Boolean_3: false,
                _Int32_1: 1,
                _Int32_2: 30,
                _Double_1: -1.3,
                _Double_2: 10.001,
                _String_1: '1',
                _String_2: '30',
                _Duplicate: 5,
                _NaN: 'd',
            },
        ]);
    });

    it('AsArray', () => {
        expect(rowset2.asArray()).toEqual([
            {
                _Boolean_1: false,
                _Boolean_2: true,
                _Boolean_3: false,
                _Int32_1: -1,
                _Int32_2: 10,
                _Double_1: -1.1,
                _Double_2: 10.1,
                _String_1: '-1',
                _String_2: '10',
                _Duplicate: -5,
                _NaN: 'a',
            },
            {
                _Boolean_1: false,
                _Boolean_2: true,
                _Boolean_3: true,
                _Int32_1: 0,
                _Int32_2: 20,
                _Double_1: -1.2,
                _Double_2: 10.01,
                _String_1: '0',
                _String_2: '20',
                _Duplicate: -5,
                _NaN: 'b',
            },
            {
                _Boolean_1: false,
                _Boolean_2: true,
                _Boolean_3: true,
                _Int32_1: 0,
                _Int32_2: 20,
                _Double_1: -1.2,
                _Double_2: 10.01,
                _String_1: '0',
                _String_2: '20',
                _Duplicate: 5,
                _NaN: 'c',
            },
            {
                _Boolean_1: false,
                _Boolean_2: true,
                _Boolean_3: false,
                _Int32_1: 1,
                _Int32_2: 30,
                _Double_1: -1.3,
                _Double_2: 10.001,
                _String_1: '1',
                _String_2: '30',
                _Duplicate: 5,
                _NaN: 'd',
            },
        ]);
    });

    it('ForEach', () => {
        rowset2.forEach(row => {
            expect(row instanceof RowsetRow).toBe(true);
        });

        let results = [];
        rowset2.forEach(row => {
            results.push(row);
            return true;
        });
        expect(results.length).toEqual(1);

        results = [];
        rowset2.forEach(value => {
            results.push(value);
        }, '_Int32_2');
        expect(results).toEqual([10, 20, 20, 30]);

        results = [];
        rowset2.forEach(value => {
            results.push(value);
            return true;
        }, '_Int32_2');
        expect(results).toEqual([10]);
    });
});

describe('RowsetRow', () => {
    beforeEach(() => {
        // @ts-ignore
        jasmine.addMatchers(customMatchers);
    });

    const rowset1 = new Rowset({
        _TCF_Rowset: 'version=1',
        mode: 0,
        header: [
            { name: '_Null', type: '1' },
            { name: '_Boolean', type: '1' },
            { name: '_Int32', type: '8' },
            { name: '_Double', type: 'C' },
            { name: '_String', type: '10' },
        ],
        defaults: [null, null, null, null, null],
        data: [[null, false, 0, 0, ''], [null, true, 1, 1.1, 'a'], [null, true, 2, 2.2, 'b']],
    });

    const rowset2 = new Rowset({
        _TCF_Rowset: 'version=1',
        mode: 0,
        header: [
            { name: '_Editable1', type: '10' },
            { name: '_Editable2', type: '10', displayMode: 0 },
            { name: '_ReadOnly', type: '10', displayMode: 1 },
        ],
        defaults: [null, null, null],
        data: [['Editable', 'Editable', 'ReadOnly'], ['Editable', 'Editable', 'ReadOnly']],
    });

    const rowset3 = new Rowset({
        _TCF_Rowset: 'version=1',
        mode: 0,
        header: [
            { name: '_Null', type: '1' },
            { name: '_Boolean', type: '1' },
            { name: '_Int32', type: '8' },
            { name: '_Double', type: 'C' },
            { name: '_String', type: '10' },
        ],
        defaults: [null, null, null, null, null],
        data: [[null, false, 0, 0, ''], [null, true, 1, 1.1, 'a'], [null, true, 2, 2.2, 'b']],
    });

    it('GetHeader', () => {
        expect(rowset1.getRow(0).getHeader(0)).toEqual({ name: '_Null', type: '1' });
        expect(rowset1.getRow(0).getHeader(1)).toEqual({ name: '_Boolean', type: '1' });
        expect(rowset1.getRow(0).getHeader(2)).toEqual({ name: '_Int32', type: '8' });
        expect(rowset1.getRow(0).getHeader(3)).toEqual({ name: '_Double', type: 'C' });
        expect(rowset1.getRow(0).getHeader(4)).toEqual({ name: '_String', type: '10' });
    });

    it('GetField', () => {
        expect(rowset1.getRow(1).getField(0)).toEqual(null);
        expect(rowset1.getRow(1).getField(1)).toEqual(true);
        expect(rowset1.getRow(1).getField(2)).toEqual(1);
        expect(rowset1.getRow(1).getField(3)).toEqual(1.1);
        expect(rowset1.getRow(1).getField(4)).toEqual('a');
    });

    it('SetField', () => {
        [false, true, 100, 100.001, 'ABC'].forEach((value, c) => {
            const row = rowset3.getRow(1);
            row.setField(c, value);

            expect(row.getField(c)).toEqual(value);
        });

        ['_Null', '_Boolean', '_Int32', '_Double', '_String'].forEach(c => {
            const row = rowset3.getRow(1);

            expect(row.getField(c)).not.toBeNull();
            row.setField(c, null);
            expect(row.getField(c)).toBeNull();
        });

        for (let r = 0, rows = rowset2.getRowCount(); r < rows; r++) {
            expect(rowset2.getField(r, 0)).toEqual('Editable');
            expect(rowset2.getField(r, 1)).toEqual('Editable');
            expect(rowset2.getField(r, 2)).toEqual('ReadOnly');

            rowset2.getRow(r).setField(0, 'Edited');
            rowset2.getRow(r).setField(1, 'Edited');
            rowset2.getRow(r).setField(2, 'Edited');

            expect(rowset2.getField(r, 0)).toEqual('Edited');
            expect(rowset2.getField(r, 1)).toEqual('Edited');
            expect(rowset2.getField(r, 2)).toEqual('ReadOnly');
        }
    });

    it('GetColIndex', () => {
        expect(rowset1.getRow(0).getColIndex(0)).toEqual(0);
        expect(rowset1.getRow(0).getColIndex(1)).toEqual(1);
        expect(rowset1.getRow(0).getColIndex(2)).toEqual(2);
        expect(rowset1.getRow(0).getColIndex(3)).toEqual(3);
        expect(rowset1.getRow(0).getColIndex(4)).toEqual(4);

        expect(rowset1.getRow(0).getColIndex('_Null')).toEqual(0);
        expect(rowset1.getRow(0).getColIndex('_Boolean')).toEqual(1);
        expect(rowset1.getRow(0).getColIndex('_Int32')).toEqual(2);
        expect(rowset1.getRow(0).getColIndex('_Double')).toEqual(3);
        expect(rowset1.getRow(0).getColIndex('_String')).toEqual(4);
    });

    it('GetColCount', () => {
        expect(rowset1.getRow(0).getColCount()).toEqual(5);
    });

    it('GetColumnName', () => {
        expect(rowset1.getRow(0).getColumnName(0)).toEqual('_Null');
        expect(rowset1.getRow(0).getColumnName(1)).toEqual('_Boolean');
        expect(rowset1.getRow(0).getColumnName(2)).toEqual('_Int32');
        expect(rowset1.getRow(0).getColumnName(3)).toEqual('_Double');
        expect(rowset1.getRow(0).getColumnName(4)).toEqual('_String');
    });

    it('AsObject', () => {
        expect(rowset1.getRow(0).asObject() instanceof Object).toBe(true);

        expect(rowset1.getRow(0).asObject()).toEqual({
            _Null: null,
            _Boolean: false,
            _Int32: 0,
            _Double: 0,
            _String: '',
        });
        expect(rowset1.getRow(1).asObject()).toEqual({
            _Null: null,
            _Boolean: true,
            _Int32: 1,
            _Double: 1.1,
            _String: 'a',
        });
        expect(rowset1.getRow(2).asObject()).toEqual({
            _Null: null,
            _Boolean: true,
            _Int32: 2,
            _Double: 2.2,
            _String: 'b',
        });

        expect(new RowsetRow(rowset2, -1).asObject()).toEqual({
            _Editable1: '_Editable1',
            _Editable2: '_Editable2',
            _ReadOnly: '_ReadOnly',
        });
    });
});
